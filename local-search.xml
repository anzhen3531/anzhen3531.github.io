<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM几大常见面试题"><a href="#JVM几大常见面试题" class="headerlink" title="JVM几大常见面试题"></a>JVM几大常见面试题</h2><p>JVM运行机制？？</p><blockquote></blockquote><p>什么是类加载过程 </p><blockquote><p>将class文件加载进运行时数据区里面去</p></blockquote><p>什么是JVM??</p><blockquote><p>用来解析和运行Java程序的虚拟机进程</p></blockquote><p>请说一下JVM内存结构</p><blockquote><p>虚拟机栈， 程序计数器，堆内存，元空间， 本地方法栈</p></blockquote><p>说一下垃圾回收算法</p><blockquote><p>标记清楚，复制， 标记压缩</p></blockquote><p>说一下垃圾回收器</p><blockquote><p>G1</p></blockquote><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>什么是类加载 ？ </p><blockquote><p>类加载分为5个步骤 ， 加载 验证  准备  解析  初始化   这5个步骤 ， 其中除去解析外，其他的步骤都是按照顺序执行的</p></blockquote><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><blockquote><p>查找并加载类的二级制数据</p></blockquote><p>加载类的第一个步骤 ： 加载阶段JVM要做的事为三件 </p><ol><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流文件静态存储结构转换为方法区运行时结构</li><li>在Java堆中生成代表这个类的Class对象，作为方法区这些数据的访问入口</li></ol><h3 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p> 保证类的安全性</p></blockquote><p>为保证Class文件的字节流中包含信息符合当前虚拟机的要求，并不会危害虚拟机本身验证阶段大致分为4个阶段</p><ol><li>文件格式验证  ： 检验加载的是否是符合Class文件规范</li><li>元数据验证  ： 对字节码的描述信息进行语义分析</li><li>字节码验证  ： 通过数据流和控制流进行分析，确定语义是合法的，符合逻辑的</li><li>符号引用验证  ：<strong>确保解析</strong>操作能正确执行</li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p>为类的静态变量分配内存，并将其初始化为默认值</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>把类中的符号引用直接转化为直接引用</p></blockquote><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类，接口，字段，类方法，接口方法，方法类型，方法句柄，调用点，限定符7类符号引用。</p><blockquote><p>符号引用就是一组符号来描述目标，可以是任何字面量</p></blockquote><blockquote><p>直接引用就是直接执行目标的指针，相对偏移量或者是一个间接到目标的句柄</p></blockquote><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化，为类的静态变量赋值正确的初始值，JVM负责对类进行初始化，只要对类变量进行初始化。在Java中对类变量进行初始化设定的俩种方式</p><ul><li>声明类变量时指定初始值</li><li>使用静态代码块为类变量进行指定初始值</li></ul><p>JVM初始化步骤</p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类没有初始化，先初始化父类</li><li>假如类中有初始化语句，则程序依次执行这些初始化语句</li></ul><p>类初始化时机:只有当类的主动使用的时候才会导致类的初始化，类的主动</p><p>使用包括以下的6种:</p><ul><li>使用new的方式</li><li>通过反射</li><li>初始化某个类的子类 </li><li>启动时被表明为启动类的类</li><li>调用类的静态方法</li><li>访问某个类的静态方法或者对静态变量赋值</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区内的数据结构的接口，对象是Heap区的数据。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>Java虚拟机将结束生命周期的几种方式</p><ul><li>执行了System.exit</li><li>程序正常执行结束</li><li>执行中出现异常</li><li>操作系统出现错误，导致虚拟机进程终止</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载分为3种 </p><blockquote><p>应用加载器   - &gt;     扩展类加载器   -&gt;   启动类加载器</p></blockquote><h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ul><li><p>全盘负责</p><ul><li><blockquote><p>当一个类加载器加载某个Class时，该Class所依赖的和引用的其他Class也将由该类Class加载器负责载入，除非显示使用另一个类加载器来载入</p></blockquote></li></ul></li><li><p>父类委托</p><ul><li><blockquote><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己类路径中加载该类</p></blockquote></li></ul></li><li><p>缓存机制</p><ul><li><blockquote><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序需要使用某个Class时，类加载器先从缓存区寻找Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。</p></blockquote></li></ul></li><li><p>双亲委派</p><ul><li><blockquote><p>如果一个类加载器收到了类加载的请求，他首先不会自己先尝试加载该类，先将请求转交给父类加载器完成，依次向上，所有类加载的请求最终都会被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，就无法完成加载，子加载器才会尝试自己去加载该类</p></blockquote></li></ul><p>双亲委派机制优点</p><blockquote><p>保护了Java核心类库不被修改</p><p>防止内存中出现相同的字节码</p></blockquote></li></ul><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>JVM运行时数据区数据区的内存结构 </p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><blockquote><p>Java栈，每个线程在创建的时候 ，都会创建一个虚拟机栈，其内部保存一个个<strong>栈帧</strong>，对应着一次次java方法调用，线程私有的，生命周期和线程生命周期一样</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p>主管Java程序的运行，它保存方法的局部变量，部分结果，参与方法的调用和返回</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>先进后出</li><li>不需要垃圾回收</li><li>快速有效的分配存储方式，访问速度仅次于程序计数器</li></ul><p>虚拟机栈会出现的异常：</p><p>OutOfMemoryError(内存溢出错误)   // 采用动态扩展的虚拟机栈</p><p>StackOverflowError （栈溢出错误） // 采用固定大小的虚拟机栈</p><p>虚拟机栈大小是固定的吗? </p><blockquote><p>Java规范虚拟机栈大小是动态的或者是固定不变的</p></blockquote><h4 id="虚拟机栈存储单位"><a href="#虚拟机栈存储单位" class="headerlink" title="虚拟机栈存储单位"></a>虚拟机栈存储单位</h4><p>栈中存储什么？ </p><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧的格式存在</strong></li><li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li><li>栈帧是一块内存区域，是一个数据集，维系着方法执行过程中各种数据信息</li></ul><h4 id="栈帧中的内部结构"><a href="#栈帧中的内部结构" class="headerlink" title="栈帧中的内部结构"></a>栈帧中的内部结构</h4><p>局部变量表，操作数栈，动态链接，方法返回地址，一些附加信息</p><p>图解</p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt="jvm-stack-frame"></p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><p>堆区分为哪三块区域（分代唯一理由就是优化GC）</p><ul><li>老年代   ： 新对象和没到达一定年龄的对象都在新生代</li><li>新生代 ： 被长时间使用的对象，老年代的内存要比新生代要大</li><li>永久代（元空间）： 像一些方法中操作的临时对象等</li></ul><p>内存结构图（JDK7）<img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" alt="JDK7"></p><h4 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h4><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集器。这种垃圾收集称为MinorGC。年轻一代被分为三个部分–伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1） 比例时8：1：1</p><ul><li>大多数新生对象都位于Eden内存空间中</li><li>当Eden空间被对象填充时，执行minorGc，并将所有幸存者对象移动到一个幸存者空间中</li><li>当MInorGC检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，总有一个幸存者空间是空的</li><li>经过多次GC循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老年代</li></ul><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>存储的是一些从年轻代存活下来的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集成为MajorGC，通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是减少年轻代发送大量内存拷贝</p><h5 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h5><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" alt="img"></p><p>JDK8元空间直接移动到本地内存 </p><h4 id="永久代（元空间）"><a href="#永久代（元空间）" class="headerlink" title="永久代（元空间）"></a>永久代（元空间）</h4><p>JDK8移动到了 本地内存 </p><p>GC垃圾回收器简介</p><p>MinorGC, MajorGC,FullGC</p><p>部分收集 : 不是完整收集整个Java堆的垃圾收集、</p><ul><li>新生代收集<ul><li>（MInorGC）只是对新生代收集</li></ul></li><li>老年代收集<ul><li>MajorGC只是老年代的垃圾回收</li></ul></li><li>混合收集<ul><li>收集整个新生代以及部分老年代的垃圾回收</li><li>目前只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC） : 收集整个Java堆和方法区的垃圾对象</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><blockquote><p>程序计数器是一块较小的内存空间，可以当作是当前线程所执行的字节码的行号指示器</p></blockquote><h4 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h4><blockquote><p>存储执行下一条指令的地址，即将要执行的指令代码。有执行引擎获取下一条指令</p></blockquote><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>是一块很小的内存，基本上可以忽略不计，也是运行速度最快的存储区域</li><li>这个是线程私有的，每个线程独有一份，生命周期和线程生命周期一样</li><li>这块内存是JVM中没有OutofMemoryError错误</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条，需要执行的字节码指令</li><li>任何一个线程都只有一个方法执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是Java方法，程序计数器记录的是JVM字节码指令地址，如果执行的是本地方法，则是未指定值</li><li>它是流程控制的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都要依赖这个计数器完成</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>方法区用于存储已被虚拟机加载到类型信息、常量、静态变量、即时编译器编译后的代码缓存</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p>在Hotspot虚拟机中，直接将本地方法栈和虚拟机栈合二为一</p></blockquote><p>那些内存是线程共享的，那些是线程私有的 </p><ul><li>线程私有：本地方法栈 ， 虚拟机栈 ，程序计数器</li><li>线程共享：堆，方法区，元空间</li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>常见的垃圾回收器</p><blockquote><p>CMS ,G1 </p></blockquote><p>垃圾回收算法 </p><blockquote><p>标记清除，标记整理，复制</p></blockquote><h3 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h3><ul><li><strong>引用计数算法</strong> </li></ul><blockquote><p>给对象添加一个引用计数器，当对象增加一个引用时加1，引用失效时-1,当引用计数器=0的时候进行回收</p><p>如果两个对象出现循环依赖的问题，此时引用计数器永远不为0，无法进行回收    ，Java虚拟机不使用此算法</p></blockquote><ul><li><strong>可达性分析</strong></li></ul><blockquote><p>可达性分析算法： </p><p>通过GCRoots 作为起始点进行搜索，能够达到的对象都是存活的，没用达到的直接回收</p></blockquote><p>Java虚拟机使用该算法来判断对象是否可以回收，在Java中GC Roots一般包含以下内容</p><ul><li>虚拟机栈的引用</li><li>本地方法栈的引用</li><li>方法区常量的引用对象</li><li>方法区类静态属性引用的对象</li></ul><ul><li><h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4></li></ul><p>方法区主要放永久代对象，而永久代对象回收率比新生代低很多，因此方法区上进行回收性价比不高。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计算算法判断对象的引用数量，还是通过GC Roots来判断对象是否可达，判断对象是否可以被回收都与引用有关。</p><p>Java有四种强度不同的引用类型</p><h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h4><p>被强引用关联的对象不会被回收</p><p>使用new一个新对象来创建强引用</p><blockquote><p>Object obj = new Object();</p></blockquote><h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会回收</p><p>使用SoftReference类来创建软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Object obj = <span class="hljs-keyword">new</span> Object();<br>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> SoftReference&lt;Object&gt;(obj);<br>obj = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 使对象只被软引用关联</span><br></code></pre></td></tr></table></figure><h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收之前</p><p>使用WealReference类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Object obj = <span class="hljs-keyword">new</span> Object();<br>WeakReference&lt;Object&gt; wf = <span class="hljs-keyword">new</span> WeakReference&lt;Object&gt;(obj);<br>obj = <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h4><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目标就是能在这个对象被回收时收到的一个系统通过。</p><p>PhantomReference使用这个设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Object obj = <span class="hljs-keyword">new</span> Object();<br>PhantomReference&lt;Object&gt; pf = <span class="hljs-keyword">new</span> PhantomReference&lt;Object&gt;(obj);<br>obj = <span class="hljs-keyword">null</span>;<br><br></code></pre></td></tr></table></figure><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>垃圾收集算法有哪几种</p><blockquote><p>标记清除，复制， 标价压缩</p></blockquote><h4 id="1、标价-清除"><a href="#1、标价-清除" class="headerlink" title="1、标价-清除"></a>1、标价-清除</h4><p>图解：</p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="image"></p><p>将存活的对象进行标记，然后清理未标记的对象</p><p>不足</p><ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象提供内存</li></ul><h4 id="2、标记-整理"><a href="#2、标记-整理" class="headerlink" title="2、标记-整理"></a>2、标记-整理</h4><p>图解：</p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="image"></p><p>让存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><h4 id="3、复制"><a href="#3、复制" class="headerlink" title="3、复制"></a>3、复制</h4><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="image"></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就还将存活对象复制到这另一块上面，然后再把使用过的内存区域进行一次清理</p><p>主要不足是只使用内存的一半</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p><h4 id="4、分代收集"><a href="#4、分代收集" class="headerlink" title="4、分代收集"></a>4、分代收集</h4><p>现在的商用虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同的采用不同的算法</p><p>一般将堆分为新生代和老年代</p><ul><li>新生代使用：标记-清除或者标记-整理算法</li><li>老年代使用：复制算法 </li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="image"></p><p>以上是HotSpot虚拟机中的7个垃圾收集器，连线表示收集器可以配合使用    </p><ul><li>单线程和多线程：单线程指的是垃圾收集器只是用一个线程进行收集，而多线程可以使用    多个线程 </li><li>串行和并行：<ul><li>串行指的是垃圾回收器与应用程序交替执行，意味着在执行垃圾收集的时候要停顿用户程序；</li><li>并行指的是垃圾收集器和用户程序同时执行。<strong>除了CMS和G1，其他的垃圾收集器都是以串行的方式执行</strong></li></ul></li></ul><h4 id="1、Serial收集器"><a href="#1、Serial收集器" class="headerlink" title="1、Serial收集器"></a>1、Serial收集器</h4><p>图解：</p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="image"></p><p>串行的垃圾收集器，是单线程的，只会有一个线程进行垃圾收集工作</p><h4 id="2、ParNew收集器"><a href="#2、ParNew收集器" class="headerlink" title="2、ParNew收集器"></a>2、ParNew收集器</h4><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="image"></p><p>它是Serial收集器的多线程版本。</p><p>是服务模式下的虚拟机首选的新生代垃圾收集器，选这个原因是CMS只能和这个配合使用</p><h4 id="3、Parallel-Scavenge-收集器"><a href="#3、Parallel-Scavenge-收集器" class="headerlink" title="3、Parallel    Scavenge  收集器"></a>3、Parallel    Scavenge  收集器</h4><p>与ParNew一样是多线程收集器。</p><p>其他垃圾收集器关注点是尽可能缩短垃圾收集时用户线程停顿的时间，而它的目标是达到一个可以控制的吞吐量，它称之为”吞吐量优先”垃圾收集器。这里的吞吐量值CPU用于运行用户代码的时间占总时间的比例。</p><p>停顿时间越短就越适合需要与用户进行交互的程序，良好的响应速度提升用户体验。而高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：    新生代空间变小，导致垃圾回收频繁，降低吞吐量</p><h4 id="4、Serial-Old垃圾收集器"><a href="#4、Serial-Old垃圾收集器" class="headerlink" title="4、Serial Old垃圾收集器"></a>4、Serial Old垃圾收集器</h4><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="image"></p><p>是Serial收集器的老年代版本，也是给Client模式下的虚拟机使用。</p><p>如果在Server模式下，它有俩大用途：</p><ul><li>在JDK1.5以及之前（Parallel  Old诞生之前）版本中与Parallel   Scavange收集器的搭建使用</li><li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。</li></ul><h4 id="5、Parallel-Old-收集器"><a href="#5、Parallel-Old-收集器" class="headerlink" title="5、Parallel Old 收集器"></a>5、Parallel Old 收集器</h4><p>Parallel Scavenge收集器的老年代版本</p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="image"></p><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge    加   Parallel  Old收集器</p><h4 id="6、CMS收集器"><a href="#6、CMS收集器" class="headerlink" title="6、CMS收集器"></a>6、CMS收集器</h4><p>CMS     (Concurrent  Mark   Sweep ) ， Mark  Sweep 指的标记</p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="image"></p><p>运行流程: </p><ol><li>初始标记      <ol><li>仅仅是标记一下GC Roots能够直接到达的对象，速度很快，需要停顿</li></ol></li><li>并发标记<ol><li>进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿</li></ol></li><li>重写标记<ol><li>为了修正<strong>并发标记期间因用户进程继续运行而导致标记产生变动</strong>的那一部分对象的标记记录，需要停顿。</li></ol></li><li>并发清理<ol><li>不需要停顿</li></ol></li></ol><p>缺点如下 ：</p><ul><li><strong>吞吐量低</strong>： 低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高</li><li><strong>无法处理浮动垃圾</strong>，可能出现Concurrent  Mode  Failure。 浮动垃圾是指并发清理阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC的时候才能被回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着CMS收集不能像其他垃圾收集器一样等待老年代快满的时候进行回收。如果预留的内存不够存放浮动垃圾就会出现Concurrent  Mode  Failure，这时候虚拟机将临时SerialOld来替换CMS。</li><li><strong>标记-清除算法导致的空间碎片</strong>，往往出现老年代空间剩余，但是无法找到足够大连续的空间来分配对象时，不得不提前触发一次FullGC</li></ul><h4 id="7、G1垃圾收集器"><a href="#7、G1垃圾收集器" class="headerlink" title="7、G1垃圾收集器"></a>7、G1垃圾收集器</h4><p>是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。</p><p>堆被分为新生代和老年代，其他的收集器的范围都是针对新生代或者是老年代的，而G1可以对俩个区域一起回收</p><p>G1把堆划分成多个大小相等的独立区域（Region），新生代和老年代不在物理隔离</p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="image"></p><p>​    通过引入Region的概念，从而使一块完整内存空间划分多个的小空间，使得每个小空间。这种划分方法带来了很大灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验得到），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>每个Region都有一个Remembered  Set，用来记录该Region对象的引用对象所在的Region。通过使用Remembered Set ，在做可达性分析的时候就可以避免全盘扫描。</p><p>图解 ： </p><p><img src="/2021/07/15/JVM%E5%AD%A6%E4%B9%A0/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="image"></p><p>如果不计算维护Remembered Set的操作，G1收集器运动大致分为以下几个步骤</p><ul><li><p>初始标记 ：</p></li><li><p>并发标记 ： </p></li><li><p>最终标记 ：</p><ul><li>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li></ul></li><li><p>筛选回收 ：</p><ul><li>首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul></li></ul><p>具备以下优点：</p><ul><li>空间整合：</li><li>可预测的停顿 ：</li></ul><h3 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h3><p>MinorGC 和 FullGC</p><ul><li>minorGC : 发生在新生代上，因为新生代对象存活时间短，因此MinorGC会频繁的执行，执行速度一般也会比较快</li><li>FullGC：发生在老年代上，老年代对象存活时间长，因此FullGC很少执行，执行速度会比MinorGC慢很多</li></ul><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><h5 id="1、新生对象直接分配到Eden"><a href="#1、新生对象直接分配到Eden" class="headerlink" title="1、新生对象直接分配到Eden"></a>1、新生对象直接分配到Eden</h5><blockquote><p>新创建的对象直接进入Eden，如果内存不够的话，直接执行一次MinorGC</p></blockquote><h5 id="2、大对象直接进入老年代"><a href="#2、大对象直接进入老年代" class="headerlink" title="2、大对象直接进入老年代"></a>2、大对象直接进入老年代</h5><blockquote><p>大对象指那些需要连续存储空间的对象，典型的大对象，就是那种很长的字符串和数组</p><p>经常出现大对象会提前触发垃圾收集以获取足够大的连续空间分配给大对象    </p></blockquote><h5 id="3、存活时间周期长进入老年代"><a href="#3、存活时间周期长进入老年代" class="headerlink" title="3、存活时间周期长进入老年代"></a>3、存活时间周期长进入老年代</h5><blockquote><p>为对象定义年龄计数器，对象在Eden出生并经过MinorGC还活着之后，将移动到Survivor中，年龄就增加一岁，增加到一定年龄则移动到老年代中</p></blockquote><h5 id="4、动态对象年龄判断"><a href="#4、动态对象年龄判断" class="headerlink" title="4、动态对象年龄判断"></a>4、动态对象年龄判断</h5><blockquote><p>虚拟机并不是永远地需要对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Surivior中相同的所有的对象大小总和大于Surivior空间的一半，则年龄大于或者等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</p></blockquote><h5 id="5、空间分配担保"><a href="#5、空间分配担保" class="headerlink" title="5、空间分配担保"></a>5、空间分配担保</h5><blockquote><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</p></blockquote><h4 id="FullGC的触发条件"><a href="#FullGC的触发条件" class="headerlink" title="FullGC的触发条件"></a>FullGC的触发条件</h4><h5 id="1、调用System-gc"><a href="#1、调用System-gc" class="headerlink" title="1、调用System.gc()"></a>1、调用System.gc()</h5><blockquote><p>只是建议虚拟机执行一下FullGC，但是虚拟机不一定真正执行</p></blockquote><h5 id="2、老年代空间不足"><a href="#2、老年代空间不足" class="headerlink" title="2、老年代空间不足"></a>2、老年代空间不足</h5><blockquote><p>老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等</p></blockquote><h5 id="3、空间分配担保失败"><a href="#3、空间分配担保失败" class="headerlink" title="3、空间分配担保失败"></a>3、空间分配担保失败</h5><blockquote><p>使用复制算法的MinorGC需要老年代的内存空间做担保，如果担保失败会执行一次FullGC</p></blockquote><h5 id="4、Concurrent-Mode-Failure"><a href="#4、Concurrent-Mode-Failure" class="headerlink" title="4、Concurrent  Mode   Failure"></a>4、Concurrent  Mode   Failure</h5><blockquote><p>执行CMS GC 的过程中同时有对象要放入老年代，而此同时老年代的空间不足，便会报Concurrent  Mode   Failure，并触发fullGC</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="Java基础理论"><a href="#Java基础理论" class="headerlink" title="Java基础理论"></a>Java基础理论</h2><h3 id="常见Java多线程问题"><a href="#常见Java多线程问题" class="headerlink" title="常见Java多线程问题"></a>常见Java多线程问题</h3><p>什么是多线程? </p><blockquote></blockquote><p>多线程的出现是要解决什么问题的?</p><blockquote><p>提高效率 </p></blockquote><p>线程不安全是指什么? 举例说明</p><blockquote><p>多个线程在操作共同数据时， 数据会发生错乱。 </p></blockquote><p>并发出现线程不安全的本质什么?</p><blockquote><p>可见性，原子性和有序性。</p></blockquote><p>Java是怎么解决并发问题的?</p><blockquote><p>3个关键字，JMM和8个Happens-Before</p></blockquote><p>线程安全是不是非真即假? </p><blockquote><p>不是</p><p>线程安全是一个类在多个线程安全调用的情况就是线程安全 </p><p>线程安全根据共享数据的安全程度来分成 ：不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</p></blockquote><p>线程安全有哪些实现思路?</p><blockquote><p>互斥同步（阻塞同步），非阻塞同步（CAS）， 无同步方案（）</p></blockquote><p>如何理解并发和并行的区别</p><blockquote><p>并发是一段时间一个线程执行多个任务，  并行是同一个时间点多个线程执行多个任务</p></blockquote><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程 ??"></a>为什么需要多线程 ??</h3><p>内存/cpu/IO设备的速度是有很大的差距的,为了合理利用CPU的高性能,平衡这三者的速度差异,让计算机体系结构,操作系统,编译程序都做出了巨大贡献,主要体现为:</p><ul><li>cpu出现了缓存,以均衡与内存的速度差异  // 导致了 可见性的问题</li><li>操作系统增加了进程,线程,分时复用CPU,进而均衡CPU和IO设备的差异  //  导致了原子性</li><li>编译程序优化指令执行次序,使缓存能够得到更加合理地利用   // 导致了有序性</li></ul><h3 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="headerlink" title="并发出现问题的根源: 并发三要素"></a>并发出现问题的根源: 并发三要素</h3><h4 id="可见性-CPU缓存引起"><a href="#可见性-CPU缓存引起" class="headerlink" title="可见性 :  CPU缓存引起"></a>可见性 :  CPU缓存引起</h4><p>​        一个线程对共享变量的修改,另外一个线程能够立即看到</p><h4 id="原子性-分时复用引起"><a href="#原子性-分时复用引起" class="headerlink" title="原子性:   分时复用引起"></a>原子性:   分时复用引起</h4><p>​        即一个操作或多个操作,要么全部执行并且执行过程不会被任何因素打乱,要么就不执行</p><h4 id="有序性-指令重排引起"><a href="#有序性-指令重排引起" class="headerlink" title="有序性:   指令重排引起"></a>有序性:   指令重排引起</h4><p>​        有序性:即程序执行的顺序按照代码的先后顺序</p><h3 id="Java是如何解决并发问题的"><a href="#Java是如何解决并发问题的" class="headerlink" title="Java是如何解决并发问题的"></a>Java是如何解决并发问题的</h3><blockquote><p>使用JMM(Java内存模型)</p></blockquote><h4 id="理解第一个维度"><a href="#理解第一个维度" class="headerlink" title="理解第一个维度"></a>理解第一个维度</h4><p>JMM本质上可以理解为,Java内存模型规范了,JVM如何提供按需警用缓存和编译优化的方法.  具体来说,这些方法包括</p><ul><li>volatile    synchronized     final  三个关键字</li><li>Happens - Before规则</li></ul><h4 id="理解第二个维度"><a href="#理解第二个维度" class="headerlink" title="理解第二个维度"></a>理解第二个维度</h4><ul><li><p>原子性</p><ul><li><blockquote><p>Java内存模型保证了基本读取和赋值操作时原子性,如果要大面积实现更大范围操作的原子性,可以通过synchronized 和 Lock来实现.由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块,那么自然就不存在原子性问题了,从而保证了原子性</p></blockquote></li></ul></li><li><p>可见性</p><ul><li><p>Java提供了volatile来保证可见性</p></li><li><p>当一个共享变量被修改时,它会保证修改的值会立即被更新到主存,当有其他线程需要读取时,它会去内存中读取新值.</p><ul><li><blockquote><p>然而 synchronized和Lock也能保证可见性,synchronized和lock能保证同一时刻只有一个线程获取锁然后执行同步代码,并且在释放锁之前会将对变量的修改刷新到主存中. 因此保证可见性</p></blockquote></li></ul></li></ul></li><li><p>有序性 </p><blockquote><p>可以使用volatile来保证有序性 </p><p>可以使用synchronized和Lock保证有序性</p><p>JMM是通过Happens -Before来保证有序性 </p></blockquote></li></ul><h4 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h4><p>上面提到了synchroized和lock来保证有序性.  除此之外JMM还规定了先行发生原则,让一个操作无需控制就能先于另一个操作完成 .</p><h5 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h5><blockquote><p>single  Thread  rule </p></blockquote><p>在一个线程内,在程序前面的操作先行与发生于后面的操作</p><p><img src="https://www.pdai.tech/_images/pics/single-thread-rule.png" alt="image"> </p><h5 id="2-管道锁定规则"><a href="#2-管道锁定规则" class="headerlink" title="2.管道锁定规则"></a>2.管道锁定规则</h5><blockquote><p>Monitor   Lock   Rule</p></blockquote><p>一个unLock操作先行发生于后面对同一个锁的Lock操作 </p><p><img src="https://www.pdai.tech/_images/pics/monitor-lock-rule.png" alt="image">  </p><p>3.volatile变量原则</p><blockquote><p>Volatile  Varible  Rule </p></blockquote><p>对一个Volatile的变量的写操作先行发生于后面对这个变量的读操作</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile-variable-rule.png" alt="image"></p><h5 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4.线程启动规则"></a>4.线程启动规则</h5><blockquote><p>Thread  Start     Rule</p></blockquote><p>Thread 对象的 start()方法调用先行发生于此线程的每一个动作.</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/thread-start-rule.png" alt="image"> </p><h5 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5.线程加入规则"></a>5.线程加入规则</h5><blockquote><p>Thread      Join     Rule </p></blockquote><p>Thread对象的结束先行发生于join()方法返回</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/thread-join-rule.png" alt="image"> </p><h5 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6.线程中断规则"></a>6.线程中断规则</h5><blockquote><p>Thread     Interruption  Rule</p></blockquote><p><strong>对线程interrupt()方法的调用先行</strong>发生于被中断线程的代码检测到中断事件的发生,可以通过interrupted()方法检测到是否有中断发生</p><h5 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7.对象终结规则"></a>7.对象终结规则</h5><blockquote><p>finallizer  Rule</p></blockquote><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</p><h5 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8.传递性"></a>8.传递性</h5><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C.</p><h3 id="线程安全-不是一个非真即假的命题"><a href="#线程安全-不是一个非真即假的命题" class="headerlink" title="线程安全:不是一个非真即假的命题"></a>线程安全:不是一个非真即假的命题</h3><p>一个类在可以被多个线程安全调用时就是线程安全的。</p><p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱分成一下五类：不可变、线程绝对安全、相对线程安全、线程兼容和线程对立。</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变的对象一定是线程安全的，不需要再采取任何线程的安全保障措施。只要一个不可变的对象被正确的构建出来，永远也不会看到它在多个线程中处于不一致的状态</p><p>不可变的类型 ： </p><ul><li><p>final字段修饰的基本数据类型 </p></li><li><p>String</p></li><li><p>枚举类型</p></li><li><p>Number部分子类，如Long,Double等数值包装类，BigInteger和BigDecimal等大数据类型。但同为Numher的原子类AtomicInteger 和 AtomicLong 则是可变的。</p></li></ul><p>对于集合类型可以通过Collecitons.unmodifiable(xxx) 获取一个不可变的集合 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个不可变的集合类型</span><br>HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zimu&quot;</span>);<br>Map&lt;String, Object&gt; stringObjectMap =<br>        Collections.unmodifiableMap(map);<br>System.out.println(stringObjectMap.get(<span class="hljs-string">&quot;name&quot;</span>));<br>stringObjectMap.put(<span class="hljs-string">&quot;ziu&quot;</span>, <span class="hljs-number">111</span>);<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">zimu<br>Exception <span class="hljs-keyword">in</span> thread &quot;main&quot; java.lang.UnsupportedOperationException<br><span class="hljs-built_in">at</span> java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="hljs-number">1457</span>)<br><span class="hljs-built_in">at</span> com.anzhen.model.reflect.TestReflect.main(TestReflect.java:<span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><p>为什么put会报错呢？</p><blockquote><p>因为Collecitons.unmodifiable(xxx)会对原先的集合进行拷贝，需要对集合进行修改的方法都是直接抛出异常</p></blockquote><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施</p><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做任何额外的保障措施。</p><p>但是对于一些特定顺序的连续调用，就可能需要在<strong>调用端使用额外的同步手段</strong>来保证调用的正确性</p><p>场景显示</p><p>将元素删除之后进行获取 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>           vector.add(i);<br>       &#125;<br>       ExecutorService executorService = Executors.newCachedThreadPool();<br>       executorService.execute(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>               vector.remove(i);<br>           &#125;<br>       &#125;);<br>       executorService.execute(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>               vector.get(i);<br>           &#125;<br>       &#125;);<br>       executorService.shutdown();<br>   &#125;<br></code></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;pool-25-thread-2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="hljs-number">174</span><br>at java.util.Vector.get(Vector.java:<span class="hljs-number">751</span>)<br>at com.anzhen.model.reflect.TestReflect.lambda$main$<span class="hljs-number">1</span>(TestReflect.java:<span class="hljs-number">31</span>)<br>at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1149</span>)<br>at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">624</span>)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure><p>解决问题的优化 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">executorService.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (vector) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>            vector.remove(i);<br>        &#125;<br>    &#125;<br>&#125;);<br>executorService.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (vector) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>            System.out.println(vector.get(i));<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>对俩个方法进行加锁，保证同步</p><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指<strong>对象本身并不是线程安全的</strong>，但是可以通过在<strong>调用端正确的使用同步手段来保证对象在并发环境中可以安全地使用</strong>，我们通常说一个类是线程不安全通常就是指这种情况</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是<strong>无论调用端是否采取了同步措施</strong>，<strong>都无法在多线程环境中并发使用的代码</strong> </p><p>由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p><p>什么是线程安全 ？？   有哪几种线程安全的 </p><blockquote><p>一个类在多个线程安全调用的情况就是线程安全 </p><p>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</p></blockquote><h3 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h3><h4 id="1、互斥同步"><a href="#1、互斥同步" class="headerlink" title="1、互斥同步"></a>1、互斥同步</h4><p>ReetrantLock 和 synchronized </p><p>初步分析查看 ：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5</a></p><p>详细深入查看文档 ：</p><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p> <a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></p><h5 id="ReetrantLock"><a href="#ReetrantLock" class="headerlink" title="ReetrantLock"></a>ReetrantLock</h5><p> ：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html">https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html</a></p><h4 id="2、非阻塞式同步"><a href="#2、非阻塞式同步" class="headerlink" title="2、非阻塞式同步"></a>2、非阻塞式同步</h4><p>非阻塞式同步和阻塞式同步有什么不同？</p><blockquote><p>阻塞式同步，不论多少线程都只能一条线程进行代码中，并且需要一直加锁放锁会带来性能问题</p></blockquote><h6 id="一-CAS"><a href="#一-CAS" class="headerlink" title="一)CAS"></a>一)CAS</h6><p>使用基于乐观并发策略: 先进行操作，如果没有其他线程争用共享数据，那就操作成功，否则就采取补偿措施（不断重试，直到成功为止）。这种乐观的并发策略都不需要将线程阻塞，因此这种同步操作称之为非阻塞式同步</p><h6 id="二）AtomicIntger"><a href="#二）AtomicIntger" class="headerlink" title="二）AtomicIntger"></a>二）AtomicIntger</h6><p>J.U.C包里面的整数原子类AtomicInteger ，其中的compareAndSet() 和 getAndIncrement()等方法都使用了Unsafe类的CAS操作</p><p>源码奉上</p><p>incrementAndGet获得自增   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="三）-ABA"><a href="#三）-ABA" class="headerlink" title="三） ABA"></a>三） ABA</h6><p>如果一个变量初次读取的时候是A值，它的值被改成了B，后面又被改成A，那CAS操作会认为它没有被进行修改</p><p>JUC提供了一个带有标记的原子引用类AtomicStampedReference来解决这个问题，它可以通过控制变量值的版本来保证CAS的正确性。大部分情况下ABA问题不会影响程序的并发的正确性，如果需要解决这个ABA的问题，该用传统的阻塞式同步会比原子类更加高效</p><h4 id="3、无同步方案"><a href="#3、无同步方案" class="headerlink" title="3、无同步方案"></a>3、无同步方案</h4><h5 id="一）-栈封闭"><a href="#一）-栈封闭" class="headerlink" title="一） 栈封闭"></a>一） 栈封闭</h5><p>因为多个线程要操作共享变量时才会导致线程安全问题 </p><p>多个变量操作局部变量时，不会导致线程安全问题，因为局部变量是存储在虚拟机栈中，每个线程独有一份 </p><h5 id="二）线程本地存储"><a href="#二）线程本地存储" class="headerlink" title="二）线程本地存储"></a>二）线程本地存储</h5><p>如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据是否保证能在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一线程之内，这样，无需同步也能保证线程之间不会出现数据争用问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如生产者和消费者模式) 都会将产品的消费过程尽量在一个线程中消费完。其中一个最典型的应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”的处理方式，这种处理方式广泛使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>Java怎么解决本地线程呢？ </p><blockquote><p>可以使用java.lang.ThreadLocal类来实现线程本地存储功能</p></blockquote><p>案例展示 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;Integer&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;Integer&gt;();<br><span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    stringThreadLocal.set(s + <span class="hljs-number">1</span>);<br>    System.out.println(stringThreadLocal.get());<br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace(); &#125;<br>    stringThreadLocal.remove();<br>&#125;,<span class="hljs-string">&quot;线程一号&quot;</span>).start();<br><br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    stringThreadLocal.set(s + <span class="hljs-number">2</span>);<br>    System.out.println(stringThreadLocal.get());<br>    stringThreadLocal.remove();<br>&#125;,<span class="hljs-string">&quot;线程二号&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出结果</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210713194437056.png" alt="image-20210713194437056"> </p><p>每个线程都是独立保存一份</p><p> 分析一下源码,了解清楚底层实现.  </p><p>解释一下下列现象</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210713200021645.png" alt="image-20210713200021645"> </p><p>为什么得到的是空值??</p><blockquote><p>由于ThradLocal调用的是Thread类中定义的ThreadLocalMap进行存储,当线程结束后,这个缓存值会被清理掉</p><p>所以会返回空值</p></blockquote><p>ThreadLocal的Set方法 就是获取线程的存储map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码后得知: 每个线程里面都有一个threadLocals </p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210713195652693.png" alt="image-20210713195652693"></p><p>总结 ::</p><blockquote><p>ThreadLocal从理论上不是来解决线程安全问题的, 因为根本就不存在多线程竞争问题 </p></blockquote><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h5 id="三）可重入代码"><a href="#三）可重入代码" class="headerlink" title="三）可重入代码"></a>三）可重入代码</h5><p>这种代码也叫纯代码 ，可以在代码执行中的任何时候中断它，转而去执行另一段代码（包括递归调用它本身），</p><p>而在控制权返回后，原来的程序不会出现任何错误</p><p>可重入的代码有一些公共特征： 不依赖存储在堆内存上的数据和公共的系统资源、用到的状态量都从参数中传入，不调用非可重入的方法等。</p><h2 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h2><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><blockquote><p>TIP</p><p>面试题：</p></blockquote><p>请说一下线程的生命周期 ？？ </p><blockquote></blockquote><p>线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?</p><blockquote><p>创建    -&gt;  new  Thread</p><p>可运行    -&gt; 通过.start</p><p>阻塞     -&gt;  没有获取到锁就会进入阻塞状态</p><p>无限期等待   -&gt;   不带时间wait</p><p>有限期等待    -&gt;  带时间的wait /  sleep/ </p><p>死亡    -&gt; 出现异常的时候</p></blockquote><p>通常创建线程有哪几种使用方式?</p><blockquote><p>实现Runnable  实现 Callable   继续 extends</p></blockquote><p>基础线程机制有哪些?</p><blockquote><p>executor   /    sleep  /    daemon   /    yield</p></blockquote><p>线程的中断方式有哪些?</p><blockquote><p>发生异常 </p><p>使用Inerrupited方法 </p><p>线程池的话使用shutdown / shutdownAll</p><p>关闭单独任务的话使用FutureTask 和 </p></blockquote><p>线程的互斥同步方式有哪些? 如何比较和选择?</p><blockquote><p>synchronized 和 ReentrantLock </p><p>不使用ReentrantLock的新功能的话，建议synchronized</p></blockquote><p>线程之间有哪些协作方式?</p><blockquote><p>join  </p><p>wait / notify / notifyall</p><p>await/ singal / singalAll</p></blockquote><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ace830df-9919-48ca-91b5-60b193f593d2-1626223589144.png" alt=" "></p><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><p>线程创建之后但未使用</p><h4 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h4><p>可能正在运行，或者是等待CPU的切片 </p><p>包含了操作系统线程状态中的Running 和 Ready</p><h4 id="阻塞-Blocking"><a href="#阻塞-Blocking" class="headerlink" title="阻塞(Blocking)"></a>阻塞(Blocking)</h4><p>等待获取一个排他锁，如果其他线程释放了锁就会结束此状态</p><h4 id="无限期等待-Waiting"><a href="#无限期等待-Waiting" class="headerlink" title="无限期等待(Waiting)"></a>无限期等待(Waiting)</h4><p>等待其他线程唤醒，否则不会分配CPU切片</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有带TimeOut参数的Object.wait()方法</td><td>Object.notify() / Object.notifyAll</td></tr><tr><td>没有设置TimeOut参数的Thread.join方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LookSupport.park()方法</td><td></td></tr></tbody></table><h4 id="限期等待-Time-Waiting"><a href="#限期等待-Time-Waiting" class="headerlink" title="限期等待(Time Waiting)"></a>限期等待(Time Waiting)</h4><p>无需等待其他线程的显示唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用Thread.sleep()方法使线程进入睡眠状态（限时等待）</p><p>调用Object.wait() 方法使线程进入限时等待或者是无限期等待时，常用“挂起一个线程来描述”</p><p>睡眠和唤醒是描述行为，堵塞和等待是描述状态</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>调用Thread.sleep()方法</td><td>等待时间结束</td></tr><tr><td>设置了TimeOut的Object.wait</td><td>等待时间结束/Object.notify/Object.notifyAll</td></tr><tr><td>设置了TimeOut的Object.join</td><td>等待调用的线程执行完成/时间结束</td></tr><tr><td>LockSupport.parkNanos方法</td><td></td></tr><tr><td>LockSupport.parkUntil()方法</td><td></td></tr></tbody></table><h4 id="死亡-Terminated"><a href="#死亡-Terminated" class="headerlink" title="死亡(Terminated)"></a>死亡(Terminated)</h4><p>线程执行成功任务结束，或者是产生了异常而结束</p><h3 id="线程的使用方式"><a href="#线程的使用方式" class="headerlink" title="线程的使用方式"></a>线程的使用方式</h3><p>有三种使用方式</p><ul><li>实现Runnable 接口 </li><li>实现Callable接口 </li><li>继承Thread类 </li></ul><p>实现了Runnable接口和Callable接口的类只能当做一个可以在线程中运行的任务，并不是真正意义上的线程，因此最后还需通过Thread类来进行调用。可以说任务是通过线程驱动而执行的</p><h4 id="三种创建方式和使用"><a href="#三种创建方式和使用" class="headerlink" title="三种创建方式和使用"></a>三种创建方式和使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JUCLearn</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Sleep sleep = <span class="hljs-keyword">new</span> Sleep();<br>        sleep.start();<br><br><br>        Cat cat = <span class="hljs-keyword">new</span> Cat();<br>        <span class="hljs-keyword">new</span> Thread(cat,<span class="hljs-string">&quot;anzh1&quot;</span>).start();<br><br>        Navicat navicat = <span class="hljs-keyword">new</span> Navicat();<br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(navicat);<br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-comment">// 继承Thread类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开启了Thread类&quot;</span>);<br>        <span class="hljs-keyword">super</span>.run();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">// 实现Runnable接口</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;继承了runbale接口 &quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">// 实现Callable接口</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Navicat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了 call 方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现接口和继承类"><a href="#实现接口和继承类" class="headerlink" title="实现接口和继承类"></a>实现接口和继承类</h4><blockquote><p>接口可以多实现，继承类的话只能继承一个</p><p>类可以只要求执行就行，继承Thread开销太大</p></blockquote><p>Callable 和 Runnable 接口的不同点</p><ul><li>使用方式不同 ，Runnbale可以直接作为参数传递给Thread类，运行run方法。而Callable接口需要转成futureTask接口才能进行传递</li><li>方法名不一样，Callable是重写call方法而Runnable接口是重写run方法</li><li>返回参数不一样 ，call方法是带返回值的，而run方法不具备</li><li>是否支持泛型，Callable可以，但是Runnable没有</li></ul><h3 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h3><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>Executor 管理多个异步任务的执行，无需程序员显示地管理生命周期。这里的异步指多个任务的执行互不干扰，</p><p>不需要进行同步操作。</p><p>主要有三种Exectour: </p><ul><li>CachedThreadPool ： 一个任务创建一个线程池；</li><li>FIexThreadPool：所以的线程都固定大小的线程</li><li>SingleThreadExectour ：相当与大小为1的FlexThreadPool</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br>ExecutorService executor = Executors.newCachedThreadPool();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-comment">// 执行线程</span><br>    executor.execute(<span class="hljs-keyword">new</span> Cat());<br>&#125;<br><span class="hljs-comment">// 关闭资源类</span><br>executor.shutdown();<br></code></pre></td></tr></table></figure><h4 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h4><p>什么是守护线程 ？？</p><p>守护线程是程序运行时在后台提供服务的线程 ，不属于程序中不可或缺的部分。</p><p>当所有的守护线程结束时，程序也将终止，同时会杀死所有的守护线程</p><p>main()属于非守护线程</p><p>使用setDaemon设置为守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置为守护线程</span><br>Thread anzhen = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Cat(), <span class="hljs-string">&quot;anzhen&quot;</span>);<br><span class="hljs-comment">//</span><br>anzhen.setDaemon(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>Thread.sleep(millisec ) 方法会休眠正在执行的线程，millisec 为毫秒单位</p><p>sleep() 可能会抛出InterruptedException, 因为异常不能跨线程传播会main中，因此必须本地处理。线程中抛出的其他异常也同样需要本地进行处理</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>对静态方法Thread.yield()调用声明了当前调用的线程已经完成生命周期中最重要的部分，可以切换给其他线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级别的其他线程可以运行 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread.yield();<br>&#125;<br> <br></code></pre></td></tr></table></figure><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><blockquote><p>一个线程执行完成之后就会结束，如果在运行中出现了异常也会提前结束 </p></blockquote><h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><p>通过调用一个线程的interrupt来中断这个该线程，如果线程处于阻塞、限期等待和无限期等待，就会抛出InterruptedException ，从而提前结束该线程，但是不能IO阻塞或synchronized锁阻塞</p><p>创建任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承Thread类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开启了Thread类&quot;</span>);<br>         <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace(); &#125;<br><br>        <span class="hljs-keyword">super</span>.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main主案例调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Sleep(),<span class="hljs-string">&quot;anzhen&quot;</span>);<br>thread.start();<br>thread.interrupt();<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">开启了Thread类<br>java.lang.InterruptedException: sleep interrupted<br>at java.lang.Thread.sleep(Native Method)<br>at java.lang.Thread.sleep(Thread.java:<span class="hljs-number">340</span>)<br>at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="hljs-number">386</span>)<br>at com.anzhen.Sleep.run(JUCLearn.java:<span class="hljs-number">39</span>)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure><h4 id="Interrupted"><a href="#Interrupted" class="headerlink" title="Interrupted()"></a>Interrupted()</h4><p><strong>如果一个线程的run方法执行一个无限循环</strong>，并且没有执行sleep()等会抛出InterrupttionException的操作，那么调用线程的<strong>Interrupted()方法</strong>就无法使线程提前结束。</p><p>调用Interrupted()方法会<strong>设置线程的中断标记</strong>，此时调用interrupted会返回true。因此可以在循环体中使用interrupted方法来判断线程是否处于中断状态，从而提前结束线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (!interrupted()) &#123;<br>                <span class="hljs-comment">// ..</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Thread end&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread thread2 = <span class="hljs-keyword">new</span> MyThread2();<br>    thread2.start();<br>    thread2.interrupt();<br>&#125;<br>  Thread end<br></code></pre></td></tr></table></figure><h4 id="Executor的中断操作"><a href="#Executor的中断操作" class="headerlink" title="Executor的中断操作"></a>Executor的中断操作</h4><p>调用Executor的shutdown()方法会等待全部线程都执行完成的时候才会关闭线程池，但是如果使调用shutdownNow()方法相当于对线程池中每个线程都执行了Interrupted()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService executorService = Executors.newCachedThreadPool();<br>executorService.execute(() -&gt; &#123;<br>     <span class="hljs-keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace(); &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程执行中&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 现在强制关闭方法</span><br>executorService.shutdownNow();<br></code></pre></td></tr></table></figure><p>如果只想中断一个线程，可以通过使用submit()方法来提交一个线程，它会返回Future&lt;?&gt; 对象，通过调用该对象的cancel(true) 就可以中断一个线程</p><h3 id="线程互斥同步锁"><a href="#线程互斥同步锁" class="headerlink" title="线程互斥同步锁"></a>线程互斥同步锁</h3><p>Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个使JVM实现的synchronized，另一个使JDK实现的ReentrantLock</p><h4 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h4><h5 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>只作用同一个对象，如果有两个对象上的同步代码块的话，这个不起作用</p><h5 id="2-同步一个方法"><a href="#2-同步一个方法" class="headerlink" title="2.同步一个方法"></a>2.同步一个方法</h5><p>和同步代码块一样，只作用于同一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;调用了 call 方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="3.同步一个类"></a>3.同步一个类</h5><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (SynchronizedExample.class) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-同步一个静态方法"><a href="#4-同步一个静态方法" class="headerlink" title="4.同步一个静态方法"></a>4.同步一个静态方法</h5><p>作用于整个类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>使JUC包中的一个类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 上锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 使用当前对象当锁</span><br>        System.out.println(<span class="hljs-string">&quot;继承了runbale接口 &quot;</span>);<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="synchronized和ReentrantLock的比较"><a href="#synchronized和ReentrantLock的比较" class="headerlink" title="synchronized和ReentrantLock的比较"></a>synchronized和ReentrantLock的比较</h4><h5 id="1、锁的比较"><a href="#1、锁的比较" class="headerlink" title="1、锁的比较"></a>1、锁的比较</h5><p>synchronized 是JVM实现的</p><p>ReentrantLock是JDK实现的</p><h5 id="2、性能"><a href="#2、性能" class="headerlink" title="2、性能"></a>2、性能</h5><p>新版本Java对synchronized进行了很多优化，例如自旋锁，synchronized与ReentrantLock大致相同</p><h5 id="3、等待可中断"><a href="#3、等待可中断" class="headerlink" title="3、等待可中断"></a>3、等待可中断</h5><p>当持有锁的线程长期不放锁的话，正在等待的线程可以放弃等待，改为处理其他事情</p><p>ReentrantLock可以   synchronized不行</p><h5 id="4、公平锁"><a href="#4、公平锁" class="headerlink" title="4、公平锁"></a>4、公平锁</h5><p>什么是公平锁？</p><blockquote><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁</p></blockquote><p>ReentrantLoock可以在创建的时候，指定是否使用公平锁（默认是非公平的）</p><p>synchronized是非公平锁</p><h5 id="5、锁绑定多个条件"><a href="#5、锁绑定多个条件" class="headerlink" title="5、锁绑定多个条件"></a>5、锁绑定多个条件</h5><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象</p><h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>除非需要使用ReentrantLock的高级功能，否则优先使用synchronized。 因为synchronized是JVM实现的，JVM会原生支持它，而ReentrantLock不是所有的JDK版本都支持。而且使用synchronized不用担心没有释放锁导致的死锁问题。JVM会确保锁的释放</p><h3 id="线程之间的协调"><a href="#线程之间的协调" class="headerlink" title="线程之间的协调"></a>线程之间的协调</h3><p>当多个线程一起工作去解决某个问题时，如果某个某些部分需要在其他部分之前完成，那么就需要对线程进行协调</p><p>join </p><blockquote><p>在一个线程中调用另一个线程的join方法，当前线程就会被挂起，而不是等待，知道目标线程结束</p></blockquote><p>Object控制线程协调的三个方法 </p><p>Object.wait()  // 让线程进入等待状态 （会释放锁）</p><p>Object.notify()  // 让唤醒等待的线程 </p><p>Object.notifyAll()   // 唤醒全部等待的线程</p><p>JUC新的控制线程协调的api</p><p>condition.await()  // 让现场进入等待</p><p>condition.singal()  // 唤醒等待线程</p><p>condition.singalAll()  // 唤醒全部等待的线程</p><h2 id="JMM-是什么"><a href="#JMM-是什么" class="headerlink" title="JMM 是什么"></a>JMM 是什么</h2><ul><li>JMM是一种符合内存规范的, 屏蔽了各种硬件和操作系统的访问差异的, 保证了Java程序在各种平台对内存访问都能保证效果一致的机制及规范</li><li>Java内存模型规定了<strong>所有的变量</strong>都存储在主内存中, 每条线程还有自己的工作内存, 线程的工作内存中保存了该线程中是<strong>用到的变量的主内存副本拷贝</strong>, 线程对变量的所有操作都必须在工作内存中进行, 不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量, 线程间变量的传递均需要自己的共工作内存和主存之间进行数据同步进行</li><li>JMM就作用于工作内存和主内存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</li></ul><h3 id="JMM-的主要作用-以及实现方式-解决了那些问题"><a href="#JMM-的主要作用-以及实现方式-解决了那些问题" class="headerlink" title="JMM 的主要作用  以及实现方式 解决了那些问题"></a>JMM 的主要作用  以及实现方式 解决了那些问题</h3><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210616092723877.png" alt="image-20210616092723877"></p><p>JMM是一种规范，目的是<strong>解决</strong>由于多线程通过共享内存进行通信时，储存在本地内存的<strong>数据不一致</strong></p><p>、编译器会对<strong>代码指令重排序</strong>、处理器会对<strong>代码乱序执行</strong>等带来的问题</p><p>原子性 ：</p><blockquote><p><em>即一个操作或者多个操作</em> <em>要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</em></p></blockquote><p>​        Java中可以使用<code>synchronized </code>来保证方法和代码内的操作是原子性的 </p><p>​        自Jdk1.5之后提供了一个<code>Lock</code>(使用的是实现类)包 可以保证方法和代码内的操作都是原子性的</p><p> 而且俩者都是可重入锁 ？ </p><blockquote><p>解答文档<a href="https://mp.weixin.qq.com/s/R7Fu1HDW3N1pl1c9VJ2T5Q">https://mp.weixin.qq.com/s/R7Fu1HDW3N1pl1c9VJ2T5Q</a></p></blockquote><p>有序性 ： 即程序执行的顺序按照代码的先后顺序执行。</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><p>可见性：</p><blockquote><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架详解</title>
    <link href="/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="集合体系架构图"><a href="#集合体系架构图" class="headerlink" title="集合体系架构图"></a>集合体系架构图</h2><p><img src="https://www.pdai.tech/_images/java_collections_overview.png" alt="img"></p><h3 id="什么是容器，有什么优点？"><a href="#什么是容器，有什么优点？" class="headerlink" title="什么是容器，有什么优点？"></a>什么是容器，有什么优点？</h3><blockquote><p>容器就是容纳其他Java对象的对象</p><p>优点是: </p><ul><li>降低编程难度</li><li>提高程序性能</li><li>提高API间的互操作性</li><li>降低学习难度</li><li>降低设计和实现相关API的难度</li><li>增加程序的重要性</li></ul><p>注意特点 ： 容器里面只能放入对象 ，如果是基本数据类型的话 ，需要转成包装类</p></blockquote><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><blockquote><p>容器主要包括Collection 和 Map俩种， Collection存储着对象的集合，而Map存储着键值对的映射表</p></blockquote><p>Set</p><ul><li>TreeSet<ul><li>基于红黑树实现，支持有序性操作。但是查询效率不如HashSet，HashSet查找为O（1） TreeSet查找效率为O(logn)</li></ul></li><li>HashSet<ul><li>基于Hash表实现，支持快速查询，但不是支持有序操作。并且失去了元素的插入顺序信息，也就是说iterator遍历的HashSet得到的结果是不一样的</li></ul></li><li>LinkedHashSet<ul><li>具有HashSet的查询效率，内部采用双向链表维护元素的插入顺序</li></ul></li></ul><p>List</p><ul><li>ArrayList<ul><li>基于动态数组实现</li></ul></li><li>LinkedList <ul><li>基于双向链表实现 </li></ul></li><li>Vector<ul><li>和ArrayList类似，但是是线程安全的</li></ul></li></ul><p>Queue</p><ul><li><p>​    LinkedList</p><ul><li>可以用它来实现双向队列 </li></ul></li><li><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><ul><li>基于堆结构实现，可以用它来实现优先队列 </li></ul></li></ul><p>Map</p><ul><li>HashMap<ul><li>基于哈希表实现</li></ul></li><li>HashTree<ul><li>基于红黑树实现</li></ul></li><li>HashTable<ul><li>和HashMap类似但是是线程安全的，意味着这个同一时刻多个线程同时写入不会导致数据不一致，它是遗留类，不应该去使用它。现在可以使用ConcurrentHashMap来支持线程安全，并且ConcurrentHashMap效率更高，因为ConcurrentHashMap引入了分段锁</li></ul></li><li>LinkedHashMap<ul><li>使用双向链表来维护元素的顺序，顺序为插入顺序或者是最少使用顺序</li></ul></li></ul><h3 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h3><h4 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h4><p>特点 ： 不是线程安全的，可以存储NULL ， 继承了List 是顺序容器</p><h4 id="底层用什么进行存储"><a href="#底层用什么进行存储" class="headerlink" title="底层用什么进行存储"></a>底层用什么进行存储</h4><p>底层采用不能序列化的Object数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;  <span class="hljs-comment">// 长度 </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 默认容量</span><br></code></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定容量大小进行进项创建ArrayList</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty list with an initial capacity of ten.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 默认的空参构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a list containing the elements of the specified</span><br><span class="hljs-comment"> * collection, in the order they are returned by the collection&#x27;s</span><br><span class="hljs-comment"> * iterator.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c the collection whose elements are to be placed into this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 传入集合类转换为ArrayList</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><br><span class="hljs-comment">// 扩容</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    <br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>扩容原理：</p><p><img src="/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/image-20210712083255565.png" alt="image-20210712083255565"></p><p>如上图所示 ，集合每次添加一个元素会添加之后容量是否足够，如果不够的话进行扩容</p><p>扩容的方式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">elementData = Arrays.copyOf(elementData, newCapacity);<br></code></pre></td></tr></table></figure><p>数组操作是，是将老数组的元素全部拷贝一份到新数组中，每次数组容量增加大约是其源容量的1.5倍。这种操作代价高，所以在使用中，应该尽量避免数组扩容。当我们知道具体容量时，可以使用指定容量的构造方法进行创建。或者根据实际需求，通过调用ensureCapacity进行手动扩容。</p><p>扩容图解</p><p><img src="/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/image-20210712084807191.png" alt="image-20210712084807191"></p><h4 id="add-addAll添加方法"><a href="#add-addAll添加方法" class="headerlink" title="add  addAll添加方法"></a>add  addAll添加方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>   <span class="hljs-comment">// 检测数组中容量是否足够  </span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查index是否可以添加元素 </span><br>    rangeCheckForAdd(index);<br>   <span class="hljs-comment">// 校验容量是否足够 </span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 从某个位置进行插入 </span><br>    <span class="hljs-comment">// 需要位置之后的元素向后移动一个单位 </span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    <span class="hljs-comment">// 将数据赋值到指定位置 </span><br>    elementData[index] = element;<br>    size++;<br>&#125;<br><br><br><span class="hljs-comment">// 将数组拼接到结尾</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-keyword">int</span> numNew = a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 指定位置对接 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-keyword">int</span> numNew = a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-keyword">int</span> numMoved = size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> 添加的时候都会检测容量是否足够，如果不够的话进行扩容，扩容操作通过grow方法完成</p><h4 id="romove"><a href="#romove" class="headerlink" title="romove"></a>romove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    checkForComodification();<br>    E result = parent.remove(parentOffset + index);<br>    <span class="hljs-keyword">this</span>.modCount = parent.modCount;<br>    <span class="hljs-keyword">this</span>.size--;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>对指定位置进行删除</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><blockquote><p>较为简单，对指定位置进行赋值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    rangeCheck(index);<br><br>    E oldValue = elementData(index);<br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br><br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>获取指定位置的元素</p></blockquote><h4 id="rimToSize"><a href="#rimToSize" class="headerlink" title="rimToSize"></a>rimToSize</h4><blockquote><p>将底层数组长度调整为当前列表保存实际元素的大小 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;<br>    modCount++;<br>    <span class="hljs-comment">// 判断当前大小是不是小于数组总长度</span><br>    <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>        elementData = (size == <span class="hljs-number">0</span>)<br>          ? EMPTY_ELEMENTDATA<br>          : Arrays.copyOf(elementData, size);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="index-indexOf"><a href="#index-indexOf" class="headerlink" title="index   indexOf"></a>index   indexOf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从开头查找位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 从数组结尾查找位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>从开头查找位置和结尾查找位置</p></blockquote><h4 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制:"></a>Fail-Fast机制:</h4><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p><h3 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>是什么    </p><p>由链表构成的集合类</p></blockquote><h4 id="存储的数据类型"><a href="#存储的数据类型" class="headerlink" title="存储的数据类型"></a>存储的数据类型</h4><blockquote><p>实现了List，序列化接口 ， 队列接口  ， 克隆接口 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Pointer to first node.</span><br><span class="hljs-comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="hljs-comment">     *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Pointer to last node.</span><br><span class="hljs-comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="hljs-comment">     *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><br><span class="hljs-comment">// 使用静态内部类Node存储数据</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E item;<br>    Node&lt;E&gt; next;  <span class="hljs-comment">// 指向下一个指针</span><br>    Node&lt;E&gt; prev;  <span class="hljs-comment">// 指向前驱的指针 </span><br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.item = element;<br>        <span class="hljs-keyword">this</span>.next = next;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a list containing the elements of the specified</span><br><span class="hljs-comment"> * collection, in the order they are returned by the collection&#x27;s</span><br><span class="hljs-comment"> * iterator.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  c the collection whose elements are to be placed into this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 调用空参构造器 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    addAll(c);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getFirst，getLast"><a href="#getFirst，getLast" class="headerlink" title="getFirst，getLast"></a>getFirst，getLast</h4><blockquote><p>获取第一个元素  ， 获取最后一个元素 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取第一个 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-comment">// 获取最后一个 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> l.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><h4 id="removeFirst，removeLast，-remove-e-，remove-index"><a href="#removeFirst，removeLast，-remove-e-，remove-index" class="headerlink" title="removeFirst，removeLast， remove(e) ，remove(index)"></a>removeFirst，removeLast， remove(e) ，remove(index)</h4><p>remove有俩个版本，一个根据元素匹配，一个根据位置进行查询</p><blockquote><p>根据元素进行删除  判断是否是空值， 因为List中可以存储空值 </p><p>删除统一用那个解除链接的方法，将被删除元素的指针删除，元素被删除之后得维护前驱和后继的链接关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 取消链接</span><br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                <span class="hljs-comment">// 取消链接 </span><br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br><br><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br>        <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-comment">// 获取元素 </span><br>        <span class="hljs-keyword">final</span> E element = x.item;<br>    <span class="hljs-comment">// 赋值后继指针 </span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-comment">// 赋值前驱指针 </span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 第一个元素</span><br>            first = next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prev.next = next;<br>            x.prev = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 最后一个元素</span><br>            last = prev;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.prev = prev;<br>            x.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        x.item = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// GC</span><br>        size--;<br>        modCount++;<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br><br><br><span class="hljs-comment">// 先检查位置是否合理 不合理直接抛出异常 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除图解"><a href="#删除图解" class="headerlink" title="删除图解"></a>删除图解</h4><p><img src="https://www.pdai.tech/_images/collection/LinkedList_remove.png" alt="LinkedList_remove.png"></p><p>删除开头元素和结尾元素最为简单，因为移动的指针很少 </p><p>删除开头元素 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-keyword">final</span> Eelement = f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-keyword">null</span>;<br>    f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>    <span class="hljs-comment">// 将头指针赋值给被删除元素的后继</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>        last = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-comment">// 删除最后一个节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;<br>    <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span><br>    <span class="hljs-keyword">final</span> E element = l.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;<br>    l.item = <span class="hljs-keyword">null</span>;<br>    l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>    <span class="hljs-comment">// 将尾指针赋值给被删除元素的前驱</span><br>    last = prev;<br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)<br>        first = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span><br>        prev.next = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-，-addAll"><a href="#add-，-addAll" class="headerlink" title="add ， addAll"></a>add ， addAll</h4><blockquote><p>add也是需要操作指针，不过这个模式是使用 尾插法进行添加的数据，最后插入的花费的时间较少</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    checkPositionIndex(index);<br><br>    <span class="hljs-keyword">if</span> (index == size)<br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>    first = newNode;<br>    <span class="hljs-keyword">else</span><br>    l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="添加移动指针图解"><a href="#添加移动指针图解" class="headerlink" title="添加移动指针图解"></a>添加移动指针图解</h4><p><img src="https://www.pdai.tech/_images/collection/LinkedList_add.png" alt="LinkedList_add"></p><p>addAll方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用的重载的方法 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> addAll(size, c);<br>&#125;<br><br><span class="hljs-comment">// 使用位置  </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>   <span class="hljs-comment">// 校验位置是否合理</span><br>    checkPositionIndex(index);<br><br>    <span class="hljs-comment">// </span><br>    Object[] a = c.toArray();<br>    <span class="hljs-keyword">int</span> numNew = a.length;<br>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    Node&lt;E&gt; pred, succ;<br>    <span class="hljs-keyword">if</span> (index == size) &#123;<br>        succ = <span class="hljs-keyword">null</span>;<br>        pred = last;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        succ = node(index);<br>        pred = succ.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (Object o : a) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;<br>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            pred.next = newNode;<br>        pred = newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123;<br>        last = pred;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pred.next = succ;<br>        succ.prev = pred;<br>    &#125;<br><br>    size += numNew;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><blockquote><p>清楚链表全部元素，方便GC回收</p></blockquote><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><blockquote><p>从头节点开始遍历，将全部的数据和节点都赋值为空，将大小置为空，将头尾指针赋值为空</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; ) &#123;<br>        Node&lt;E&gt; next = x.next;<br>        x.item = <span class="hljs-keyword">null</span>;<br>        x.next = <span class="hljs-keyword">null</span>;<br>        x.prev = <span class="hljs-keyword">null</span>;<br>        x = next;<br>    &#125;<br>    first = last = <span class="hljs-keyword">null</span>;<br>    size = <span class="hljs-number">0</span>;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Positional-Access-方法"><a href="#Positional-Access-方法" class="headerlink" title="Positional Access 方法"></a>Positional Access 方法</h4><h5 id="通过index获取元素"><a href="#通过index获取元素" class="headerlink" title="通过index获取元素"></a>通过index获取元素</h5><blockquote><p>先校验index是否合理，合理之后进行迭代获取 ， 遍历采用二分查找 </p></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 通过id获取数据 </span><br><span class="hljs-keyword">public</span> E get(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>) &#123;<br><span class="hljs-comment">// </span><br>    checkElementIndex(<span class="hljs-keyword">index</span>);<br>    <span class="hljs-keyword">return</span> node(<span class="hljs-keyword">index</span>).item;<br>&#125;<br><br>Node&lt;E&gt; node(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>) &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br><span class="hljs-comment">// 判断是否合理</span><br><span class="hljs-comment">// 二分法 通过判断位置是否大于中简单的数据 </span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">index</span>; i++)<br>            x = x.<span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 大于从结尾查</span><br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = size - <span class="hljs-number">1</span>; i &gt; <span class="hljs-keyword">index</span>; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对某个位置重新赋值"><a href="#对某个位置重新赋值" class="headerlink" title="对某个位置重新赋值"></a>对某个位置重新赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验长度是否合理</span><br>    checkElementIndex(index);<br>    Node&lt;E&gt; x = node(index);<br>    <span class="hljs-comment">// 获得修改前的值</span><br>    E oldVal = x.item;<br>    x.item = element;<br>    <span class="hljs-keyword">return</span> oldVal;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="根据index删除元素"><a href="#根据index删除元素" class="headerlink" title="根据index删除元素"></a>根据index删除元素</h4><blockquote><p>先判断位置是否合理 ， 然后进行删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><blockquote><p>通过元素查询位置  ， 定义一个count判断元素是否相等，返回count</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> index;<br>            index++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                <span class="hljs-keyword">return</span> index;<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = size;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            index--;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> index;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            index--;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                <span class="hljs-keyword">return</span> index;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h4><blockquote><p>使用LinkedList做队列的方法 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">element</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getFirst();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkFirst(f);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> add(e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Deque方法-双端队列"><a href="#Deque方法-双端队列" class="headerlink" title="Deque方法  (双端队列)"></a>Deque方法  (双端队列)</h4><blockquote><p>Linked实现了deque的接口 </p></blockquote><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addFirst(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : l.item;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkFirst(f);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkLast(l);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addFirst(e);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> remove(o);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>(当作栈或队列使用时)有着更好的性能。</p></blockquote><h3 id="Stack-amp-Queue源码解析"><a href="#Stack-amp-Queue源码解析" class="headerlink" title="Stack &amp;  Queue源码解析"></a>Stack &amp;  Queue源码解析</h3><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><blockquote><p>Java里有一个Stack的类 ，却没有一个Queue的类(只有一个接口)。官方不推荐使用Stack，而是推荐使用高效的ArrayDuque；虽然Queue只是一个接口，当需要使用队列时也就首选了ArrayDuque 次选时 LinkedList</p></blockquote><h3 id="Priority-Queue源码解析"><a href="#Priority-Queue源码解析" class="headerlink" title="Priority  Queue源码解析"></a>Priority  Queue源码解析</h3><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><h3 id="HashSet-amp-HashMap源码解析"><a href="#HashSet-amp-HashMap源码解析" class="headerlink" title="HashSet  &amp;  HashMap源码解析"></a>HashSet  &amp;  HashMap源码解析</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><blockquote><p>由于HashSet底层还是使用的是HashMap所以主谈HashMap</p></blockquote><p>查看源码得知 :  HashSet本质就是使用HashMap的Key特性创建而成 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5024744406713321676L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br>    <span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment">     * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="hljs-keyword">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>        addAll(c);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="HashMap用什么结构存储数据"><a href="#HashMap用什么结构存储数据" class="headerlink" title="HashMap用什么结构存储数据"></a>HashMap用什么结构存储数据</h4><blockquote><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p></blockquote><h4 id="HashMap结构图"><a href="#HashMap结构图" class="headerlink" title="HashMap结构图"></a>HashMap结构图</h4><p><img src="https://www.pdai.tech/_images/java/java-collection-hashmap8.png" alt="img"></p><p>源码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><br><span class="hljs-comment">// 使用内部类Node进行存储 ， 实现了 Entry接口 </span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; next;<br><br>    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.hash = hash;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>        V oldValue = value;<br>        value = newValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                Objects.equals(value, e.getValue()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由图得知，HashMap用静态内部类node存储数据 </p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><blockquote><p>总结： 因为HashMap是第一次put值的时候进行初始化，所以要判断是否是第一次put值</p><p>2 判断散列的位置有没有值 如果没有的话，将数据放入当前位置 </p><p>3 判断key是否相等，判断hash值是否相等  如果先等的话，直接进行覆盖操作 </p><p>4 判断节点是不是红黑树，如果是的话，直接进行创建</p><p>5 遍历单链表 判断有没有相同的key如果相同的话，直接进行覆盖，不是的话进行尾插法插入新节点</p><p>6 判断增加有么有过阈值如果超过了阈值就进行扩容</p><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br><span class="hljs-comment">// 第五个参数 evict 我们这里不关心</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    <br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>   <span class="hljs-comment">// 判断是不是第一次put值</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>       <span class="hljs-comment">// 将将resize初始化的值赋值给tab, 将长度给n</span><br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 判断hash之后的位置有没有值   如果没有的话创建Node赋值</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 进入这里表示hash出来的位置有值</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 将之前查找到的位置的数据值 进行Hash比较 传入的key比较</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>           <span class="hljs-comment">// 表示key相等  进行覆盖操作  </span><br>            e = p;<br>        <span class="hljs-comment">// 判断是不是树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 到这里说明当前节点是单链表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 遍历到尾部进行插入操作 </span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 使用尾插法进行节点插入</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 如果binCunt == 8的话 就要转换为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果找到两块相同的地址 </span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>           <span class="hljs-comment">// 将e的值取出来</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">// 将新值替换掉</span><br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回老值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 如果加入的之后的size大于阈值之后应该进行扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数组扩容</p><blockquote><p>流程 ： 判断是否超过阈值 超过了进行扩容 </p><p>结论 ： 每次扩容后为原来的2倍</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">// 将原先数据进行拷贝 </span><br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">// 判断之前的表是否为空 获取原表的容量 </span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-comment">// 获取原表的阈值</span><br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断是否大于最大容量</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-comment">// 将最大值赋值给阈值</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 不是的话新容量 =  旧容量 * 2</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-comment">// 双倍阈值</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 计算新的阈值  =  新容量  *  加载因子0.75</span><br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">// 赋值新阈值 </span><br>    threshold = newThr;<br>    <span class="hljs-comment">//@SuppressWarnings 批注允许您选择性地取消特定代码段（即，类或方法）中的警告。其中的想法是当您看到警告时，您将调查它，如果您确定它不是问题，</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <br>    <span class="hljs-comment">// 使用新容量创建表 </span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-comment">// 将数据遍历 存入新表中并返回</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><blockquote><p>流程 : </p><p>判断hash值是否为空 为空直接返回空 </p><p>判断 // 判断表是否为空, 长度是否小于0, hash散列出来的位置是否有数据</p><p>判断hash是否相等, 判断key是否相等, 判断key的值是否相等</p><p>如果同一位置都不为空的话 , 就直接为</p><p>结论 : </p></blockquote><p>源码解析 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    <span class="hljs-comment">// </span><br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k<br>    <span class="hljs-comment">// 判断表是否为空, 长度是否小于0, hash散列出来的位置是否有数据</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 判断hash是否相等, 判断key是否相等, 判断key的值是否相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-comment">// 返回阶段first</span><br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 表示是单链表或者是树结构</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 判断是否是树节点 </span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 遍历单链表寻找相同的值</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TreeSet-amp-TreeMap-源码解析"><a href="#TreeSet-amp-TreeMap-源码解析" class="headerlink" title="TreeSet  &amp;  TreeMap 源码解析"></a>TreeSet  &amp;  TreeMap 源码解析</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><blockquote><p>之所以把TreeSet和 TreeMap一起讲, 应为二者在java中有着相同的实现,前者只是对后者进行了一层包装,也就是说TreeSet里面有一个TreeMap(适配器模式). </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>activiti学习</title>
    <link href="/2021/07/13/activiti%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/13/activiti%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Activiti"><a href="#Activiti" class="headerlink" title="Activiti"></a>Activiti</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Activiti-介绍"><a href="#Activiti-介绍" class="headerlink" title="Activiti 介绍"></a>Activiti 介绍</h3><p>： Activiti 是一个工作流引擎，可以将复杂的业务抽出出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由Activiti进行管理，减少业务系统由于流程变更进行系统升级改造的的工作量，从而提高系统的健壮性，同时减少系统开发维护成本</p><h4 id="activiti-流程部署"><a href="#activiti-流程部署" class="headerlink" title="activiti 流程部署"></a>activiti 流程部署</h4><p><img src="/2021/07/13/activiti%E5%AD%A6%E4%B9%A0/image-20210713104052176.png" alt="image-20210713104052176"></p><h4 id="activiti使用用法"><a href="#activiti使用用法" class="headerlink" title="activiti使用用法"></a>activiti使用用法</h4><p>创建配置文件 </p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-json-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-cloud-services-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>20030825.184428<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    配置有俩种方式  配置数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcDriver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti?characterEncoding=utf-8<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUsername&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcPassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;anzhen3531&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--        帮我们自动创建表结构--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写测试类，运行得出25张表</p><p><img src="/2021/07/13/activiti%E5%AD%A6%E4%B9%A0/image-20210713203930385.png" alt="image-20210713203930385"> </p><p>表结构解析 </p><p>re 表示仓库 </p><p>ru表示运行时保存数据，结束之后数据都会被删除</p>]]></content>
    
    
    
    <tags>
      
      <tag>activiti</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java复习</title>
    <link href="/2021/07/10/Java%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/07/10/Java%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java整体分析"><a href="#Java整体分析" class="headerlink" title="Java整体分析"></a>Java整体分析</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li>多态</li><li>封装</li><li>继承</li></ol><h4 id="封装是什么-？"><a href="#封装是什么-？" class="headerlink" title="封装是什么 ？"></a>封装是什么 ？</h4><blockquote><p>将抽象数据类型基于数据的操作封装在一起，使其构成一个不可分割的独立实体。</p><p>数据被保护抽象数据类型在内部 ，尽可能地隐藏内部的细节，只提供外部的一些接口进行访问 。</p><p>用户无需关注内部的细节，但是可以通过外部的接口使用访问对象</p></blockquote><p>优点： </p><ul><li>减少耦合 ，可以独立开发，测试，使用，理解</li><li>减轻维护的负担：可以更容易被理解，并且在调试的时候不影响其他模块</li><li>有效地调节性能：可以通过剖析确定那些模块影响性能 </li><li>提高软件的可重用性</li><li>降低构建大型系统地风险：即使整个系统不可以，但是这些独立的模块有可能是可以用的 </li></ul><h4 id="继承是什么-？"><a href="#继承是什么-？" class="headerlink" title="继承是什么 ？"></a>继承是什么 ？</h4><blockquote><p>继承的关系 是一种  is -a  的关系 ， 继承应该遵循里氏替换原则，子类必须能替换掉父类所有的对象 </p></blockquote><h4 id="多态是什么？"><a href="#多态是什么？" class="headerlink" title="多态是什么？"></a>多态是什么？</h4><p>多态分为： </p><ol><li><p>运行时多态</p><ol><li><blockquote><p>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间确定</p></blockquote></li></ol></li><li><p>编译时多态</p><ol><li><blockquote><p>编译时多态主要指方法的重载</p></blockquote></li></ol></li></ol><p>运行时多态三条件:</p><ul><li>继承</li><li>复写</li><li>向上转型</li></ul><h4 id="类图的关系"><a href="#类图的关系" class="headerlink" title="类图的关系"></a>类图的关系</h4><h5 id="泛化关系-用来描述继承关系，Java中extends"><a href="#泛化关系-用来描述继承关系，Java中extends" class="headerlink" title="泛化关系(用来描述继承关系，Java中extends)"></a>泛化关系(用来描述继承关系，Java中extends)</h5><p> <img src="/2021/07/10/Java%E5%A4%8D%E4%B9%A0/image-20210710093913469.png" alt="image-20210710093913469"></p><h5 id="实现关系（Realization）"><a href="#实现关系（Realization）" class="headerlink" title="实现关系（Realization）"></a>实现关系（Realization）</h5><p>用来实现一个接口，在Java中使用implement关键字</p><p><img src="/2021/07/10/Java%E5%A4%8D%E4%B9%A0/image-20210710094132172.png" alt="image-20210710094132172"> </p><p>聚合关系 </p><blockquote><p>若B是A的成员变量，但B不在A的构造函数中生成（new）,只在需要用到的时候才new，则构成聚合关系。</p></blockquote><p>依赖关系（dependency）</p><blockquote><p>若A在某个成员函数中使用了局部变量B，则构成了依赖关系。</p></blockquote><p>组合关系 （Composition）</p><blockquote><p>若B是A的成员变量，且B在A的构造函数种生成（new），则构成组合关系。</p></blockquote><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>8个基本数据类型     占用的字节数 </p><p>boolean    /  1</p><p>byte  /  8</p><p>char   /    16</p><p>short   /  16</p><p>int   / 32 </p><p>float   /  32 </p><p>long    / 64 </p><p>double  /  64</p><p>自动装箱和拆箱 </p><p>基本数据类型都有对应的包装类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntLearn</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer integer = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 装箱 </span><br>        <span class="hljs-keyword">int</span> y = integer;    <span class="hljs-comment">// 拆箱 </span><br>        System.out.println(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>解释一下这个代码 为什么不会相等 ？？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer integer = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>Integer integer1 = Integer.valueOf(<span class="hljs-number">10</span>);<br>System.out.println(integer == integer1);    <span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>​    </p><p>new  Integer(10) 是创建在堆内存里面的对象  ， 每次都会创建一个对象 </p><p>Integer.valueOf(10) 是将常量池的引用赋值过来 ，多个相同的会使用同一个对象</p><p>valueOf() 源码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断i 是否属于缓存池的范围</span><br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-comment">// 如果属于则从缓存中读取</span><br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i  = <span class="hljs-number">124</span>;<br>Integer y = <span class="hljs-number">124</span>;<br>System.out.println(i == y);    <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>基本数据类型包装类的缓冲区大小 </p><blockquote><p>boolean values true and false</p><p>all byte values</p><p>short values between -128 and 127</p><p>int values between -128 and 127</p><p>char in the range \u0000 to \u007F</p></blockquote><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>string 是基本数据类型吗 ？</p><blockquote><p>不是， String是引用数据类型 </p></blockquote><p>String 可以被继承吗 ？ </p><blockquote><p>不可以  String 是final修饰的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br></code></pre></td></tr></table></figure><blockquote><p>String 实现了 序列化接口，比较接口 ， 字符序列接口 </p><p>数据存储采用了 final修饰的字符数组， 所以String数据是不可更改的 </p></blockquote><p>不可变有什么好处 ？？ </p><ul><li>可以缓存hash值<ul><li>在创建的时候就要算hash值， 不可变性就只要算一次hash</li></ul></li><li>String Pool 的需要 <ul><li>如果一个String对象已经被创建过了，那么就会从String Pool中取得引用。只有String是不可变的，才能使用StringPool</li></ul></li><li>安全性 <ul><li>String 经常作为参数，String不可变性质可以保证参数不可变</li></ul></li><li>线程安全 <ul><li>String不可变性天生具有线程安全 ，可以在多个线程中使用</li></ul></li></ul><p>可变的String有哪几个 ？ </p><p>String Buffer   线程安全的    内部使用 <code>synchronized</code></p><p> String Builder 不是线程安全的 </p><p>String.Intern() </p><blockquote><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p></blockquote><p>解释下列现象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String string = <span class="hljs-string">&quot;anzhen&quot;</span>;<br>String anzhen = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;anzhen&quot;</span>);<br>System.out.println(string == anzhen);    <span class="hljs-comment">// false</span><br>System.out.println(anzhen.intern() == string);   <span class="hljs-comment">//  true </span><br></code></pre></td></tr></table></figure><p>创建对象不同， 直接使用字面量创建String的话 ，先检查字符串常量池里面是否有这个常量，如果有的话 就将引用赋值给变量 ，没有就在常量池里创建这个对象</p><blockquote><p>使用字面量创建字符串实例的，会将新建的对象放入String Poll中 </p></blockquote><p>如果使用new String(“111”)的方式去创建对象，先查看字符串常量池里面是否有相等的字符串，如果没有的话就创建，如果有的话将那个字符串的引用地址给对象，对象保存的是指向常量池的引用</p><blockquote><p>开辟了俩个空间 </p></blockquote><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol><li>数据 <ol><li>声明数据为常量，可以是编译时常量，也可能是运行时常量<ol><li>对于基本数据类型 ，数据不能改变</li><li>对于引用数据类型 ，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ol></li></ol></li><li>方法 <ol><li>声明的方法不能被子类重写</li></ol></li><li>类 <ol><li>声明的类不能被继承</li></ol></li></ol><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>静态变量和实例变量的区别 </p><blockquote><p>静态变量 ： 静态变量，称之为类变量，类的所有的实例都共享静态变量，静态变量在内存中只存在一份</p><p>实例变量：每创建一个实例就会产生一个实例变量，它与实例同生共死</p></blockquote><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>能不能声明 抽象静态方法 ？？？ </p><blockquote><p>不能， Illegal combination of modifiers: ‘abstract’ and ‘static’ 编译就会提示警告 </p><p>原因 : 静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，所以不能抽象的 </p></blockquote><p>注意事项，静态方法中，不能有this , super</p><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><p>静态代码块只在类加载的时候执行一次 </p><p>静态加载顺序呢 ？？ </p><blockquote><p>排在前面的先执行</p></blockquote><p>存在继承的情况下，初始化顺序为:</p><ul><li>父类(静态变量、静态语句块)</li><li>子类(静态变量、静态语句块)</li><li>父类(实例变量、普通语句块)</li><li>父类(构造函数)</li><li>子类(实例变量、普通语句块)</li><li>子类(构造函数)</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h5 id="泛型的10道面试题"><a href="#泛型的10道面试题" class="headerlink" title="泛型的10道面试题"></a>泛型的10道面试题</h5><h6 id="1、泛型是什么-？-有什么好处-？"><a href="#1、泛型是什么-？-有什么好处-？" class="headerlink" title="1、泛型是什么 ？  有什么好处 ？"></a>1、泛型是什么 ？  有什么好处 ？</h6><p><strong>泛型</strong> ：顾名思义就是 <strong>广泛的数据类型</strong>，也就是说什么数据类型都可以</p><p>提供了编译器的安全 ，只有填写对应的属性才可以通过编译 </p><h6 id="2、Java泛型如何工作？-什么是类型擦除-？？"><a href="#2、Java泛型如何工作？-什么是类型擦除-？？" class="headerlink" title="2、Java泛型如何工作？  什么是类型擦除 ？？"></a>2、Java泛型如何工作？  什么是类型擦除 ？？</h6><p>工作流程： </p><blockquote><p>Java中的泛型,只在编译阶段有效。在编译过程中,正确检验泛型结果后,会将泛型的相关信息擦出,并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说,泛型信息不会进入到运行时阶段。</p></blockquote><blockquote><p>编译之后会将泛型擦除，比如List<String> 编译之后 就是 List </String></p></blockquote><h6 id="3、什么是泛型中的限定通配符和非限定通配符-？？"><a href="#3、什么是泛型中的限定通配符和非限定通配符-？？" class="headerlink" title="3、什么是泛型中的限定通配符和非限定通配符 ？？"></a>3、什么是泛型中的限定通配符和非限定通配符 ？？</h6><blockquote><p>&lt; ? extends T&gt;  一定要是T类的子类才可以用这个</p></blockquote><blockquote><?  super   T> 一定要是这个类的父类才可以用 </blockquote><h6 id="4、用泛型写一个缓存淘汰算法"><a href="#4、用泛型写一个缓存淘汰算法" class="headerlink" title="4、用泛型写一个缓存淘汰算法"></a>4、用泛型写一个缓存淘汰算法</h6><blockquote><p>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示LinkedHashMap可以用来实现固定大小的LRU缓存  ，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p></blockquote><h6 id="5、Array中可以用泛型吗"><a href="#5、Array中可以用泛型吗" class="headerlink" title="5、Array中可以用泛型吗?"></a>5、Array中可以用泛型吗?</h6><blockquote><p>不可以， 如果数组想要使用泛型的话  可以使用list</p></blockquote><h6 id="6、如何阻止Java中的类型未检查的警告"><a href="#6、如何阻止Java中的类型未检查的警告" class="headerlink" title="6、如何阻止Java中的类型未检查的警告?"></a>6、如何阻止Java中的类型未检查的警告?</h6><blockquote><p>将JDK版本提高到5.0以上</p></blockquote><h6 id="7、你可以把List传递给一个接受List参数的方法吗？"><a href="#7、你可以把List传递给一个接受List参数的方法吗？" class="headerlink" title="7、你可以把List传递给一个接受List参数的方法吗？"></a>7、你可以把List<String>传递给一个接受List<Object>参数的方法吗？</Object></String></h6><blockquote><p>不可以， 这样会导致编译报错 ，</p></blockquote><h3 id="接口和实现类的区别"><a href="#接口和实现类的区别" class="headerlink" title="接口和实现类的区别"></a>接口和实现类的区别</h3><ul><li>一个子类只能继承一个抽象类,但能实现多个接口</li><li>抽象类可以有构造方法,接口没有构造方法</li><li>抽象类可以有普通成员变量,接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li><li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li><li>抽象类可以有静态方法，接口不能有静态方法</li><li>抽象类中的方法可以是public、protected;接口方法只有public abstract</li></ul><h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><blockquote><p>反射是什么 ？ </p><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意的对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称之为Java的反射机制</p></blockquote><p>如何理解Java的一切都是对象</p><blockquote><p>反射就是把java类中的各种成分映射成一个个的Java对象     类也是对象  例如：一个类有实例变量  静态变量， 方法  构造方法，包等等信息，利用反射技术可以对一个类进行剖析，把一个个组成部分映射成一个个Java对象</p></blockquote><ul><li>Class类也是类的一种，与class关键字不同。</li><li>手动编写的类被编译后会产生一个Class对象；其表示是创建的类的类型信息，而且这个Class对象保存在同名.class文件中</li><li>每个通过关键词class标识的类，在内存中有且只有一个与之相对应得Class对象来描述类信息，无论创建多少个实例对象，其依据的都是用一个Class对象 </li><li>Class类只存私有的构造器，因此Class对象只能由JVM创建和加载 </li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要</li></ul><p>获取Class对象的几种方式？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Class对象的三种方式</span><br>logger.info(<span class="hljs-string">&quot;根据类名:  \t&quot;</span> + User.class);<br>logger.info(<span class="hljs-string">&quot;根据对象:  \t&quot;</span> + <span class="hljs-keyword">new</span> User().getClass());<br>logger.info(<span class="hljs-string">&quot;根据全限定类名:\t&quot;</span> + Class.forName(<span class="hljs-string">&quot;com.test.User&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="反射调用流程小结"><a href="#反射调用流程小结" class="headerlink" title="反射调用流程小结"></a>反射调用流程小结</h4><p>最后，用几句话总结反射的实现原理：</p><ol><li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li><li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题提取</title>
    <link href="/2021/07/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%8F%90%E5%8F%96/"/>
    <url>/2021/07/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="面试题基础板块"><a href="#面试题基础板块" class="headerlink" title="面试题基础板块"></a>面试题基础板块</h2><h3 id="JavaSe-常见面试题"><a href="#JavaSe-常见面试题" class="headerlink" title="JavaSe 常见面试题"></a><code>JavaSe</code> 常见面试题</h3><h4 id="1、-和-equals-的区别"><a href="#1、-和-equals-的区别" class="headerlink" title="1、==  和  equals 的区别"></a>1、==  和  equals 的区别</h4><blockquote><p>== 比较的是地址值   </p><p>​            基本类型 比较的是数值</p><p>​            引用类型 比较的是地址</p><p>equals 比较的是具体的值</p></blockquote><p>总结 </p><blockquote><p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p></blockquote><h4 id="2、接口和抽象类的区别"><a href="#2、接口和抽象类的区别" class="headerlink" title="2、接口和抽象类的区别"></a>2、接口和抽象类的区别</h4><ul><li><p><strong>都不能实例化</strong>，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p></li><li><p><strong>抽象类需要被继承，接口需要被实现</strong></p></li><li><p>接口只能做方法申明（类似一个规范），抽象类中可以做方法申明，也可以做方法实现 （增强代码的扩展性）</p></li><li><p>接口定义的变量只能是公共的静态常量，抽象类中定义的变量是普通变量。</p></li><li><p>抽象类中的所有抽象方法都需要被子类实现，如果不能实现父类的全部方法，那么该子类只能是抽象类，一个类实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p></li><li><p><strong>抽象方法只能申明，不能实现</strong></p></li><li><p>抽象类里面可以没有抽象方法，接口里面方法没有方法体</p></li><li><p>如果一个类里面有抽象方法，那么这个类只能是抽象类，</p></li><li><p>抽象类的所有方法不能为静态和私有的，因为所有的抽象方法需要被实现。</p></li><li><p>接口可多实现，抽象类只能继承单个继承</p></li></ul><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>abstract</td><td>interface</td></tr><tr><td>实现</td><td>子类通过extends来继承抽象类，如果<strong>子类不是抽象类</strong>的话需要提供抽象类中所有的证明方法的实现</td><td>通过实现implements关键字来实现接口，它需要提供接口中所有的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中可以是任意访问修饰符</td><td>接口方法默认是public，并且不允许定义为private或者是protected</td></tr><tr><td>多继承</td><td>一个类中直接继承一个</td><td>一个类中可以多实现接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段都是static  和   final修饰的</td></tr></tbody></table><h4 id="3、常用的集合类"><a href="#3、常用的集合类" class="headerlink" title="3、常用的集合类"></a>3、常用的集合类</h4><h6 id="是否线程安全"><a href="#是否线程安全" class="headerlink" title="是否线程安全"></a>是否线程安全</h6><h6 id="如何保证集合类线程安全"><a href="#如何保证集合类线程安全" class="headerlink" title="如何保证集合类线程安全"></a>如何保证集合类线程安全</h6><p>List</p><ul><li><p><code>ArrayList</code></p><blockquote><p>非线程安全    </p><p>保证线程安全的方式 ：</p><ol><li><p>使用Vector  </p></li><li><p>使用<code>Collections.synchronizedList()</code>给集合类加锁 </p></li><li><p>使用新的集合类   CopyOnWriteArrayList 写时复制， 效率高 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();   <br><span class="hljs-comment">// 线程安全  (执行效率变低)  == 不建议使用</span><br>List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment">// 使用collections 工具库创建 线程安全的集合</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;(); <span class="hljs-comment">// 写时复制</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>HashMap</code></p><blockquote><p>非线程安全 </p><p>保证线程安全的方式：</p><ol><li>给集合类，加锁 </li><li>使用JUC包下的集合类   <code>ConcurrentHashMap</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 效率低下   不推荐使用</span><br>Map&lt;String,String&gt; hash = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br><br><span class="hljs-comment">// JUC 的hashMap 推荐使用  线程安全  读写分离</span><br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap();<br></code></pre></td></tr></table></figure></blockquote></li></ul><h4 id="4、BIO、NIO、AIO-有什么区别？"><a href="#4、BIO、NIO、AIO-有什么区别？" class="headerlink" title="4、BIO、NIO、AIO 有什么区别？"></a><strong>4、<code>BIO</code>、<code>NIO</code>、<code>AIO</code> 有什么区别？</strong></h4><ul><li><code>BIO</code>：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li><code>NIO</code>：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li><code>AIO</code>：Asynchronous IO 是 <code>NIO</code> 的升级，也叫 <code>NIO2</code>，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h4 id="5、什么是线程和进程"><a href="#5、什么是线程和进程" class="headerlink" title="5、什么是线程和进程"></a>5、什么是线程和进程</h4><p>详情查看另一篇博客 </p><p><strong><code>JMM</code>是什么</strong>  ？</p><blockquote><p>是一套规范 ， 解决了多线程在通过共享内存进行通信时，储存在本地内存时数据不一致，编译器会对代码指令重排，CPU乱序执行所带来的问题</p></blockquote><h4 id="6、this与super的区别"><a href="#6、this与super的区别" class="headerlink" title="6、this与super的区别"></a>6、this与super的区别</h4><ul><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h3 id="JVM常见面试题"><a href="#JVM常见面试题" class="headerlink" title="JVM常见面试题"></a><code>JVM常见面试题</code></h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a><code>JVM</code>内存结构</h4><p>内存分布图 </p><p>浅谈几大内存结构 </p><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（<code>Methed Area</code>）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><p><code>JVM</code>内存结构图</p><p><img src="/2021/07/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%8F%90%E5%8F%96/image-20210706083832326.png" alt="image-20210706083832326"></p><p>创建对象流程</p><p>判断该对象对应的类是否以及加载过 </p><p>为对象分配内存</p><ol><li><p>如果内存规整的话采用指针碰撞创建内存 </p></li><li><p>如果内存不规整的话</p><ol><li>虚拟机需要维护一个列表 </li><li>空闲列表分配</li></ol></li><li><p>处理并发安全问题</p><ol><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配一块TLAB</li></ol></li><li><p>初始化分配的空间 - 所有的属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p></li><li><p>设置对象的对象头</p></li><li><p>执行inti方法进行初始化</p></li></ol><p>什么是指针碰撞 ？？</p><blockquote><p>如果是Java堆的内存是规整，即使所有的内存用过的都在一边，没用过的都在另一边。分配内存时将中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成内存分工作</p></blockquote><p>空闲列表？？</p><blockquote><p>如果Java堆的内存是不完整的，则需要有虚拟机维护一个列表来记录那些内存是可以用的，这样在分配的时候可以从列表中查询到足够大的内存空间分配给对象，更新空闲列表</p></blockquote><p>如何解决对象并发安全 ？？</p><blockquote><ol><li><p>对分配的内存空间的动作进行同步处理（采用CAS +失败重试来保障更新操作的原子性）</p></li><li><p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配了一小块内存，称之为本地线程分配缓冲（Thread Local Allocation Buffer, <code>TLAB</code>）哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁。通过设置虚拟机参数：-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</p></li></ol></blockquote><p>浅拷贝和深拷贝 </p><blockquote><p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p><p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p></blockquote><h3 id="Spring常见面试题"><a href="#Spring常见面试题" class="headerlink" title="Spring常见面试题"></a>Spring常见面试题</h3><h4 id="1、SpringIOC"><a href="#1、SpringIOC" class="headerlink" title="1、SpringIOC"></a>1、<code>SpringIOC</code></h4><p><code>IOC</code>控制反转, 将创建对象的操作交予Spring管理，</p><blockquote><p>对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p></blockquote><p><code>IOC</code>有什么作用</p><p>管理对象的创建和依赖关系的维护。对象创建并不是一件简单事，当对象关系复杂的时，如果依赖关系需要程序员来维护的话，那是相当头疼的</p><p>解耦，由容器去维护具体的对象</p><p>托管了类的生产过程，比如我们需要在类的生产过程中做一些处理，最直接的例子就是代理，如果由容器可以把这部分处理交予容器，应用程序无需关心类时如何完成代理的</p><p><code>IOC</code>有什么功能</p><ul><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li></ul><h4 id="2、SpringAOP"><a href="#2、SpringAOP" class="headerlink" title="2、SpringAOP"></a>2、<code>SpringAOP</code></h4>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis6Learn</title>
    <link href="/2021/06/25/Redis6Learn/"/>
    <url>/2021/06/25/Redis6Learn/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>redis 中的字符串value最多可以是512m</p><p>关于字符串的操作命令 </p><blockquote><p>set <key>  value </key></p><p>get <key> </key></p><p>append <key>  value  ： 追加 </key></p><p>strlen <key>  ： 获取key长度</key></p><p>setnx  <key>   <value>  :  只有当key不存在时    设置key的值</value></key></p><p>incr <key>   将key中存储的数字+1    只能对数字值操作，如果为空，新增值为1 （是原子性操作 ）</key></p><p>decr  <key>  将key 中的数字 - 1</key></p></blockquote><p>多个key 和 value的操作 </p><blockquote><p> mset <key> <value> <key> <value>  </value></key></value></key></p><p>原子性操作</p><p>msetnx  <key> <value> <key> <value>   : 如果key中有之前存在过的  则不会设置成功</value></key></value></key></p><p>setrange   <key>    <start>   <value> :   设置key 从start开始往后的所有值都是value</value></start></key></p><p>setex <key> <seconds>  <value>  :    设置过期时间   </value></seconds></key></p></blockquote><blockquote><p>mget <key> <value> <key> <value> </value></key></value></key></p><p>getrange <key>  start  end  :  设置起始位置  类似于SubString    包含 start 和 end </key></p><p>getset <key>  <value>  : 以新值换旧值</value></key></p></blockquote><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特点 ： 单键多值</p><p>底层是一个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能较差</p><p>常用命令 ：</p><blockquote><p>lpush / rpush <key>  <value>  <value>   <value>  </value></value></value></key></p><p> 一个key 多个value  从左边或者是右边插入一个或者是多个值 </p></blockquote><blockquote><p>ipop/rpop <key>  ： 从左边、右边弹出一个值， 值在键在，值亡键亡 </key></p></blockquote><blockquote><p>rpoplpush <key>  <key1>  ： 从 key 右边弹出一个值  放入key1的左边 </key1></key></p></blockquote><blockquote><p>lrange  <key>  <start>  <end>  ： 从左到右，按照下标获得元素</end></start></key></p><p>lrange  <key>   0   -1 ：  遍历所有的值</key></p><p>lindex   <key>  <index>  :   从左到右 ， 去key中下标index中的值</index></key></p><p>llen  <key>  ： 获取key长度</key></p></blockquote><p><img src="/2021/06/25/Redis6Learn/image-20210625211038918.png" alt="image-20210625211038918"></p><p>注意  before 是在前面的意思    图中有失误</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>特点 ： 无需，不存储重复数据 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; sadd k1 v1 v2 v3    : 往<span class="hljs-built_in">set</span>集合添加值 <br>(<span class="hljs-built_in">integer</span>) 3     <br>192.168.1.57:6379&gt; smembers k1    : 遍历<span class="hljs-built_in">set</span>集合<br>1) <span class="hljs-string">&quot;v2&quot;</span><br>2) <span class="hljs-string">&quot;v1&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br>192.168.1.57:6379&gt; sismember k1 v1    : 检测key里面有没有v1<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; sismember k1 v3<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; scard k1    : 获取<span class="hljs-built_in">set</span>集合长度<br>(<span class="hljs-built_in">integer</span>) 3<br>192.168.1.57:6379&gt; srem k1 v1    :  指定value 弹出 key<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; smembers k1  <br>1) <span class="hljs-string">&quot;v2&quot;</span><br>2) <span class="hljs-string">&quot;v3&quot;</span><br>192.168.1.57:6379&gt; spop k1   : 随机弹出一个数据  <br><span class="hljs-string">&quot;v3&quot;</span><br>192.168.1.57:6379&gt; srandmember k1 2    : 从key中随机取俩个值  不会删除数据<br><br>192.168.1.57:6379&gt; smove k1 k2 v2<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; smembers k2<br>1) <span class="hljs-string">&quot;v2&quot;</span><br>2) <span class="hljs-string">&quot;4&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>4) <span class="hljs-string">&quot;1&quot;</span><br>192.168.1.57:6379&gt; sinter k1 k2  : 取俩个结合交集<br>(empty list or <span class="hljs-built_in">set</span>)<br>192.168.1.57:6379&gt;  sunion k1 k2  : 取俩个集合并集<br>1) <span class="hljs-string">&quot;4&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br>4) <span class="hljs-string">&quot;3&quot;</span><br>192.168.1.57:6379&gt; sdiff k1 k2  : 取俩个集合差集<br>(empty list or <span class="hljs-built_in">set</span>)<br></code></pre></td></tr></table></figure><p>底层数据结构，就是用hash表去除value字段 用filed做value</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>特点 ： key  -&gt; value</p><p>关系映射图 ： </p><p><img src="/2021/06/25/Redis6Learn/image-20210625215237439.png" alt="image-20210625215237439"></p><p>常用命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; hset user:1001 id 1  <span class="hljs-comment"># 创建hash &lt;key&gt;  field value </span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; hset user:1001 name zhangshan  <span class="hljs-comment"># 添加 属性 </span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; hget user:1001 id   <span class="hljs-comment"># 通过filed 获取key中的value</span><br><span class="hljs-string">&quot;1&quot;</span><br>192.168.1.57:6379&gt; hmset user:1001 age 10 danger 12 <span class="hljs-comment"># 批量添加filed 和 value </span><br>OK<br>192.168.1.57:6379&gt; hexists user:1001 id <span class="hljs-comment"># 判断key中是否有这个属性</span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt;<br>192.168.1.57:6379&gt; hkeys user:1001 <span class="hljs-comment"># 获取key中所有的属性 </span><br>1) <span class="hljs-string">&quot;id&quot;</span><br>2) <span class="hljs-string">&quot;name&quot;</span><br>3) <span class="hljs-string">&quot;age&quot;</span><br>4) <span class="hljs-string">&quot;danger&quot;</span><br>192.168.1.57:6379&gt; hvals user:1001  <span class="hljs-comment"># 获取key中所有的值</span><br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;zhangshan&quot;</span><br>3) <span class="hljs-string">&quot;10&quot;</span><br>4) <span class="hljs-string">&quot;12&quot;</span><br>192.168.1.57:6379&gt; hincrby user:1001 age 2 <span class="hljs-comment"># 获取key中filed 属性加 2 </span><br>(<span class="hljs-built_in">integer</span>) 12<br>192.168.1.57:6379&gt;  hsetnx user:1001 age 222 <span class="hljs-comment"># 如果key中有这个filed则添加失败否则成功</span><br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>底层数据结构</p><h2 id="2、常用命令"><a href="#2、常用命令" class="headerlink" title="2、常用命令"></a>2、常用命令</h2><p>创建key :  set  key  value</p><p>查看所有key  : keys *</p><p>判断key是否存在 ： exists key</p><p>查看key类型 ： type key </p><p>删除key : del  key</p><p>阻塞删除key :  unlink  key  </p><p>设置key的过期时间  : expire  key </p><p>查看key的剩余时间 ： ttl   key    -1表示永不过期   -2 表示已经过期 </p><p>切换数据库   ： select   index   </p><p>查看数据库中的key 数量 ： dbsize</p><h2 id="3、Redis发布和订阅"><a href="#3、Redis发布和订阅" class="headerlink" title="3、Redis发布和订阅"></a>3、Redis发布和订阅</h2><h3 id="3-1、-什么是发布和订阅"><a href="#3-1、-什么是发布和订阅" class="headerlink" title="3.1、 什么是发布和订阅"></a>3.1、 什么是发布和订阅</h3><blockquote><p>是一种消息通信模式： 发布者发送消息，订阅者接收消息</p></blockquote><h3 id="3-2、-Redis发布和订阅"><a href="#3-2、-Redis发布和订阅" class="headerlink" title="3.2、 Redis发布和订阅"></a>3.2、 Redis发布和订阅</h3><p>订阅端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; subscribe channel  <span class="hljs-comment"># 订阅频道命令 </span><br>Reading messages... (press Ctrl-C to quit)<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;channel&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br>1) <span class="hljs-string">&quot;message&quot;</span><br>2) <span class="hljs-string">&quot;channel&quot;</span><br>3) <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>发布端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; publish channel <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment"># 向频道中发送信息</span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt;<br></code></pre></td></tr></table></figure><h2 id="4、Redis6-新数据类型"><a href="#4、Redis6-新数据类型" class="headerlink" title="4、Redis6 新数据类型"></a>4、Redis6 新数据类型</h2><h4 id="4-1、bitmaps"><a href="#4-1、bitmaps" class="headerlink" title="4.1、bitmaps"></a>4.1、bitmaps</h4><p>什么是bitmaps</p><blockquote><p>Bitmaps并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M。</p></blockquote><blockquote><p>字节操作可以分为两类：恒定时间的单个字节操作如将一个字节设置为1或者0、或者获取一个字节的值，和批量字节操作如在给定的字节范围内计算设置字节的数量。</p></blockquote><p> <img src="/2021/06/25/Redis6Learn/image-20210626124901895.png" alt="image-20210626124901895"></p><p>Redis中bitmaps的常用操作<br>基本使用<br>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p><ol><li>setbit key offset value</li><li>getbit key offset</li></ol><ol start="3"><li><p>bitcount key [start end]</p></li><li><p>bitpos key targetBit [start] [end] （起始版本：2.8.7）</p></li></ol><p>计算位图指定范围（start到end，单位为字节，如果不指定就是获取全部）第一个偏移量对应的值等于targetBit的位置。</p><ol start="5"><li>bitop and|or|not|xor destkey key [key…]</li></ol><p>做多个bitmap的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存到destkey中。</p><p>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p><p>6.魔术指令 bitfield</p><p>前文我们设置 (setbit) 和获取 (getbit) 指定位的值都是单个位的，如果要一次操作多个位，就必须使用管道来处理。</p><p>不过 Redis 的 3.2 版本以后新增了一个功能强大的指令，有了这条指令，不用管道也可以一次进行多个位的操作。</p><p>bitfield 有三个子指令，分别是 get/set/incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个</p><h4 id="4-2、HyperLogLog"><a href="#4-2、HyperLogLog" class="headerlink" title="4.2、HyperLogLog"></a>4.2、HyperLogLog</h4><p>用途： 用来做基数统计的算法</p><p>常用命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; pfadd program &quot;java&quot;  # 创建HyperLogLog <br>(integer) 1<br>127.0.0.1:6379&gt; pfadd program &quot;php&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; pfadd program &quot;java&quot;  # 如果有相同的则返回0  成功加入返回1<br>(integer) 0<br>127.0.0.1:6379&gt; pfadd program &quot;spring&quot; &quot;mysql&quot; # 添加多个value  <br>(integer) 1<br>127.0.0.1:6379&gt; pfcount program3  # 统计个数<br>(integer) 7<br>127.0.0.1:6379&gt; pfmerge program3 program program1  # 将俩个合并到一个里面去<br>OK<br></code></pre></td></tr></table></figure><h4 id="4-3、Geospatial"><a href="#4-3、Geospatial" class="headerlink" title="4.3、Geospatial"></a>4.3、Geospatial</h4><p>提供了经纬度，查询，范围查询，距离查询，经纬度 hash等常见操作</p><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; geoadd china 121.48 41.23 shanghai #  创建geo数据类型<br>(integer) 1<br>127.0.0.1:6379&gt; geopos china shanghai   #  获取<br>1) 1) &quot;121.48000091314315796&quot;<br>   2) &quot;41.23000123535113914&quot;<br>127.0.0.1:6379&gt; geoadd china 106.50 29.53 beijng<br>(integer) 1<br>127.0.0.1:6379&gt; geodist china beijng shanghai  km # 两个地方相隔<br>&quot;1875.9716&quot;<br>127.0.0.1:6379&gt; georadius china 110 30 1000 km # 查找周围范围的value<br>1) &quot;beijng&quot;<br><br></code></pre></td></tr></table></figure><h2 id="5、Redis事务"><a href="#5、Redis事务" class="headerlink" title="5、Redis事务"></a>5、Redis事务</h2><h4 id="5-1、redis事务是什么"><a href="#5-1、redis事务是什么" class="headerlink" title="5.1、redis事务是什么"></a>5.1、redis事务是什么</h4><blockquote><p>是一个隔离操作：事务中的所有命令都会序列化，按照顺序执行。事务在执行过程中，不会被其他的客户端发来的请求所打断</p><p>作用：串连多个操作 防止别的命令进行插队</p></blockquote><h4 id="5-2、-事务怎么样使用"><a href="#5-2、-事务怎么样使用" class="headerlink" title="5.2、 事务怎么样使用"></a>5.2、 事务怎么样使用</h4><p>Redis 事务命令   ： </p><p>multi (开启事务) 进入组队模式  </p><p>exec  (执行命令)  执行队列中的命令</p><p>discard (消除命令) ：将队列中的命令清空 关闭事务</p><p><img src="/2021/06/25/Redis6Learn/image-20210626151933051.png" alt="image-20210626151933051"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi  # 开启redis事务 <br>OK<br>127.0.0.1:6379(TX)&gt; set key anzhen  # 将命令放入队列中<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k1 zimu<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec  # 将队列的命令一起执行 <br>1) OK<br>2) OK<br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure><p>几点注意事项 ： </p><blockquote><p>如果是在组队阶段，命令出现了错误时，所有命令都不会执行 </p><p>如果时在执行阶段，出现了错误时，会继续执行下一条命令</p></blockquote><h4 id="5-3、Redis事务锁机制"><a href="#5-3、Redis事务锁机制" class="headerlink" title="5.3、Redis事务锁机制"></a>5.3、Redis事务锁机制</h4><p>解决事务冲突时用到什么锁  ？？</p><ul><li><p>悲观锁</p><ul><li><blockquote><p>悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></blockquote><p>缺点  ——&gt;   效率太低 ：只能一个线程进行操作 </p></li></ul></li><li><p>乐观锁</p><ul><li><blockquote><p>进行操作时，给线程数据加上字段 version，通过版本号判断数据有没有被修改过</p></blockquote></li></ul></li></ul><h4 id="5-4、Redis事务三特性"><a href="#5-4、Redis事务三特性" class="headerlink" title="5.4、Redis事务三特性"></a>5.4、Redis事务三特性</h4><ul><li>不保证原子性 <ul><li>事务中，如果出现错误不会发生回滚 ，而是执行下一条命令</li></ul></li><li>没有隔离级别的概念<ul><li>队列中的命令没有提交之前都不会实际执行，因为事务提交前任何命令都不会实际执行</li></ul></li><li>单独的隔离操作<ul><li>事务中所有的命令都会序列化，按照顺序执行。事务执行的过程中，不会被其他客户端发来的命令请求所打断</li></ul></li></ul><h2 id="6、Redis-主从复制"><a href="#6、Redis-主从复制" class="headerlink" title="6、Redis 主从复制"></a>6、Redis 主从复制</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">port:26379<br>daemonize yes<br>sentinel<span class="hljs-built_in"> monitor </span>mymaster<br></code></pre></td></tr></table></figure><p>主从复制特点以及 ： </p><p>读写分离 ， 主服务器用来写入， 从服务器用来读取</p><p>容灾快速回复： 如果从服务器挂了的话，可以切换到另一台从服务器</p><p>搭建详情: 查看此博客 <a href="https://www.cnblogs.com/kingyifan/p/11721422.html#!comments">https://www.cnblogs.com/kingyifan/p/11721422.html#!comments</a></p><p>redis 集群搭建： <a href="https://www.cnblogs.com/niceyoo/p/14118146.html">https://www.cnblogs.com/niceyoo/p/14118146.html</a> 查看此博客 </p><p>声明  所有的搭建都是在docker 上搭建的</p><h2 id="7、缓存的三大问题"><a href="#7、缓存的三大问题" class="headerlink" title="7、缓存的三大问题"></a>7、缓存的三大问题</h2><h3 id="7-1、缓存穿透"><a href="#7-1、缓存穿透" class="headerlink" title="7.1、缓存穿透"></a>7.1、缓存穿透</h3><p>是什么</p><blockquote><p> 缓存的命中率减低，导致请求绝大部分直接走数据库，造成数据库压力过大甚至宕机</p></blockquote><p><img src="/2021/06/25/Redis6Learn/image-20210627172316133.png" alt="image-20210627172316133"></p><p> <img src="/2021/06/25/Redis6Learn/image-20210627172541377.png" alt="image-20210627172541377"></p><h3 id="7-2、缓存雪崩"><a href="#7-2、缓存雪崩" class="headerlink" title="7.2、缓存雪崩"></a>7.2、缓存雪崩</h3><p>是什么</p><blockquote><p>极少时间段，查询大量key的集中过期情况</p></blockquote><p>解决方案 ：</p><ul><li><p>构建多级缓存架构： nginx(缓存） + redis(缓存) + ehcache(其他缓存)</p></li><li><p>使用锁或者是队列 </p><ul><li>使用锁或者是队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适合高并发情况</li></ul></li><li><p>设置过期标志更新缓存：</p><ul><li>记录缓存数据是否已过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存</li></ul></li><li><p>将缓存失效时间分散开：</p><ul><li>我们可以在原来失效时间的基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，很难引发集体失效的事件。</li></ul></li></ul><h3 id="7-3、缓存击穿"><a href="#7-3、缓存击穿" class="headerlink" title="7.3、缓存击穿"></a>7.3、缓存击穿</h3><p>是什么</p><blockquote><p>某一个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。</p></blockquote><p>解决方案： </p><ul><li><p>预先设置热门数据 ：     在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key长</p></li><li><p>实时调整：现场监控那些数据热门，实时增加key的过期时长</p></li><li><p>使用锁 ：</p></li></ul><h2 id="8、Redis多线程"><a href="#8、Redis多线程" class="headerlink" title="8、Redis多线程"></a>8、Redis多线程</h2><p>Redis并不是多线程？ </p><blockquote><p>Redis是多路IO复用，执行命令还是单线程，</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity</title>
    <link href="/2021/06/18/SpringSecurity/"/>
    <url>/2021/06/18/SpringSecurity/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="1、-是什么？"><a href="#1、-是什么？" class="headerlink" title="1、 是什么？"></a>1、 是什么？</h2><p>看官网<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/">Spring Security Reference</a></p><h2 id="2、项目搭建"><a href="#2、项目搭建" class="headerlink" title="2、项目搭建"></a>2、项目搭建</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        spring security 安全管理框架--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动成功后 ， 后台日志会生成一串安全密码</p><p><img src="/2021/06/18/SpringSecurity/image-20210618201857845.png" alt="image-20210618201857845"></p><p>前台访问登录请求则是使用的Security自带的登录页面</p><img src="/2021/06/18/SpringSecurity/image-20210618202018351.png" alt="image-20210618202018351" style="zoom:33%;"> <p>账号使用的是 user  密码是 日志的密码</p><h4 id="SpringSecurity-Oauth2"><a href="#SpringSecurity-Oauth2" class="headerlink" title="SpringSecurity   +  Oauth2"></a><code>SpringSecurity</code>   +  Oauth2</h4><blockquote><p>配置 Security 配置器 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启安全控制</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 加密服务</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 关闭csrf防护</span><br>        http.csrf().disable()<br>                .authorizeRequests()<br>                <span class="hljs-comment">// 放行登录和认证</span><br>                .antMatchers(<span class="hljs-string">&quot;/oauth/**&quot;</span>,<span class="hljs-string">&quot;/login/**&quot;</span>, <span class="hljs-string">&quot;logout/**&quot;</span>)<br>                .permitAll()<br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .formLogin()<br>                .permitAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置<code>OAuth2</code> 的资源服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableResourceServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourcesServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// </span><br>        http.authorizeRequests()<br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .requestMatchers()<br>                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置<code>OAuth2</code> 的认证服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启授权服务器</span><br><span class="hljs-meta">@EnableAuthorizationServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;<br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * clients : 客户端详细信息服务配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        clients.inMemory()<br>                <span class="hljs-comment">// client id  </span><br>                .withClient(<span class="hljs-string">&quot;admin&quot;</span>) <br>                <span class="hljs-comment">// 密钥</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123123&quot;</span>))<br>                <span class="hljs-comment">// 设置重定向路径</span><br>                .redirectUris(<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>)<br>                <span class="hljs-comment">// 配置申请授权范围</span><br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br>                <span class="hljs-comment">// 设置授权类型  授权码模式 </span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;authorization_code&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>授权码模式  访问流程</p><ol><li><p>浏览器访问<a href="http://localhost:2313/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=https://www.bilibili.com&amp;scope=all">http://localhost:2313/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=https://www.bilibili.com&amp;scope=all</a></p></li><li><p>这条<code>url</code>的 的参数  必须和授权服务一致 否则会出现错误 </p><ol><li><blockquote><p>response_type=code </p><p>client_id=admin</p><p>redirect_uri=<a href="https://www.bilibili.com/">https://www.bilibili.com</a></p><p>scope=all</p></blockquote></li></ol></li></ol><p><img src="/2021/06/18/SpringSecurity/image-20210619163841308.png" alt="image-20210619163841308"></p><p>输入之后自动跳转 security的登录页面 </p><p><img src="/2021/06/18/SpringSecurity/image-20210619164144176.png" alt="image-20210619164144176"></p><p>code 就是授权码 </p><p><img src="/2021/06/18/SpringSecurity/image-20210619164205506.png" alt="image-20210619164205506"></p><p>这里的账号密码就是授权服务器的账号和密码<img src="/2021/06/18/SpringSecurity/image-20210619164255414.png" alt="image-20210619164255414"></p><p>这个里面的字段和<strong>授权服务器</strong>相同, 然后授权服务器发送token </p><p>访问login 并带上token </p><p><img src="/2021/06/18/SpringSecurity/image-20210619165450033.png" alt="image-20210619165450033"></p><p>访问接口带上token 即可返回正确数据</p><h4 id="使用Password模式进行认证"><a href="#使用Password模式进行认证" class="headerlink" title="使用Password模式进行认证"></a>使用Password模式进行认证</h4><p>增加一个方法  修改<code>authorizedGrantTypes</code> 类型为password</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启授权服务器</span><br><span class="hljs-meta">@EnableAuthorizationServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 密码模式需要使用的</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endpoints</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     * 将密码传输给授权服务器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//</span><br>        endpoints.authenticationManager(authenticationManager)<br>                .userDetailsService(userService);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * clients : 客户端详细信息服务配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        clients.inMemory()<br>                <span class="hljs-comment">// client id</span><br>                .withClient(<span class="hljs-string">&quot;admin&quot;</span>)<br>                <span class="hljs-comment">// 密钥</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123123&quot;</span>))<br>                <span class="hljs-comment">// 设置重定向路径</span><br>                .redirectUris(<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>)<br>                <span class="hljs-comment">// 配置申请授权范围</span><br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br>                <span class="hljs-comment">// 设置授权类型 使用授权码的方式</span><br>                <span class="hljs-comment">//.authorizedGrantTypes(&quot;authorization_code&quot;);</span><br>                <span class="hljs-comment">// 使用密码的方式</span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为需要注入<code>AuthenticationManager</code>所以需要往<code>SecurityConfig</code>里面配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启安全控制</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 加密服务</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>    &#125;<br><br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">super</span>.authenticationManager();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 关闭csrf防护</span><br>        http.csrf().disable()<br>                .authorizeRequests()<br>                <span class="hljs-comment">// 放行登录和认证</span><br>                .antMatchers(<span class="hljs-string">&quot;/oauth/**&quot;</span>,<span class="hljs-string">&quot;/login/**&quot;</span>, <span class="hljs-string">&quot;logout/**&quot;</span>)<br>                .permitAll()<br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .formLogin()<br>                .permitAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mallGateway</title>
    <link href="/2021/06/17/mallGateway/"/>
    <url>/2021/06/17/mallGateway/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是服务网关-？"><a href="#什么是服务网关-？" class="headerlink" title="什么是服务网关 ？"></a>什么是服务网关 ？</h2><ul><li><code>API </code>    是一个服务器，是系统统一堆外开放的入口，网关封装了内部架构，为每个客户端提供了一个定制的<code>API</code>。<code>API</code>网关方式的核心就是：所有的客户端和服务端通过统一的网关接入微服务，在网关层处理所有非业务功能</li></ul><p>优缺点 ：</p><ul><li>通过聚合接口使得服务对调用者透明，  降低客户端和服务端的耦合度。</li><li>聚合后台服务，节省流量，提高性能，提升用户体验</li><li>提供安全，流量控制，认证，过滤，监控，计费的API管理</li></ul><h2 id="为什么要有服务网关"><a href="#为什么要有服务网关" class="headerlink" title="为什么要有服务网关"></a>为什么要有服务网关</h2><p>单机应用  ： 浏览器发送请求给应用，应用查询数据库原路返回服务器，单机应用只有一个服务所以是用不上网关的</p><p><img src="/2021/06/17/mallGateway/image-20210617145224101.png" alt="image-20210617145224101"></p><p>微服务应用 ： </p><h3 id="网关解决了什么问题"><a href="#网关解决了什么问题" class="headerlink" title="网关解决了什么问题"></a>网关解决了什么问题</h3><ul><li>统一接入</li><li>认证授权</li><li>流量控制</li><li>协议适配  </li></ul><h3 id="Gateway-实现API网关"><a href="#Gateway-实现API网关" class="headerlink" title="Gateway 实现API网关"></a>Gateway 实现<code>API</code>网关</h3><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li><pre><code> **路由（router）** :  包括`id ` ,   目标`uri` ,    一组断言和一组过滤器组成。如果断言路由为真，则说明请求的Uri和配置相符</code></pre></li><li>​    <strong>断言（Predicate）</strong>：检验</li><li>​    <strong>过滤 （Filter）</strong>：</li></ul><h5 id="1、-路由的配置规则-："><a href="#1、-路由的配置规则-：" class="headerlink" title="1、 路由的配置规则 ："></a>1、 路由的配置规则 ：</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment">#配置路由路径</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-auth</span>   <span class="hljs-comment">#  路由id </span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-auth</span>   <span class="hljs-comment"># 目标微服务地址</span><br>          <span class="hljs-attr">predicates:</span>    <span class="hljs-comment">#  断言  检验请求地址是否和path相符  判断条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-auth/**</span>   <span class="hljs-comment">#  根据请求路进行跳转</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span> <br>            <span class="hljs-comment"># 根据指定时间前进行判断</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span><br>            <span class="hljs-comment"># 根据指定时间后进行判断</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="hljs-number">2017-01-21T17:42:47.789-07:00</span>[<span class="hljs-string">America/Denver</span>]<br>            <span class="hljs-comment"># 根据指定时间内进行判断</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=chocolate,</span> <span class="hljs-string">ch.p</span><br>            <span class="hljs-comment"># 根据cookie 进行判断</span><br>            <br></code></pre></td></tr></table></figure><h4 id="2、动态路由规则-："><a href="#2、动态路由规则-：" class="headerlink" title="2、动态路由规则 ："></a>2、动态路由规则 ：</h4><p>动态获取微服务地址： </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span>   <br>          <span class="hljs-comment"># 通过开启与服务发现进行结合，通过serviceId转发到具体服务实例。</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">lower-case-service-id:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#使用小写service-id</span><br></code></pre></td></tr></table></figure><p>3、 Path过滤器</p><p>4、 全局过滤器 <code>Global Filter</code> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">全局过滤器不需要在配置文件中配置，作用在所有的路由上，最终通过   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker搭建笔记</title>
    <link href="/2021/06/16/docker%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/16/docker%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="docker-搭建-RibbitMQ"><a href="#docker-搭建-RibbitMQ" class="headerlink" title="docker 搭建 RibbitMQ"></a>docker 搭建 RibbitMQ</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 拉取镜像</span><br>docker pull rabbitmq<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看所有镜像</span><br>docker images<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 创建容器</span> <br>docker run -d --name rabbitmq<br>-p 5672:5672<br>-p 15672:15672<br>-v `pwd`/data:/var/lib/rabbitmq<br>--hostname myRabbit <br>-e RABBITMQ_DEFAULT_VHOST=my_vhost  <br>-e RABBITMQ_DEFAULT_USER=admin <br>-e RABBITMQ_DEFAULT_PASS=admin rabbitmq<br><br><br>rabbitmq 是指image name<br>-d 后台运行容器；<br>--name 指定容器名；<br>-p 指定服务运行的端口（5672：应用访问端口；15672：控制台Web端口号）；<br>-v 映射目录或文件；<br>--hostname 主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；<br>-e 指定环境变量；（<br>RABBITMQ_DEFAULT_VHOST：默认虚拟机名；<br>RABBITMQ_DEFAULT_USER：默认的用户名；<br>RABBITMQ_DEFAULT_PASS：默认用户名的密码）<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看运行容器</span> <br>docker ps <br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 启动管理程序</span> <br><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it【交互式方式执行命令】容器id/容器name 命令</span><br>docker exec -it rabbitmq  rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><h2 id="Docker搭建Redis6"><a href="#Docker搭建Redis6" class="headerlink" title="Docker搭建Redis6"></a>Docker搭建Redis6</h2><h4 id="1、-拉取镜像"><a href="#1、-拉取镜像" class="headerlink" title="1、 拉取镜像"></a>1、 拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull redis<br></code></pre></td></tr></table></figure><h4 id="2、下载配置文件"><a href="#2、下载配置文件" class="headerlink" title="2、下载配置文件"></a>2、下载配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建本地文件映射 </span><br><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span><br>mkdir redis<br><span class="hljs-built_in">cd</span> redis<br><span class="hljs-comment"># 下载配置文件</span><br>wget http://download.redis.io/redis-stable/redis.conf<br><br><span class="hljs-comment"># 修改配置文件</span><br><span class="hljs-comment"># 关闭ip绑定 </span><br><span class="hljs-built_in">bind</span> 127.0.0.1 -::1 注释掉这行<br></code></pre></td></tr></table></figure><p><strong>关闭保护模式（默认是yes）</strong></p><p><img src="/2021/06/16/docker%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/image-20210622084518055.png" alt="image-20210622084518055"></p><h4 id="3、-创建容器"><a href="#3、-创建容器" class="headerlink" title="3、 创建容器"></a>3、 创建容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 6379:6379  -v <span class="hljs-variable">$PWD</span>/data:/data -v <span class="hljs-variable">$PWD</span>/redis.conf:/etc/redis/redis.conf --privileged=<span class="hljs-literal">true</span> --name mredis -d redis redis-server /etc/redis/redis.conf<br><br><br><br><br>创建哨兵模式的redis <br>docker run -p 6379:6379 -p 26379:26379   -v <span class="hljs-variable">$PWD</span>/data:/data -v <span class="hljs-variable">$PWD</span>/redis.conf:/etc/redis/redis.conf --privileged=<span class="hljs-literal">true</span> --name sentinelredis -d redis redis-server /etc/redis/redis.conf<br><br><span class="hljs-comment"># 进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> -it redis /bin/bash<br><br><span class="hljs-comment"># 更新依赖  安装vim</span><br>apt-get update<br>apt-get install -y vim<br></code></pre></td></tr></table></figure><h4 id="4、查看运行状态"><a href="#4、查看运行状态" class="headerlink" title="4、查看运行状态"></a>4、查看运行状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><h4 id="5、-进入本地客户端"><a href="#5、-进入本地客户端" class="headerlink" title="5、 进入本地客户端"></a>5、 进入本地客户端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mredis(与创建的容器名相对应) redis-cli<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mall学习笔记</title>
    <link href="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1、项目结构分析"><a href="#1、项目结构分析" class="headerlink" title="1、项目结构分析"></a>1、项目结构分析</h2><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210616131124608.png" alt="image-20210616131124608"> </p><p><code>mall-admin</code> ： 主业务模块</p><p><code>mall-auth</code> ： 用户认证模块</p><p><code>mall-common </code>：公共模块</p><p><code>mall-monitor </code>：监控模块</p><p><code>mall-portal </code>： 前端用户接口</p><p><code>mall-search</code> ： 搜索模块</p><p><code>mall-mbg</code> ： Mapper配置文件和接口</p><p><code>mall-gateway</code> ：网关模块 </p><p>所有的请求都走网关进入先阅读<code>gateway</code>和<code>auth</code></p><h3 id="Gateway模块"><a href="#Gateway模块" class="headerlink" title="Gateway模块"></a>Gateway模块</h3><h4 id="1、先查看配置文件"><a href="#1、先查看配置文件" class="headerlink" title="1、先查看配置文件"></a>1、先查看配置文件</h4><h5 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a><strong><code>application.yaml</code></strong></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8201</span><br>  <br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">lower-case-service-id:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#使用小写service-id</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment">#配置路由路径</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-auth</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-auth</span><br>          <span class="hljs-attr">predicates:</span>  <span class="hljs-comment"># 使用路径断言</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-auth/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-admin</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-admin</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-admin/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span>    <br>            <span class="hljs-comment"># 分割请求路径  默认前端请求路径都带mall-admin 将mall-admin分割掉</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-portal</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-portal</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-portal/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-search</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-search</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-search/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-demo</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-demo</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-demo/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">oauth2:</span><br>      <span class="hljs-attr">resourceserver:</span><br>        <span class="hljs-attr">jwt:</span><br>          <span class="hljs-attr">jwk-set-uri:</span> <span class="hljs-string">&#x27;http://localhost:8201/mall-auth/rsa/publicKey&#x27;</span> <span class="hljs-comment">#配置RSA的公钥访问地址</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-comment">#host: 192.168.1.57</span><br>    <span class="hljs-attr">password:</span><br><span class="hljs-attr">secure:</span><br>  <span class="hljs-attr">ignore:</span><br>    <span class="hljs-attr">urls:</span> <span class="hljs-comment">#配置白名单路径</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/doc.html&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/swagger-resources/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/swagger/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/v2/api-docs&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.js&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.css&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.png&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.ico&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/webjars/springfox-swagger-ui/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/actuator/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-auth/oauth/token&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-auth/rsa/publicKey&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-search/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/sso/login&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/sso/register&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/sso/getAuthCode&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/home/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/product/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/brand/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-admin/admin/login&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-admin/admin/register&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-admin/minio/upload&quot;</span><br><span class="hljs-attr">management:</span> <span class="hljs-comment">#开启SpringBoot Admin的监控</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>注意 ：</p><p><code>bootstrap.yml</code>（<code>bootstrap.properties</code>）先加载<br><code>application.yml</code>（<code>application.properties</code>）后加载<br><code>bootstrap.yml</code> 用于应用程序上下文的引导阶段。<br><code>bootstrap.yml</code> 由父Spring<code> ApplicationContext</code>加载。</p><h5 id="bootstrap-yaml"><a href="#bootstrap-yaml" class="headerlink" title="bootstrap.yaml"></a><strong><code>bootstrap.yaml</code></strong></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>  <span class="hljs-comment"># 配置的是dev环境</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">application:</span><br>  <span class="hljs-comment"># 配置应用名  用于微服务注册</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-gateway</span><br></code></pre></td></tr></table></figure><h5 id="bootstrap-dev-yaml-开发环境"><a href="#bootstrap-dev-yaml-开发环境" class="headerlink" title="bootstrap-dev.yaml(开发环境)"></a><strong><code>bootstrap-dev.yaml</code></strong>(开发环境)</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>    <span class="hljs-comment"># 配置服务发现</span><br>      <span class="hljs-attr">discovery:</span><br>      <span class="hljs-comment"># 配置nacos 地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>      <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 配置配置地址 </span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span>  <span class="hljs-comment"># 配置配置文件地址</span><br></code></pre></td></tr></table></figure><p>运行网关</p><p>因为Cookie 不能跨域访问， 配置<strong>全局的跨域器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;加载全局跨域配置&quot;</span>);<br>        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();<br>        <span class="hljs-comment">// 允许任何方式访问</span><br>        config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 允许任何来源的请求访问</span><br>        config.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 允许任何请求头进行访问</span><br>        config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 设置是否允许发送cookie信息</span><br>        config.setAllowCredentials(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 为Url配置映射路径</span><br>        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource(<span class="hljs-keyword">new</span> PathPatternParser());<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>        <span class="hljs-comment">// 返回重新定义的配置器</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsWebFilter(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、资源服务器"><a href="#2、资源服务器" class="headerlink" title="2、资源服务器"></a>2、资源服务器</h4><h5 id="资源配置服务"><a href="#资源配置服务" class="headerlink" title="资源配置服务"></a>资源配置服务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebFluxSecurity</span> <br><span class="hljs-comment">// 由于gateway使用的是Flux 协议</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">// 权限管理器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthorizationManager authorizationManager;<br><br>    <span class="hljs-comment">// 权限白名单</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IgnoreUrlsConfig ignoreUrlsConfig;<br><br>    <span class="hljs-comment">// Restful 访问被拒绝处理程序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestfulAccessDeniedHandler restfulAccessDeniedHandler;<br><br>    <span class="hljs-comment">// 休息站点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestAuthenticationEntryPoint restAuthenticationEntryPoint;<br><br>    <span class="hljs-comment">// 白名单路径访问时需要移除JWT请求头</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IgnoreUrlsRemoveJwtFilter ignoreUrlsRemoveJwtFilter;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 安全网页过滤链  这里涉及的是SpringSecurity Web Filter Chain  保护网关</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> http</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SecurityWebFilterChain <span class="hljs-title">springSecurityFilterChain</span><span class="hljs-params">(ServerHttpSecurity http)</span> </span>&#123;<br><br><br>        <span class="hljs-comment">// 加载 jwtAuthenticationConverter  将</span><br>        http.oauth2ResourceServer().jwt()<br>                .jwtAuthenticationConverter(jwtAuthenticationConverter());<br><br>        <span class="hljs-comment">//自定义处理JWT请求头过期或签名错误的结果</span><br>        <span class="hljs-comment">// 身份验证入口  如果没有token 则会直接提出</span><br>        http.oauth2ResourceServer().authenticationEntryPoint(restAuthenticationEntryPoint);<br><br>        <span class="hljs-comment">//对白名单路径，直接移除JWT请求头</span><br>        http.addFilterBefore(ignoreUrlsRemoveJwtFilter,SecurityWebFiltersOrder.AUTHENTICATION);<br><br>        http.authorizeExchange()<br>                <span class="hljs-comment">// 配置网关白名单  将全局网关配置的url获取出来进行匹配</span><br>                .pathMatchers(ArrayUtil.toArray(ignoreUrlsConfig.getUrls(),String.class)).permitAll()<br>                <span class="hljs-comment">// 剩余所有的请求都要走鉴权管理器</span><br>                .anyExchange().access(authorizationManager)<span class="hljs-comment">//鉴权管理器配置</span><br>                .and().exceptionHandling()<br>                <span class="hljs-comment">// 权限不足的接口 走这个返回  没有权限访问时 处理未授权</span><br>                .accessDeniedHandler(restfulAccessDeniedHandler)<br>                 <span class="hljs-comment">// 没有token是 走这个返回  处理未认证</span><br>                .authenticationEntryPoint(restAuthenticationEntryPoint)<br>                .and().csrf().disable();<br>        <span class="hljs-keyword">return</span> http.build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Jwt认证转换器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Converter&lt;Jwt, ? extends Mono&lt;? extends AbstractAuthenticationToken&gt;&gt; jwtAuthenticationConverter() &#123;<br><br>        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = <span class="hljs-keyword">new</span> JwtGrantedAuthoritiesConverter();<br><br>        <span class="hljs-comment">// 设置权限前缀</span><br>        jwtGrantedAuthoritiesConverter.setAuthorityPrefix(AuthConstant.AUTHORITY_PREFIX);<br><br>        <span class="hljs-comment">// 设置权限声明名词</span><br>        jwtGrantedAuthoritiesConverter.setAuthoritiesClaimName(AuthConstant.AUTHORITY_CLAIM_NAME);<br><br>        <span class="hljs-comment">//</span><br>        JwtAuthenticationConverter jwtAuthenticationConverter = <span class="hljs-keyword">new</span> JwtAuthenticationConverter();<br><br>        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在刚才的资源服务器中已经配置了 这个校验器  所以至于要交予spring托管</p><h5 id="权限校验器"><a href="#权限校验器" class="headerlink" title="权限校验器"></a>权限校验器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ReactiveAuthorizationManager</span>&lt;<span class="hljs-title">AuthorizationContext</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IgnoreUrlsConfig ignoreUrlsConfig;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验权限</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mono</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> authorizationContext</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;AuthorizationDecision&gt; <span class="hljs-title">check</span><span class="hljs-params">(Mono&lt;Authentication&gt; mono, AuthorizationContext authorizationContext)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过 request</span><br>        ServerHttpRequest request = authorizationContext.getExchange().getRequest();<br>        <span class="hljs-comment">// 获取uri</span><br>        URI uri = request.getURI();<br>        <span class="hljs-comment">// 创建路径匹配器</span><br>        PathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();<br>        <span class="hljs-comment">//白名单路径直接放行</span><br>        List&lt;String&gt; ignoreUrls = ignoreUrlsConfig.getUrls();<br>        <span class="hljs-keyword">for</span> (String ignoreUrl : ignoreUrls) &#123;<br>            <span class="hljs-keyword">if</span> (pathMatcher.match(ignoreUrl, uri.getPath())) &#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测请求方式</span><br>        <span class="hljs-keyword">if</span>(request.getMethod()==HttpMethod.OPTIONS)&#123;<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>));<br>        &#125;<br>        <span class="hljs-comment">//不同用户体系登录不允许互相访问</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取请求头中的token</span><br>            String token = request.getHeaders().getFirst(AuthConstant.JWT_TOKEN_HEADER);<br>            <span class="hljs-comment">// 检验请求中是否有token</span><br>            <span class="hljs-keyword">if</span>(StrUtil.isEmpty(token))&#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>            &#125;<br>            <span class="hljs-comment">// 去除token前缀</span><br>            String realToken =   token.replace(AuthConstant.JWT_TOKEN_PREFIX, <span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-comment">// 将realToken中的数据进行解密</span><br>            JWSObject jwsObject = JWSObject.parse(realToken);<br>            String userStr = jwsObject.getPayload().toString();<br>            <span class="hljs-comment">// 将token的数据封装到一个bean中</span><br>            UserDto userDto = JSONUtil.toBean(userStr, UserDto.class);<br><br>            <span class="hljs-comment">// 获取请求地址的url进行配对 失败返回false</span><br>            <span class="hljs-keyword">if</span> (AuthConstant.ADMIN_CLIENT_ID.equals(userDto.getClientId()) &amp;&amp;!pathMatcher.match(AuthConstant.ADMIN_URL_PATTERN, uri.getPath())) &#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(AuthConstant.PORTAL_CLIENT_ID.equals(userDto.getClientId()) &amp;&amp; pathMatcher.match(AuthConstant.ADMIN_URL_PATTERN, uri.getPath())) &#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>        &#125;<br>        <span class="hljs-comment">//非管理端路径直接放行  前端用户接口直接放行</span><br>        <span class="hljs-keyword">if</span> (!pathMatcher.match(AuthConstant.ADMIN_URL_PATTERN, uri.getPath())) &#123;<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>));<br>        &#125;<br>        <span class="hljs-comment">//管理端路径需校验权限</span><br>        <span class="hljs-comment">//将redis中的数据进行去除之后重新写入map集合中</span><br>        Map&lt;Object, Object&gt; resourceRolesMap =<br>                redisTemplate.opsForHash().entries(AuthConstant.RESOURCE_ROLES_MAP_KEY);<br>        <br>        Iterator&lt;Object&gt; iterator = resourceRolesMap.keySet().iterator();<br>        <br>        <span class="hljs-comment">// </span><br>        List&lt;String&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            String pattern = (String) iterator.next();<br>            <span class="hljs-comment">// 将uri的地址与redis中的地址进行匹配</span><br>            <span class="hljs-keyword">if</span> (pathMatcher.match(pattern, uri.getPath())) &#123;<br>                authorities.addAll(Convert.toList(String.class, resourceRolesMap.get(pattern)));<br>            &#125;<br>        &#125;<br>        authorities = authorities.stream().map(i -&gt; i = AuthConstant.AUTHORITY_PREFIX + i).collect(Collectors.toList());<br>        System.out.println(authorities);<br>        <span class="hljs-comment">//认证通过且角色匹配的用户可访问当前路径</span><br>        <span class="hljs-keyword">return</span> mono<br>                .filter(Authentication::isAuthenticated)<br>                .flatMapIterable(Authentication::getAuthorities)<br>                .map(GrantedAuthority::getAuthority)<br>                .any(authorities::contains)<br>                .map(AuthorizationDecision::<span class="hljs-keyword">new</span>)<br>                .defaultIfEmpty(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>start - 9.0</p><p>网关过滤器拦截请求执行顺序 </p><p>白名单拦截器 -&gt; 全局过滤器 -&gt; 安全验证管理器  -&gt; 跳转模块</p><h4 id="3、拦截器"><a href="#3、拦截器" class="headerlink" title="3、拦截器"></a>3、拦截器</h4><h5 id="白名单拦截器"><a href="#白名单拦截器" class="headerlink" title="白名单拦截器"></a>白名单拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IgnoreUrlsRemoveJwtFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebFilter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IgnoreUrlsConfig ignoreUrlsConfig;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, WebFilterChain chain)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;白名单拦截器&quot;</span>);<br>        <span class="hljs-comment">// 获取请求对象 </span><br>        ServerHttpRequest request = exchange.getRequest();<br>        <span class="hljs-comment">// 获取请求路径 </span><br>        URI uri = request.getURI();<br>        <span class="hljs-comment">// 创建路径匹配器</span><br>        PathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();<br>        <span class="hljs-comment">//白名单路径移除JWT请求头</span><br>        List&lt;String&gt; ignoreUrls = ignoreUrlsConfig.getUrls();<br>        <span class="hljs-comment">// 遍历该路径是否属于白名单 </span><br>        <span class="hljs-keyword">for</span> (String ignoreUrl : ignoreUrls) &#123;<br>            <span class="hljs-keyword">if</span> (pathMatcher.match(ignoreUrl, uri.getPath())) &#123;<br>                request = exchange .getRequest(). mutate(). header (AuthConstant.JWT_TOKEN_HEADER, <span class="hljs-string">&quot;&quot;</span>).build();<br>                <span class="hljs-comment">// 封装请求传递给 下一个请求</span><br>                exchange = exchange.mutate().request(request).build();<br>                <span class="hljs-keyword">return</span> chain.filter(exchange);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>    <span class="hljs-comment">//  创建日志对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AuthGlobalFilter.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过exchange 获取token对象</span><br>        String token = exchange. getRequest(). getHeaders(). getFirst(AuthConstant.JWT_TOKEN_HEADER);<br>        System.out.println(<span class="hljs-string">&quot;进入全局拦截器 &quot;</span>);<br>        LOGGER.warn(<span class="hljs-string">&quot;当前请求是否有jwt&quot;</span> + StrUtil.isEmpty(token));<br>        <span class="hljs-keyword">if</span> (StrUtil.isEmpty(token)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;token === null&quot;</span>);<br>            System.out.println(exchange);<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//从token中解析用户信息并设置到Header中去</span><br>            String realToken = token.replace(AuthConstant.JWT_TOKEN_PREFIX, <span class="hljs-string">&quot;&quot;</span>);<br>            JWSObject jwsObject = JWSObject.parse(realToken);<br>            String userStr = jwsObject.getPayload().toString();<br>            LOGGER.info(<span class="hljs-string">&quot;AuthGlobalFilter.filter() user:&#123;&#125;&quot;</span>,userStr);<br>            ServerHttpRequest request = exchange.getRequest().mutate().header(AuthConstant.USER_TOKEN_HEADER, userStr).build();<br>            exchange = exchange.mutate().request(request).build();<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *   过滤器执行顺序，数值越小，优先级越高</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、自定义返回结果"><a href="#4、自定义返回结果" class="headerlink" title="4、自定义返回结果"></a>4、自定义返回结果</h4><h5 id="校验失败返回结果"><a href="#校验失败返回结果" class="headerlink" title="校验失败返回结果"></a>校验失败返回结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestfulAccessDeniedHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerAccessDeniedHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">handle</span><span class="hljs-params">(ServerWebExchange exchange, AccessDeniedException denied)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;权限不对&quot;</span>);<br><br>        ServerHttpResponse response = exchange.getResponse();<br><br>        response.setStatusCode(HttpStatus.OK);<br><br>        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);<br><br>        response.getHeaders().set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br><br>        response.getHeaders().set(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br><br>        String body= JSONUtil.toJsonStr(CommonResult.forbidden(denied.getMessage()));<br><br>        DataBuffer buffer =  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>)));<br><br>        System.out.println(Mono.just(buffer));<br><br>        <span class="hljs-keyword">return</span> response.writeWith(Mono.just(buffer));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5><h5 id="没有token或者token过期时-异常返回结果"><a href="#没有token或者token过期时-异常返回结果" class="headerlink" title="没有token或者token过期时   异常返回结果"></a>没有token或者token过期时   <strong>异常返回结果</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestAuthenticationEntryPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerAuthenticationEntryPoint</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">commence</span><span class="hljs-params">(ServerWebExchange exchange, AuthenticationException e)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;因为没有token直接返回&quot;</span>);<br><br>        ServerHttpResponse response = exchange.getResponse();<br><br>        response.setStatusCode(HttpStatus.OK);<br><br>        <span class="hljs-comment">// 指定响应头类型</span><br>        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);<br><br>        <span class="hljs-comment">// 添加跨域支持</span><br>        response.getHeaders().set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br><br>        <span class="hljs-comment">// 是否允许缓存 控制</span><br>        response.getHeaders().set(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br><br>        <span class="hljs-comment">// 异常message</span><br>        String body= JSONUtil.toJsonStr(CommonResult.unauthorized(e.getMessage()));<br><br>        DataBuffer buffer =  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>)));<br><br>        <span class="hljs-keyword">return</span> response.writeWith(Mono.just(buffer));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Auth模块"><a href="#Auth模块" class="headerlink" title="Auth模块"></a><code>Auth</code>模块</h3><p>模块介绍 ： 该模块用于认证和发送token字符串  </p><h4 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h4><h5 id="application-yaml-1"><a href="#application-yaml-1" class="headerlink" title="application.yaml"></a><code>application.yaml</code></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8401</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">okhttp:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#服务请求连接超时时间（毫秒）</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#服务请求处理超时时间（毫秒）</span><br></code></pre></td></tr></table></figure><h5 id="bootstrap-yaml-1"><a href="#bootstrap-yaml-1" class="headerlink" title="bootstrap.yaml"></a><code>bootstrap.yaml</code></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>  <span class="hljs-comment"># 使用dev环境</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">application:</span><br>  <span class="hljs-comment"># 配置应用名称</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-auth</span><br></code></pre></td></tr></table></figure><h5 id="bootstrap-dev-yaml"><a href="#bootstrap-dev-yaml" class="headerlink" title="bootstrap-dev.yaml"></a><code>bootstrap-dev.yaml</code></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>      <span class="hljs-comment"># 服务发现地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>      <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 服务配置地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br><span class="hljs-comment"># 配置日志级别</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h4 id="2、配置类"><a href="#2、配置类" class="headerlink" title="2、配置类"></a>2、配置类</h4><h5 id="配置授权服务器"><a href="#配置授权服务器" class="headerlink" title="配置授权服务器"></a>配置授权服务器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 开启授权服务器</span><br><span class="hljs-meta">@EnableAuthorizationServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Oauth2ServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">// 密码加密方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordEncoder passwordEncoder;<br><br>    <span class="hljs-comment">// 自定义登录逻辑</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserServiceImpl userDetailsService;<br><br>    <span class="hljs-comment">// 身份认证转换器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthenticationManager authenticationManager;<br><br>    <span class="hljs-comment">// jwt内容增强器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTokenEnhancer jwtTokenEnhancer;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        clients.inMemory()<br>                <span class="hljs-comment">// 配置clientId</span><br>                .withClient(<span class="hljs-string">&quot;admin-app&quot;</span>)<br>                <span class="hljs-comment">// 设置密码</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123456&quot;</span>))<br>                <span class="hljs-comment">// 配置作用域</span><br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br>                <span class="hljs-comment">// 授权</span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>)<br>                <span class="hljs-comment">// 访问令牌的有效期</span><br>                .accessTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>)<br>                <span class="hljs-comment">// 刷新令牌的有效期</span><br>                .refreshTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">7</span>)<br>                .and()<br>                 <span class="hljs-comment">// 配置ClientId</span><br>                .withClient(<span class="hljs-string">&quot;portal-app&quot;</span>)<br>                <span class="hljs-comment">// 配置密钥</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123456&quot;</span>))<br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br> <span class="hljs-comment">// 设置密码模式  刷新token 如果不设置refresh_token 是不会自动刷新token的</span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>)<br>                .accessTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>)<br>                .refreshTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">7</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  密码模式需要这个配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 配置token增强器</span><br>        TokenEnhancerChain enhancerChain = <span class="hljs-keyword">new</span> TokenEnhancerChain();<br><br>        List&lt;TokenEnhancer&gt; delegates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        delegates.add(jwtTokenEnhancer);<br><br>        delegates.add(accessTokenConverter());<br><br>        <span class="hljs-comment">//配置JWT的内容增强器</span><br>        enhancerChain.setTokenEnhancers(delegates);<br><br>        endpoints.authenticationManager(authenticationManager)<br>                <span class="hljs-comment">//配置加载用户信息的服务</span><br>                .userDetailsService(userDetailsService)<br>                <span class="hljs-comment">// 配置Jwt Token 和 Access Token 转换</span><br>                .accessTokenConverter(accessTokenConverter())<br>                <span class="hljs-comment">// token 存储策略</span><br>                .tokenEnhancer(enhancerChain);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取密钥需要身份认证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> security</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        security.allowFormAuthenticationForClients();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-comment">// 令牌转换器  </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">accessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;<br><br>        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();<br>        <span class="hljs-comment">// 将密钥的的值放入token中</span><br>        jwtAccessTokenConverter.setKeyPair(keyPair());<br>        <span class="hljs-keyword">return</span> jwtAccessTokenConverter;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyPair <span class="hljs-title">keyPair</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//从classpath下的证书中获取秘钥对</span><br>        <span class="hljs-comment">// 创建密钥  存入密钥文件</span><br>        KeyStoreKeyFactory keyStoreKeyFactory = <span class="hljs-keyword">new</span> KeyStoreKeyFactory(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;jwt.jks&quot;</span>), <span class="hljs-string">&quot;123456&quot;</span>.toCharArray());<br>        <span class="hljs-keyword">return</span> keyStoreKeyFactory.getKeyPair(<span class="hljs-string">&quot;jwt&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>.toCharArray());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>SecurityConfig</p><h5 id="配置-SprignSecurity安全"><a href="#配置-SprignSecurity安全" class="headerlink" title="配置 SprignSecurity安全"></a>配置 <code>SprignSecurity</code>安全</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-comment">// 开启web安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 配置安全</span><br>        http.authorizeRequests()<br>                .requestMatchers (EndpointRequest.toAnyEndpoint())  .permitAll()<br>                <span class="hljs-comment">// 释放公钥地址和api-docs地址</span><br>                .antMatchers(<span class="hljs-string">&quot;/rsa/publicKey&quot;</span>).permitAll()<br>                .antMatchers(<span class="hljs-string">&quot;/v2/api-docs&quot;</span>).permitAll()<br>                .anyRequest().authenticated();  <span class="hljs-comment">// 所有请求认证</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 身份认证器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManagerBean();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密器  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置token内容增强器"><a href="#配置token内容增强器" class="headerlink" title="配置token内容增强器"></a>配置token内容增强器</h5><blockquote><p>为什么需要这个 ？？ </p><p><code>SpringSecurity OAuth2</code> 生成的token 中不能添加字段 所以使用token内容增强器</p><p>增加token信息  多携带信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTokenEnhancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenEnhancer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;<br><br>        SecurityUser securityUser = (SecurityUser) authentication.getPrincipal();<br><br>        Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">//把用户ID设置到JWT中</span><br>        info.put(<span class="hljs-string">&quot;id&quot;</span>, securityUser.getId());<br><br>        info.put(<span class="hljs-string">&quot;client_id&quot;</span>,securityUser.getClientId());<br><br>        <span class="hljs-comment">// OAuth2AccessToken 这个是接口  所以只能强转</span><br>        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);<br><br>        <span class="hljs-keyword">return</span> accessToken;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定义消息常量"><a href="#定义消息常量" class="headerlink" title="定义消息常量"></a>定义消息常量</h5><p>便于统一定制 消息返回提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConstant</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOGIN_SUCCESS = <span class="hljs-string">&quot;登录成功!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USERNAME_PASSWORD_ERROR = <span class="hljs-string">&quot;用户名或密码错误!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CREDENTIALS_EXPIRED = <span class="hljs-string">&quot;该账户的登录凭证已过期，请重新登录!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ACCOUNT_DISABLED = <span class="hljs-string">&quot;该账户已被禁用，请联系管理员!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ACCOUNT_LOCKED = <span class="hljs-string">&quot;该账号已被锁定，请联系管理员!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ACCOUNT_EXPIRED = <span class="hljs-string">&quot;该账号已过期，请联系管理员!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PERMISSION_DENIED = <span class="hljs-string">&quot;没有访问权限，请联系管理员!&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h4><h5 id="1、自定义获取token接口"><a href="#1、自定义获取token接口" class="headerlink" title="1、自定义获取token接口"></a>1、自定义获取token接口</h5><p>通过需要安全验证的接口， 通过远程调用这个接口进行验证返回token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Api(tags = &quot;AuthController&quot;, description = &quot;认证中心登录认证&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/oauth&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TokenEndpoint tokenEndpoint;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;Oauth2获取token&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParams(&#123;</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;grant_type&quot;, value = &quot;授权模式&quot;, required = true),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;client_id&quot;, value = &quot;Oauth2客户端ID&quot;, required = true),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;client_secret&quot;, value = &quot;Oauth2客户端秘钥&quot;, required = true),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;refresh_token&quot;, value = &quot;刷新token&quot;),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;username&quot;, value = &quot;登录用户名&quot;),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;password&quot;, value = &quot;登录密码&quot;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/token&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Oauth2TokenDto&gt; <span class="hljs-title">postAccessToken</span><span class="hljs-params">(<span class="hljs-meta">@ApiIgnore</span> Principal principal, <span class="hljs-meta">@ApiIgnore</span> <span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; parameters)</span> <span class="hljs-keyword">throws</span> HttpRequestMethodNotSupportedException </span>&#123;<br><br>        <span class="hljs-comment">// 构建token</span><br>        OAuth2AccessToken oAuth2AccessToken = tokenEndpoint.postAccessToken(principal, parameters).getBody();<br><br>        Oauth2TokenDto oauth2TokenDto = Oauth2TokenDto.builder()<br>                .token(oAuth2AccessToken.getValue())<br>                .refreshToken(oAuth2AccessToken.getRefreshToken().getValue())<br>                .expiresIn(oAuth2AccessToken.getExpiresIn())<br>                .tokenHead(AuthConstant.JWT_TOKEN_PREFIX).build();<br><br>        <span class="hljs-keyword">return</span> CommonResult.success(oauth2TokenDto);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、接口返回参数类"><a href="#2、接口返回参数类" class="headerlink" title="2、接口返回参数类"></a>2、接口返回参数类</h5><h6 id="定义-Oauth2Token返回参数"><a href="#定义-Oauth2Token返回参数" class="headerlink" title="定义 Oauth2Token返回参数"></a>定义 <code>Oauth2Token</code>返回参数</h6><p>便于返回统一格式Token</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Data</span><br><span class="hljs-variable">@EqualsAndHashCode</span>(callSuper = false)<br><span class="hljs-variable">@Builder</span><br>public class Oauth2TokenDto &#123;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;访问令牌&quot;</span>)<br>    private String token;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;刷令牌&quot;</span>)<br>    private String refreshToken;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;访问令牌头前缀&quot;</span>)<br>    private String tokenHead;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;有效时间（秒）&quot;</span>)<br>    private int expiresIn;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、获取公钥"><a href="#3、获取公钥" class="headerlink" title="3、获取公钥"></a>3、获取公钥</h5><p>通过接口获取公钥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyPairController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KeyPair keyPair;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/rsa/publicKey&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 读取公钥  转换成Json 返回</span><br>        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();<br>        RSAKey key = <span class="hljs-keyword">new</span> RSAKey.Builder(publicKey).build();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JWKSet(key).toJSONObject();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、自定义登录逻辑"><a href="#4、自定义登录逻辑" class="headerlink" title="4、自定义登录逻辑"></a>4、自定义登录逻辑</h4><h5 id="1、UserServiceImpl"><a href="#1、UserServiceImpl" class="headerlink" title="1、UserServiceImpl"></a>1、<code>UserServiceImpl</code></h5><p>通过实现<code>UserDetailService</code>进行自定义<code>sercurity</code>的登录逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-comment">// 通过远程接口进行访问</span><br>    <span class="hljs-keyword">private</span> UmsAdminService adminService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-comment">// 通过远程接口进行调用</span><br>    <span class="hljs-keyword">private</span> UmsMemberService memberService;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> HttpServletRequest request;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br><br>        <span class="hljs-comment">// 获取服务端id</span><br>        String clientId = request.getParameter(<span class="hljs-string">&quot;client_id&quot;</span>);<br>        <span class="hljs-comment">// 统一封装参数</span><br>        UserDto userDto;<br>        <span class="hljs-comment">// 检验是不是后台客户端</span><br>        <span class="hljs-keyword">if</span>(AuthConstant.ADMIN_CLIENT_ID.equals(clientId))&#123;<br>            <span class="hljs-comment">// 调用后台的接口查询</span><br>            userDto = adminService.loadUserByUsername(username);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 调用前台的接口查询</span><br>            userDto = memberService.loadUserByUsername(username);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userDto==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 表示用户名和密码错误</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(MessageConstant.USERNAME_PASSWORD_ERROR);<br>        &#125;<br>        <span class="hljs-comment">// 将clientId 加入参数中</span><br>        userDto.setClientId(clientId);<br>        <span class="hljs-comment">// 添加</span><br>        SecurityUser securityUser = <span class="hljs-keyword">new</span> SecurityUser(userDto);<br>        <span class="hljs-comment">// 检验账号是否已经开启</span><br>        <span class="hljs-keyword">if</span> (!securityUser.isEnabled()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledException(MessageConstant.ACCOUNT_DISABLED);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!securityUser.isAccountNonLocked()) &#123;    <span class="hljs-comment">// 检验是否被锁定</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LockedException(MessageConstant.ACCOUNT_LOCKED);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!securityUser.isAccountNonExpired()) &#123;   <span class="hljs-comment">// 检验账号是否过期</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccountExpiredException(MessageConstant.ACCOUNT_EXPIRED);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!securityUser.isCredentialsNonExpired()) &#123;  <span class="hljs-comment">// 检验账号凭证是否已经过期</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CredentialsExpiredException(MessageConstant.CREDENTIALS_EXPIRED);<br>        &#125;<br>        <span class="hljs-keyword">return</span> securityUser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、SecurityUser"><a href="#2、SecurityUser" class="headerlink" title="2、SecurityUser"></a><code>2、SecurityUser</code></h5><p>使用与参数列表  <code>SecurityUser</code> 和 <code>UserServiceImpl</code>是security安全的俩个核心</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityUser</span> <span class="hljs-title">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> username;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> password;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> enabled;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录客户端ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> clientId;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 权限数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Collection&lt;SimpleGrantedAuthority&gt; authorities;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">SecurityUser</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">SecurityUser</span>(<span class="hljs-params">UserDto userDto</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setId(userDto.getId());<br>        <span class="hljs-built_in">this</span>.setUsername(userDto.getUsername());<br>        <span class="hljs-built_in">this</span>.setPassword(userDto.getPassword());<br>        <span class="hljs-built_in">this</span>.setEnabled(userDto.getStatus() == <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.setClientId(userDto.getClientId());<br>        <span class="hljs-keyword">if</span> (userDto.getRoles() != <span class="hljs-literal">null</span>) &#123;<br>            authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            userDto.getRoles().forEach(item -&gt; authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(item)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Collection&lt;? <span class="hljs-keyword">extends</span> GrantedAuthority&gt; <span class="hljs-function"><span class="hljs-title">getAuthorities</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.authorities;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getPassword</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.password;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getUsername</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.username;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isAccountNonExpired</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isAccountNonLocked</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isCredentialsNonExpired</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isEnabled</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.enabled;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>总结 ： <code>Auth</code>认证服务 通过暴露<code>/oauth/token</code>接口，让需要认真的接口远程调用进行认证  </p><h3 id="Admin模块"><a href="#Admin模块" class="headerlink" title="Admin模块"></a><code>Admin</code>模块</h3><p><code>admin</code>模块</p><h4 id="订单管理"><a href="#订单管理" class="headerlink" title="订单管理"></a>订单管理</h4><p>暂时还没到这个层面</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><ul><li><p>授权<code>admin</code>  没有修改最后登录</p></li><li><p>授权了管理员或者是别的账号    角色用户数没有增加 </p></li><li><p>不管是增加和删除都没有增加数量    </p></li><li><p>删除和授权  角色关系映射和角色表应该改变 </p><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210630084404241.png" alt="image-20210630084404241"></p></li></ul><p>删除问题已经解决</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>查看三张表的关系</p><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210630104835298.png" alt="image-20210630104835298"></p><p>接口定义  加上事务  不然出现异常用户不会回滚 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    <span class="hljs-comment">// 删除账号</span><br>    <span class="hljs-keyword">int</span> count = adminMapper.deleteByPrimaryKey(id);<br>    System.out.println(id);<br>    <span class="hljs-comment">// 获取关系映射id</span><br>    UmsAdminRoleRelation roleRelation = adminRoleRelationDao.getRoleIdByAdminId(id);<br>    System.out.println(roleRelation);<br>    <span class="hljs-comment">// 删除关系映射</span><br>    <span class="hljs-keyword">int</span> i = adminRoleRelationMapper .deleteByPrimaryKey (roleRelation.getId()); <br>    <span class="hljs-comment">// 删除role对应的角色数量</span><br>    UmsRole umsRole = roleService.selectRoleById(roleRelation.getRoleId());<br>    umsRole.setAdminCount(umsRole.getAdminCount()-<span class="hljs-number">1</span>);<br>    roleService.update(roleRelation.getRoleId() , umsRole);<br>    <span class="hljs-comment">// 删除缓存</span><br>    adminCacheService.delAdmin(id);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出登录修改最后登录时间 </p><p>添加中角色数量没有增加   需要进行修改 </p><h4 id="会员管理"><a href="#会员管理" class="headerlink" title="会员管理"></a>会员管理</h4><h5 id="对接会员模块"><a href="#对接会员模块" class="headerlink" title="对接会员模块"></a>对接会员模块</h5><p>如图可知，现在开源项目 ， 会员管理并未完成， 对接会员管理</p><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703101321207.png" alt="image-20210703101321207"></p><h5 id="修改后端"><a href="#修改后端" class="headerlink" title="修改后端"></a>修改后端</h5><ol><li><p>创建菜单列表  对应的数据库为 <code>ums_menu</code>这个实现的接口为  <code>/menu/**</code></p></li><li><p>使用改接口添加会员字段  （对菜单表进行insert操作）</p></li><li><p>创建子级目录 会员列表和会员等级列表    &lt; 数据库设计如下</p><ol><li><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703111656921.png" alt="image-20210703111656921"></li></ol></li><li><p>在资源列表中将会员列表的接口 和 会员等级的接口添加进去资源列表，要不然前端无法调用</p></li><li><p>添加之后设置等级 ，缓存等级表是<code>ums_resource_category</code>  这里有对应的模块用于对模块进行分类显示</p></li><li><p>其中这个表的id要与resource资源路径的categoryId一致</p><ol><li><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703112539225.png" alt="image-20210703112539225"></li></ol></li></ol><h5 id="修改前端"><a href="#修改前端" class="headerlink" title="修改前端"></a>修改前端</h5><h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><blockquote><p>前端采用的是vue + elementUi </p><p>Vue对组件的路径管理  采用的是路由的方式 </p><p>所以得先修改路由，进行展示 </p></blockquote><p>先查看路由</p><p>修改路由注意事项</p><p> <img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703125358063.png" alt="image-20210703125358063"></p><blockquote><p>这里是用全局路由数组和请求过来的权限数组进行匹配  如果有不匹配的则不进行显示</p></blockquote><p>查看路由匹配算法 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//判断是否有权限访问该菜单</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPermission</span>(<span class="hljs-params">menus, route</span>) </span>&#123;<br>   <span class="hljs-comment">// 将路由名字进行判断</span><br>  <span class="hljs-keyword">if</span> (route.name) &#123;<br>      <span class="hljs-comment">// 通过路由名字 和 menus 进行匹配 查看是否匹配</span><br>    <span class="hljs-keyword">let</span> currMenu = getMenu(route.name, menus);<br>    <span class="hljs-keyword">if</span> (currMenu!=<span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//设置菜单的标题、图标和可见性</span><br>      <span class="hljs-keyword">if</span> (currMenu.title != <span class="hljs-literal">null</span> &amp;&amp; currMenu.title !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        route.meta.title = currMenu.title;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (currMenu.icon != <span class="hljs-literal">null</span> &amp;&amp; currMenu.title !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        route.meta.icon = currMenu.icon;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(currMenu.hidden!=<span class="hljs-literal">null</span>)&#123;<br>        route.hidden = currMenu.hidden !== <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (currMenu.sort != <span class="hljs-literal">null</span> &amp;&amp; currMenu.sort !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        route.sort = currMenu.sort;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      route.sort = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (route.hidden !== <span class="hljs-literal">undefined</span> &amp;&amp; route.hidden === <span class="hljs-literal">true</span>) &#123;<br>          <span class="hljs-comment">// 不会显示</span><br>        route.sort=-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以这里的路由命和meanu菜单的name要保持一致</p><p>增加对会员列表的增删查改 </p><p>完成 。。。</p><p>增加会员等级列表 </p><p>完成</p><p>增加会员成长值 </p><p>完成</p><p>增加会员登录日志</p><p>完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaJvm和JMM</title>
    <link href="/2021/06/16/JavaJVM%E5%92%8CJMM/"/>
    <url>/2021/06/16/JavaJVM%E5%92%8CJMM/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>JVM(Java虚拟机的运行时区域)  和 JMM(Java内存模型) 有什么关系 </p><blockquote><p>JMM 和  Java并发编程有关  </p></blockquote><h2 id="JMM-是什么"><a href="#JMM-是什么" class="headerlink" title="JMM 是什么"></a>JMM 是什么</h2><ul><li>JMM是一种符合内存规范的, 屏蔽了各种硬件和操作系统的访问差异的, 保证了Java程序在各种平台对内存访问都能保证效果一致的机制及规范</li><li>Java内存模型规定了<strong>所有的变量</strong>都存储在主内存中, 每条线程还有自己的工作内存, 线程的工作内存中保存了该线程中是<strong>用到的变量的主内存副本拷贝</strong>, 线程对变量的所有操作都必须在工作内存中进行, 不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量, 线程间变量的传递均需要自己的共工作内存和主存之间进行数据同步进行</li><li>JMM就作用于工作内存和主内存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</li></ul><h2 id="JMM-的主要作用-以及实现方式-解决了那些问题"><a href="#JMM-的主要作用-以及实现方式-解决了那些问题" class="headerlink" title="JMM 的主要作用  以及实现方式 解决了那些问题"></a>JMM 的主要作用  以及实现方式 解决了那些问题</h2><p><img src="/2021/06/16/JavaJVM%E5%92%8CJMM/image-20210616092723877.png" alt="image-20210616092723877"></p><p>JMM是一种规范，目的是<strong>解决</strong>由于多线程通过共享内存进行通信时，储存在本地内存的<strong>数据不一致</strong></p><p>、编译器会对<strong>代码指令重排序</strong>、处理器会对<strong>代码乱序执行</strong>等带来的问题</p><p>原子性 ：</p><blockquote><p><em>即一个操作或者多个操作</em> <em>要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</em></p></blockquote><p>​        Java中可以使用<code>synchronized </code>来保证方法和代码内的操作是原子性的 </p><p>​        自Jdk1.5之后提供了一个<code>Lock</code>(使用的是实现类)包 可以保证方法和代码内的操作都是原子性的</p><p> 而且俩者都是可重入锁 ？ </p><blockquote><p>解答文档<a href="https://mp.weixin.qq.com/s/R7Fu1HDW3N1pl1c9VJ2T5Q">https://mp.weixin.qq.com/s/R7Fu1HDW3N1pl1c9VJ2T5Q</a></p></blockquote><p>有序性 ： 即程序执行的顺序按照代码的先后顺序执行。</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><p>可见性：</p><blockquote><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h2 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h2><p>JVM类加载过程？？</p><blockquote><p>类加载过程里面包含加载 验证 准备  解析  初始化这五个步骤，其中加载  验证  准备  初始化这四个阶段的顺序是确定的，而 解析阶段不一样，它在某个情况下</p></blockquote><p>类加载阶段所做的事 </p><p>浅谈JVM内存模型 </p><p>JVM垃圾回收算法 </p><p>JVM垃圾回收器</p>]]></content>
    
    
    
    <tags>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSeRelearn</title>
    <link href="/2021/06/15/JavaSeRelearn/"/>
    <url>/2021/06/15/JavaSeRelearn/</url>
    
    <content type="html"><![CDATA[<h1 id="javaSe-复习"><a href="#javaSe-复习" class="headerlink" title="javaSe  复习"></a>javaSe  复习</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java 数据类型的取值范围 </p><blockquote><p>byte 字节型 -128～127 -2^7～2^7-1 1字节</p><p>short 短整型 -32768～32767 -2^15～2^15-12字节</p><p>int 整型 -2147483648～2147483647 -2^31～2^31-1 4字节</p><p>long 长整型 -9223372036854775808～9223372036854775807 -2^63～2^-1 8字节</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> i = <span class="hljs-number">127</span>;<br><span class="hljs-keyword">long</span> s = <span class="hljs-number">1000L</span>;<br><span class="hljs-keyword">long</span> l = s - i;<br>System.out.println(l);<br></code></pre></td></tr></table></figure><blockquote><p>当容量小的数据类型与容量大的数据类型的变量做运算时, 结果会自动提升为容量大的数据类型</p></blockquote><p>位运算符 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">【特别说明的】<br>1. 位运算符操作的都是整型的数据<br>2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2<br>&gt;&gt; :在一定范围内，每向右移1位，相当于 / 2<br></code></pre></td></tr></table></figure><p>流程控制 </p><p>switch 语法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>执行语句<span class="hljs-number">1</span>;<br><span class="hljs-comment">//break;</span><br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>执行语句<span class="hljs-number">2</span>;<br><span class="hljs-comment">//break;</span><br>...<br><span class="hljs-keyword">default</span>:<br>执行语句n;<br><span class="hljs-comment">//break;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组数据类型 </p><p>数组的特点</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 1数组是序排列的<br><span class="hljs-bullet">*</span> 2数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型<br><span class="hljs-bullet">*</span> 3创建数组对象会在内存中开辟一整块连续的空间<br><span class="hljs-bullet">*</span> 4数组的长度一旦确定，就不能修改。<br></code></pre></td></tr></table></figure><p>数组的创建方式</p><ol><li><p>直接声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[]  array;   <br></code></pre></td></tr></table></figure></li><li><p>静态初始化： 数组初始化和数组元素赋值同时进行 </p> <figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">int[]<span class="hljs-built_in"> array </span>= &#123;1,2 ,3, 4&#125;;<br></code></pre></td></tr></table></figure></li><li><p>动态初始化：数组的初始化和数组元素的赋值操作分开进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明数组时 指定长度 默认数组的所有元素初始化为null </span><br>String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure></li></ol><p>‘ Arrays 工具类的使用’</p><blockquote><p>boolean equals(int[] a,int[] b)  :判断两个数组是否相等。<br>String toString(int[] a)  :输出数组信息。<br>void fill(int[] a,int val)  :将指定值填充到数组之中<br>void sort(int[] a)  :对数组进行排序<br>int binarySearch(int[] a,int key) :  从数组中查找key    </p></blockquote><h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><p>理解”<strong>万事万物皆对象</strong>“  </p><p>1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构</p><ul><li><blockquote><p>Scanner,String等</p></blockquote></li><li><blockquote><p>文件：File</p></blockquote></li><li><blockquote><p>网络资源：URL</p></blockquote></li></ul><p>2.涉及到Java语言与前端<strong>Html</strong>、后端的数据库交互时<strong>，前后端的结构在Java层面交互时</strong>，都体现为<strong>类、对象</strong>。</p><p>类的属性和局部变量的不同以及差异</p><blockquote><p>对比：属性  vs  局部变量</p><p>1.相同点：</p><ul><li><pre><code>    1.1  定义变量的格式：数据类型  变量名 = 变量值</code></pre></li><li><pre><code>    1.2 先声明，后使用</code></pre></li><li><pre><code>    1.3 变量都其对应的作用域 </code></pre></li></ul><p>2.不同点：<br>       2.1 在类中声明的位置的不同</p><ul><li><pre><code>    属性：直接定义在类的一对&#123;&#125;内</code></pre></li><li><pre><code>    局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</code></pre></li></ul><p> 2.2 关于权限修饰符的不同</p><ul><li><pre><code>    属性：可以在声明属性时，指明其权限，使用权限修饰符。</code></pre></li><li><pre><code>    常用的权限修饰符：private、public、缺省、protected  ---&gt;封装性</code></pre></li><li><pre><code>    目前，大家声明属性时，都使用缺省就可以了。</code></pre></li><li><pre><code>    局部变量：不可以使用权限修饰符。</code></pre></li></ul><p> 2.3 默认初始化值的情况：</p><ul><li><pre><code>    属性：类的属性，根据其类型，都默认初始化值。</code></pre></li><li><pre><code>    整型（byte、short、int、long：0）</code></pre></li><li><pre><code>    浮点型（float、double：0.0）</code></pre></li><li><pre><code>    字符型（char：0  （或&#39;\u0000&#39;））</code></pre></li><li><pre><code>    布尔型（boolean：false）</code></pre></li></ul><ul><li><pre><code>        引用数据类型（类、数组、接口：null）</code></pre></li><li><pre><code>        局部变量：没默认初始化值。</code></pre></li><li><pre><code>        意味着，我们在调用局部变量之前，一定要显式赋值。</code></pre></li><li><pre><code>        特别地：形参在调用时，我们赋值即可。</code></pre></li></ul><p> 2.4 在内存中加载的位置：</p><ul><li><pre><code>    属性：加载到**堆空间**中   （非static）</code></pre></li><li><pre><code>    局部变量：加载到操作数栈</code></pre></li></ul></blockquote><h4 id="为什么-需要封装"><a href="#为什么-需要封装" class="headerlink" title="为什么 需要封装"></a>为什么 需要封装</h4><blockquote><p>我们程序设计追求“高内聚，低耦合”。</p><p>高内聚 ：<strong>类的内部数据操作细节自己完成，不允许外部干涉；</strong><br>低耦合 ：<strong>仅对外暴露少量的方法用于使用。</strong></p></blockquote><p>封装概念以及思想</p><blockquote><p>隐藏对象内部的复杂性，只对外公开简单的接口。</p><p>便于外界调用，从而提高系统的可扩展性、可维护性。</p><p>通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p></blockquote><p>封装的具体的代码实现</p><ul><li><blockquote><p>将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p></blockquote></li><li><blockquote><p>不对外暴露的私有的方法</p></blockquote></li><li><blockquote><p>单例模式（将构造器私有化）****</p></blockquote></li><li><blockquote><p>如果不希望类在包外被调用，可以将类设置为缺省的。</p></blockquote></li></ul><p>java的权限修饰符 </p><blockquote><p>private &lt;  缺省 &lt; protected &lt; public</p></blockquote><p>四个属性修饰的范围 </p><blockquote><p>4种权限都可以用来修饰<strong>类的内部结构</strong>：<strong>属性、方法、构造器、内部类</strong></p></blockquote><blockquote><p>修饰类的话，只能使用：<strong>缺省、public</strong></p></blockquote><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote><p>2.使用说明：</p><ul><li>1.如果没显式的定义类的构造器的话，则系统默认提供一个<strong>空参的构造器</strong></li><li>2.定义构造器的格式：<strong>权限修饰符  类名(形参列表){}</strong></li><li>3.一个类中定义的多个构造器，<strong>彼此构成重载</strong></li><li>4.一旦我们显式的定义了类的构造器之后，<strong>系统就不再提供默认的空参构造器</strong></li><li>5.一个类中，至少<strong>会有一个构造器。</strong></li></ul></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>// 面向对象三大特性  ：  封装  继承  多态 </p><ul><li>不使用继承前的代码 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> Integer age;<br>    <span class="hljs-keyword">public</span> Date   birthDate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(name + age + birthDate);<br>        <span class="hljs-keyword">return</span>  name + age + birthDate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生类 class Student&#123;    public String name;    public Integer age;    public Date   birthDate;    public String schoolName;    public String  getInfo()&#123;        System.out.println(name + age + birthDate);        return  name + age + birthDate;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>使用继承之后的代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明父类class People&#123;    public String name;    public Integer age;    public Date   birthDate;    public String  getInfo()&#123;        System.out.println(name + age + birthDate);        return  name + age + birthDate;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生类class Student extends People&#123;    public String schoolName;&#125;</span><br></code></pre></td></tr></table></figure><p>通过上述的代码：  ——&gt; 得出的结论为 ：   继承可以减少代码冗余     提高可复用性</p></li></ul><p>  作用：</p><blockquote><p>继承的出现减少了代码冗余   提高了代码的复用性。<br>继承的出现，更有利于功能的扩展。<br>继承 的出现让类与类之间产生了 关系 ，提供了多态的 前提 。</p><blockquote><p>注意：<strong>不要 仅为了获取其他类中某个功能而去继承</strong></p></blockquote></blockquote><p>  为什么要有继承 ？？？</p><blockquote><p>多个类中存在<strong>相同属性和行为</strong>时，将这些内容抽取到单独一个类中，<br>那么<strong>多个类无需再定义这些属性和行为</strong>，只要继承那个类即可。</p></blockquote><p>​    </p><p>子类是不是能操作父类的全部的数据呢 ？？ </p><blockquote><p>不是， 子类不能直接访问父类私有的属性以及方法</p></blockquote><p>java是不是属于多继承呢 ？？ </p><blockquote><p>java 是单继承   一个子类只能有一个父类    一个父类可以有多个子类</p></blockquote><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>子类重写父类的定义：：</p><blockquote><p>在子类中可以根据需要对从<strong>父类中继承来的方法进行改造</strong> 也称<br>为方法 的 重置、覆盖 。在程序执行时，<strong>子类的方法将覆盖父类的方法。</strong>  </p></blockquote><p>注意事项：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 子类与父类中同名同参数的方法必须同时声明 为  非static的 (即为重写)，或者同时声明 为static 的不是重写 。因为 static方法是属于类的，子类无法覆盖父类的方法。</span><br></code></pre></td></tr></table></figure><p>要求</p><ol><li><p>子类重写的方法 必须和父类被重写的方法 具有<strong>相同的 方法名称、 参数 列表</strong></p></li><li><p>子类<strong>重写的方法的返回值类型</strong>不能大于   <strong>父类被重写的方法的返回值类型</strong></p></li><li><p>子类<strong>重写的方法使用的访问权限</strong> 不能小于 父类被重写的方法的访问权限</p><ol><li><blockquote><p>子类<strong>不能重写父类中声明为 private 权限的方法</strong></p></blockquote></li></ol></li><li><p>子类<strong>方法抛出的异常</strong>不能大于<strong>父类被重写方法的异常</strong></p></li></ol><p>问题： 重写和重载的区别 :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 方法的重写Overriding和重载Overloading是Java多态性的不同表现。2. 重写Overriding是父类与子类之间多态性的一种表现，3. 重载Overloading是一个类中多态性的一种表现。4. 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&quot;屏蔽&quot;了。5. 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。<br></code></pre></td></tr></table></figure><h4 id="super关键词"><a href="#super关键词" class="headerlink" title="super关键词"></a>super关键词</h4><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210411184500602.png" alt="image-20210411184500602"></p></blockquote><p>this  和  super的区别</p><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210411184639758.png" alt="image-20210411184639758"></p></blockquote><p>面试题：  ==  和  equasl 的区别 </p><blockquote><p>== 既可以比较 地址值和数据值    </p><p>对于基本类型比较的是值   对于引用类型比较的就是地址</p><p>具体 要看自定义类里有没有 重写 Object 的 equals 方法来 判断。</p><p>通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。</p></blockquote><h3 id="字符串和基本数据类型之间的互相转换"><a href="#字符串和基本数据类型之间的互相转换" class="headerlink" title="字符串和基本数据类型之间的互相转换"></a>字符串和基本数据类型之间的互相转换</h3><p><strong>String 转换成基本数据类型的方法</strong></p><p><strong>基本数据类型转换String</strong> </p><p><img src="/2021/06/15/JavaSeRelearn/image-20210414104116418.png" alt="image-20210414104116418"></p><h3 id="interface-gt-abstract"><a href="#interface-gt-abstract" class="headerlink" title="interface   -&gt;  abstract"></a>interface   -&gt;  abstract</h3><p>接口和抽象类有什么不同点和共同点</p><p>相同点：</p><blockquote><p>不能实例化    -    都可以包含抽象方法</p></blockquote><p> 不同点：</p><blockquote><p>类： 单继承      接口： 多继承  </p><p>类与接口 ： 多实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">interfaceLearn</span>   <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Dao</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 接口可以调用接口的静态方法        Dao.tses(new Object());        // 默认方法 通过接口的实现类进行调用  如果接口的实现复写了改方法 就调用接口实现者的方法        Dao dao = new interfaceLearn();        // 调用默认方法        // 调用的是抽象类的方法   执行类有先的原则        dao.test();        /**         *  service -&gt;  执行         * java.lang.Object@1b6d3586         * Service-&gt;   test         */    &#125;&#125;interface Dao&#123;    // 结构中可以声明静态方法    static void tses(Object o)&#123;        System.out.println(o);    &#125;    // 接口中的默认方法    default void  test()&#123;        System.out.println(&quot;interface  -&gt; default  -&gt;   test&quot;);    &#125;&#125;abstract class Service&#123;    // 抽象类中声明静态代码块    static &#123;        System.out.println(&quot; service -&gt;  执行&quot;);    &#125;    // 定义普通方法     public void  test()&#123;         System.out.println(&quot;Service-&gt;   test&quot;);     &#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h3><p>疑问 ： </p><ul><li>线程声明周期 ：</li></ul><p><img src="/2021/06/15/JavaSeRelearn/image-20210414155458289.png" alt="image-20210414155458289"></p><ul><li> 创建多线程有多少方法</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 第一种：  通过继承Thread类然后   调用start()进行创建# 第二种： 通过继承runnable()    接口进行创建# 第三种： 通过继承callable 接口进行创建   （带有泛型和返回值）# 第四种： 通过线程池创建</span><br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 使用线程        new MyThread().start();        // 使用runnable 实现接口        new Thread(new RunnableLearn()).start();        // 实现 callable接口 注意这个接口需要使用别的扩展类进行创建线程        new Thread(new FutureTask&lt;&gt;(new CallableLearn())).start();        // 使用线程池创建   创建线程池        System.out.println(&quot;线程池执行 = 》   》》》 》》》   》》&quot;);        ExecutorService executorService = Executors.newFixedThreadPool(10);        executorService.execute(new MyThread());        executorService.execute(new RunnableLearn());        // 执行 callable接口        executorService.execute(new FutureTask&lt;&gt;(new CallableLearn()));        executorService.shutdown();    &#125;&#125;// 创建线程第一种方法class MyThread extends Thread&#123;    @Override    public void run() &#123;        System.out.println(&quot;MyThread  -&gt;  run&quot;);    &#125;&#125;// 第二种创建线程方法  通过 runnable接口class RunnableLearn implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(&quot;runnable  -&gt;  run&quot;);    &#125;&#125;// 第三种方式通过实现callable 接口  该接口带有泛型  泛型就表示call方法返回值class CallableLearn implements Callable&lt;Object&gt; &#123;    @Override    public Object call() throws Exception &#123;        System.out.println(&quot; callable  -&gt;  run&quot;);        return new String(&quot;callable run&quot;);    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>Java里面线程池的<strong>顶级接口是Executor</strong>，但是<strong>严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。</strong>真正的<strong>线程池接口是ExecutorService。</strong></p><p>线程池有几种 ？    四种</p><p>分别是什么   功能以及优缺点？ </p><ul><li><blockquote><h1 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h1><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p></blockquote></li><li><blockquote><h1 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h1><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p></blockquote></li></ul><ul><li><blockquote><h1 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h1><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote></li><li><blockquote><h1 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h1><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p></blockquote></li></ul><h4 id="线程池-源码解析"><a href="#线程池-源码解析" class="headerlink" title="线程池 源码解析"></a><strong>线程池 源码解析</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">都是通过 <span class="hljs-keyword">new</span> ThreadPoolExecutor 进行创建的线程池     <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>,  <span class="hljs-comment">// 核心线程数 process + 1,   // 最大线程数 ==  电脑线程数 + 12L,   // 存活时间 TimeUnit.SECONDS,  // 时间单位new LinkedBlockingQueue&lt;&gt;(3),  // 创建长度为三的阻塞队列  Executors.defaultThreadFactory(),     //   默认线程工厂    //new ThreadPoolExecutor.AbortPolicy() // 出场默认中止策略    //new ThreadPoolExecutor.CallerRunsPolicy()   // 处理不掉的 任务返回给委派任务者    //new ThreadPoolExecutor.DiscardPolicy()  //  抛弃任务中的等待时间最长的任务，然后把当前任务加入队列中，尝试再次提交当前任务   不抛出异常    new ThreadPoolExecutor.DiscardOldestPolicy()   // 该策略默默丢弃一些无法处理的任务,不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略);</span><br></code></pre></td></tr></table></figure><h4 id="线程锁："><a href="#线程锁：" class="headerlink" title="线程锁："></a>线程锁：</h4><p>概念暂无 ：“</p><p>详情查看书籍 :   java重点总结</p><p>Start 和  run 方法的区别</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">start与<span class="hljs-built_in">run</span>区别 <span class="hljs-number">1.</span> start（）方法来启动线程，真正实现了多线程运行。这时无需等待<span class="hljs-built_in">run</span>方法体代码执行完毕，可以直接继续执行下面的代码。<span class="hljs-number">2.</span> 通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 <span class="hljs-number">3.</span> 方法<span class="hljs-built_in">run</span>()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行<span class="hljs-built_in">run</span>函数当中的代码。 <span class="hljs-built_in">Run</span>方法运行结束， 此线程终止。然后CPU再调度其它线程。<br></code></pre></td></tr></table></figure><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h4><p>源码分析： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span>          <span class="hljs-title">private</span> <span class="hljs-title">final</span> <span class="hljs-title">char</span> <span class="hljs-title">value</span>[]</span>;    <span class="hljs-comment">// String 是final修饰的， 是不能被修改的// 实现了 Serializable接口实现了序列化// 实现了Comparable接口  可以进行比较// String底层默认使用字符数组进行存储</span><br></code></pre></td></tr></table></figure><p>字符串实例方式  以及差异 </p><blockquote><p>第一种方式通过字符字面量进行创建</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String name = <span class="hljs-string">&quot;anzhen&quot;</span>; <span class="hljs-comment">// 直接创建在常量池    </span><br></code></pre></td></tr></table></figure><blockquote><p>第二种通过new  String 进行创建    </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String names = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;anzhen&quot;</span>);System.out.println(names == name); <span class="hljs-comment">// 比较地址值// 返回值为false</span><br></code></pre></td></tr></table></figure><p>请问new String() 开辟了 几块内存 </p><blockquote><p>两个: 一个是<strong>堆空间中new结构</strong>，另一个是<strong>char[]对应的常量池中的数据</strong>：”abc”</p></blockquote><p>创建过程如下： </p><blockquote><p>先在堆空间开辟对象，然后查找字符串常量池中查找传入的值  </p><p>如果字符串常量池中存在则把字符串常量地址复制给value</p></blockquote><p>检验如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">names = names.intern();   <span class="hljs-comment">// intern 将字符串的值推向常量池  如果常量池存在则把常量池对象地址赋值给变量System.out.println(names == name);  // 比较地址值</span><br></code></pre></td></tr></table></figure><p>字符串拼接：</p><blockquote><p>常量和常量拼接在字符串常量池   常量池不会存在相同的常量</p><p>只要<strong>其中一个是变量</strong>结果就在<strong>堆中</strong></p><p>如果拼接的字符串的结果调用了 <strong>intern()</strong> 方法， 返回值就在常量池中</p></blockquote><p>string 常用api </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span>：返回字符串的长度： return value.lengthchar <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span>： 返回某索引处的字符return value[index]<span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span>：判断是否是空字符串：return value.length </span>== 0<span class="hljs-function">String <span class="hljs-title">toLowerCase</span><span class="hljs-params">()</span>：使用默认语言环境，将 String 中的所字符转换为小写String <span class="hljs-title">toUpperCase</span><span class="hljs-params">()</span>：使用默认语言环境，将 String 中的所字符转换为大写String <span class="hljs-title">trim</span><span class="hljs-params">()</span>：返回字符串的副本，忽略前导空白和尾部空白<span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span>：比较字符串的内容是否相同<span class="hljs-keyword">boolean</span> <span class="hljs-title">equalsIgnoreCase</span><span class="hljs-params">(String anotherString)</span>：与equals方法类似，忽略大小写String <span class="hljs-title">concat</span><span class="hljs-params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”<span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(String anotherString)</span>：比较两个字符串的大小String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="hljs-title">endIndex</span><span class="hljs-params">(不包含)</span>的一个子字符串。<span class="hljs-keyword">boolean</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(String suffix)</span>：测试此字符串是否以指定的后缀结束<span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span>：测试此字符串是否以指定的前缀开始<span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix, <span class="hljs-keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="hljs-keyword">char</span> 值序列时，返回 trueint <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引<span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引<span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索注：indexOf和lastIndexOf方法如果未找到都是返回-1替换：String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> oldChar, <span class="hljs-keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。String <span class="hljs-title">replace</span><span class="hljs-params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。String <span class="hljs-title">replaceAll</span><span class="hljs-params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。String <span class="hljs-title">replaceFirst</span><span class="hljs-params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。匹配:<span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。切片：String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex)</span>：根据给定正则表达式的匹配拆分此字符串。String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex, <span class="hljs-keyword">int</span> limit)</span>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span><br></code></pre></td></tr></table></figure><p>String 和 基本数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)// 基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)int age = 198;String strAge = String.valueOf(age);  // 基本数据类型和包装类转换字符串int i = Integer.parseInt(strAge);   // 字符串转基本数据类型System.out.println(i == age);   // trueSystem.out.println(strAge instanceof String); // true</span><br></code></pre></td></tr></table></figure><p>String 和 char[] 数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//        String --&gt; char[]:调用String的toCharArray()//        char[] --&gt; String:调用String的构造器String name = &quot;anzhen&quot;;char[] chars = name.toCharArray();  // 转换成字符数组String s = new String(chars);  //  转换字符串System.out.println(s == name); // false  解释如下: 通过new的对象生成在堆里面System.out.println(s.intern() == name); // true</span><br></code></pre></td></tr></table></figure><p>String 和 byte[] 数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">编码：String --&gt; <span class="hljs-keyword">byte</span>[]:调用String的getBytes()解码：<span class="hljs-keyword">byte</span>[] --&gt; String:调用String的构造器编码：字符串 --&gt;字节  (看得懂 ---&gt;看不懂的二进制数据)解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。String name = <span class="hljs-string">&quot;anzhen&quot;</span>;<span class="hljs-keyword">byte</span>[] bytes = name.getBytes(StandardCharsets.UTF_8);<span class="hljs-comment">// 设置标准字符集String s = new String(bytes);System.out.println(Arrays.toString(bytes));System.out.println(s);</span><br></code></pre></td></tr></table></figure><p>​    </p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合类的关系图</p><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210416205008922.png" alt="image-20210416205008922"></p></blockquote><p>接口中定义的方法</p><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210416205148905.png" alt="image-20210416205148905"></p></blockquote><p>collection 与 数组的转换 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">调用 toArray()<br></code></pre></td></tr></table></figure><p>数组  转换为  集合 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">通过  Arrays.asList()<br></code></pre></td></tr></table></figure><p>使用Collection集合存储对象，要求对象所属的类满足：</p><blockquote><p>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</p></blockquote><p>迭代器接口</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">GOF给迭代器模式的定义为：提供一种方法访问一个容器(<span class="hljs-built_in">container</span>)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection list = <span class="hljs-keyword">new</span> ArrayList();  <span class="hljs-comment">// 创建集合对象list.add(&quot;anzhne&quot;);list.add(&quot;age&quot;);list.add(11);Iterator iterator = list.iterator();// 获取拦截器while (iterator.hasNext())&#123;     // 判断是否下一个元素存在    System.out.println(iterator.next());      // 指针下移  进行输出&#125;</span><br></code></pre></td></tr></table></figure><p>collection 接口和  list接口主要的实现类</p><h5 id="List-接口以及实现类"><a href="#List-接口以及实现类" class="headerlink" title="List 接口以及实现类"></a>List 接口以及实现类</h5><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p><ul><li>|—-List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组<ul><li><pre><code> |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</code></pre></li><li><pre><code> |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</code></pre></li><li><pre><code> |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</code></pre></li></ul></li></ul><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>底层源码解析</p><p>疑问1: new 的时候有没有分配大小？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用空参构造器的时候  创建的是this.elementData =      DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  // 这个常量默认等于空只要调用add方法的时候才会创建长度为10的element数组</span><br></code></pre></td></tr></table></figure><p>特点： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">排列有序，可重复底层使用数组查询速度修改速度快  增加和删除慢线程不安全当容量不足时 arraylist的当前容量*<span class="hljs-number">1.5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList list = <span class="hljs-keyword">new</span> LinkedList(); 内部声明了Node类型的first和last属性，默认值为<span class="hljs-keyword">null</span>*      list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//将123封装到Node中，创建了Node对象。**      其中，Node定义为：体现了LinkedList的双向链表的说法private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        this.item = element;        this.next = next;        this.prev = prev;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>特点：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">增加和删除快  但是查询和修改效率不高底层使用的是双向链表 有序的, 可重复的线程不安全<br></code></pre></td></tr></table></figure><h6 id="Vector-已经废用"><a href="#Vector-已经废用" class="headerlink" title="Vector: (已经废用)"></a>Vector: (已经废用)</h6><blockquote><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p></blockquote><h5 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h5><p>set接口特性 ：</p><blockquote><p>无序性， 不可重复的元素</p></blockquote><p>子类 </p><h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><blockquote><p>底层是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">// initial capacity (16) and load factor (0.75).public HashSet() &#123;   map = new HashMap&lt;&gt;();&#125;// 初始化默认长度是 16  加载因子是0.75</span><br></code></pre></td></tr></table></figure><p>无序排列 ， 元素不重复</p><p>存取速度快</p><p>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。</p></blockquote><h6 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h6><blockquote><p>无序排列 ， 元素不重复</p><p>底层实现：二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,Object&gt;());&#125;<br></code></pre></td></tr></table></figure><p>可以自定义排序 </p></blockquote><h6 id="LinkedSet"><a href="#LinkedSet" class="headerlink" title="LinkedSet"></a>LinkedSet</h6><blockquote><p>采用hash表存储，并用双向链表记录插入顺序</p><p>内部是LinkedHashMap</p><p>默认容量和加载因子是 16 ， 0.75</p></blockquote><p>使用Set集合存储对象时， 注意事项</p><blockquote><p>HashSet/LinkedHashSet:</p><p>要求：</p><blockquote><p>向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</p></blockquote><blockquote><p>重写的hashCode()和equals()尽可能保持一致性：</p></blockquote><blockquote><p>相等的对象必须具有相等的散列码</p></blockquote><ul><li><p>   重写两个方法的小技巧：</p></li><li><p>   对象中用作 equals() 方法比较的 Field，</p></li><li><p>   都应该用来计算 hashCode 值。</p></li></ul><p>TreeSet:<br>1.自然排序中，比较两个对象是否相同的标准为：</p><blockquote><p>compareTo()返回0.不再是equals().</p></blockquote><p>2.定制排序中，比较两个对象是否相同的标准为：</p><blockquote><p>compare()返回0.不再是equals().</p></blockquote></blockquote><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h5><p>子类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap  HashTable  （线程安全）TreeMap (可排序)LinkHashMap（记录插入顺序）<br></code></pre></td></tr></table></figure><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><blockquote><p>HashMap根据<strong>键的hashCode</strong>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。<strong>HashMap非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 <strong>Collections的synchronizedMap方法使HashMap具有线程安全的能力</strong>，或者使用<strong>ConcurrentHashMap。</strong></p></blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210417151158049.png" alt="image-20210417151158049"></p><p>当单链表长度大于8时候  单链表变成红黑树</p><h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable:"></a>HashTable:</h6><blockquote><p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是<strong>线程安全</strong>的，任一时间只有一个线程能写Hashtable，<strong>并发性不如ConcurrentHashMap</strong>，因为<strong>ConcurrentHashMap引入了分段锁</strong>。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。****</p></blockquote><h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><blockquote><p>TreeMap实现<strong>SortedMap接口</strong>，能够把<strong>它保存的记录根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。 如果使用排序的映射，建议使用TreeMap。 在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p></blockquote><h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap:"></a>LinkedHashMap:</h6><blockquote><p><strong>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</strong></p></blockquote><p>如何把线程不安全的集合类变得线程安全？？</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;# 回答如下第一种方式 : ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程安全的。使用synchronizedList(List list） 和 synchronizedMap(Map map）给集合类加锁# 第二种使用线程安全的集合类// 线程安全的集合类 arraylist线程安全类CopyOnWriteArrayList// map 集合线程安全类ConcurrentHashMap<br></code></pre></td></tr></table></figure></blockquote><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>集合中使用泛型和不使用泛型的区别</p><blockquote><p>任何类型都可以添加到集合中，类型不安全</p><p>读取出来的数据需要强转， 太过于繁琐</p></blockquote><p>集合泛型总结</p><blockquote><ul><li>① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。</li></ul><ul><li> ② 在实例化集合类时，可以指明具体的泛型类型</li><li> ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</li><li> 比如：add(E e)  —&gt;实例化以后：add(Integer e)</li><li> ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li><li> ⑤ 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。</li></ul></blockquote><h3 id="Class-反射"><a href="#Class-反射" class="headerlink" title="Class 反射"></a>Class 反射</h3><p>Class 反射概念  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<span class="hljs-comment"># 框架 = 反射 + 注解 + 设计模式。3.体会反射机制的“动态性”</span><br></code></pre></td></tr></table></figure><p>类加载过程：</p><blockquote><p>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</p><p>2.换句话说，Class的实例就对应着一个运行时类。</p><p>3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p></blockquote><p>获取class实例的四种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;System.out.println(personClass.getClassLoader());  //  AppClassLoader// 通过对象获取classPerson person = new Person();Class&lt;? extends Person&gt; aClass = person.getClass(); // 获取class对象System.out.println(aClass.getName());  //  获取全类名// 调用Class的静态方法Class&lt;?&gt; person1 = Class.forName(&quot;com.anzhen.io.Person&quot;);System.out.println(person1);// 使用类加载器加载ClassLoader classLoader = ClassLearn.class.getClassLoader();Class&lt;?&gt; aClass1 = classLoader.loadClass(&quot;com.anzhen.io.Person&quot;);// 加载classSystem.out.println(aClass1);</span><br></code></pre></td></tr></table></figure><p>通过反射创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;// 通过反射获取对象Person person = personClass.newInstance();System.out.println(person);</span><br></code></pre></td></tr></table></figure><p>获取全部权限为public的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] fields = personClass.getFields();<span class="hljs-comment">// 只能获取权限为public的for (Field field : fields) &#123;    System.out.println(field);&#125;</span><br></code></pre></td></tr></table></figure><p>获取全部属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] declaredFields = personClass.getDeclaredFields();  <span class="hljs-comment">// 获取全部属性的信息 包括私有的（不包含父类的）for (Field declaredField : declaredFields) &#123;    System.out.println(declaredField);&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz = Person.class;<span class="hljs-comment">//getConstructors():获取当前运行时类中声明为public的构造器Constructor[] constructors = clazz.getConstructors();for(Constructor c : constructors)&#123;    System.out.println(c);&#125;System.out.println();//getDeclaredConstructors():获取当前运行时类中声明的所的构造器Constructor[] declaredConstructors = clazz.getDeclaredConstructors();for(Constructor c : declaredConstructors)&#123;System.out.println(c);&#125;// 获取父类Class superclass = clazz.getSuperclass();System.out.println(superclass);        // 获取父类泛型Type genericSuperclass = clazz.getGenericSuperclass();System.out.println(genericSuperclass);</span><br></code></pre></td></tr></table></figure><p>通过class 创建实例打开私有权限 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;// 通过反射获取对象Person person = personClass.newInstance();person.setName(&quot;anzhen&quot;);person.setAge(19);Field age = personClass.getDeclaredField(&quot;age&quot;);// 打开权限age.setAccessible(true);System.out.println(age.get(person));</span><br></code></pre></td></tr></table></figure><p>通过class 调用方法 和 静态方法</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSe</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
