<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="Java基础理论"><a href="#Java基础理论" class="headerlink" title="Java基础理论"></a>Java基础理论</h2><h3 id="常见Java多线程问题"><a href="#常见Java多线程问题" class="headerlink" title="常见Java多线程问题"></a>常见Java多线程问题</h3><p>什么是多线程? </p><blockquote></blockquote><p>多线程的出现是要解决什么问题的?</p><blockquote><p>提高效率 </p></blockquote><p>线程不安全是指什么? 举例说明</p><blockquote></blockquote><p>并发出现线程不安全的本质什么?</p><blockquote><p>可见性，原子性和有序性。</p></blockquote><p>Java是怎么解决并发问题的?</p><blockquote><p>3个关键字，JMM和8个Happens-Before</p></blockquote><p>线程安全是不是非真即假? </p><blockquote><p>不是</p><p>线程安全是一个类在多个线程安全调用的情况就是线程安全 </p><p>线程安全根据共享数据的安全程度来分成 ：不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</p></blockquote><p>线程安全有哪些实现思路?</p><blockquote></blockquote><p>如何理解并发和并行的区别</p><blockquote></blockquote><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程 ??"></a>为什么需要多线程 ??</h3><p>内存/cpu/IO设备的速度是有很大的差距的,为了合理利用CPU的高性能,平衡这三者的速度差异,让计算机体系结构,操作系统,编译程序都做出了巨大贡献,主要体现为:</p><ul><li>cpu出现了缓存,以均衡与内存的速度差异  // 导致了 可见性的问题</li><li>操作系统增加了进程,线程,分时复用CPU,进而均衡CPU和IO设备的差异  //  导致了原子性</li><li>编译程序优化指令执行次序,使缓存能够得到更加合理地利用   // 导致了有序性</li></ul><h3 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="headerlink" title="并发出现问题的根源: 并发三要素"></a>并发出现问题的根源: 并发三要素</h3><h4 id="可见性-CPU缓存引起"><a href="#可见性-CPU缓存引起" class="headerlink" title="可见性 :  CPU缓存引起"></a>可见性 :  CPU缓存引起</h4><p>​        一个线程对共享变量的修改,另外一个线程能够立即看到</p><h4 id="原子性-分时复用引起"><a href="#原子性-分时复用引起" class="headerlink" title="原子性:   分时复用引起"></a>原子性:   分时复用引起</h4><p>​        即一个操作或多个操作,要么全部执行并且执行过程不会被任何因素打乱,要么就不执行</p><h4 id="有序性-指令重排引起"><a href="#有序性-指令重排引起" class="headerlink" title="有序性:   指令重排引起"></a>有序性:   指令重排引起</h4><p>​        有序性:即程序执行的顺序按照代码的先后顺序</p><h3 id="Java是如何解决并发问题的"><a href="#Java是如何解决并发问题的" class="headerlink" title="Java是如何解决并发问题的"></a>Java是如何解决并发问题的</h3><blockquote><p>使用JMM(Java内存模型)</p></blockquote><h4 id="理解第一个维度"><a href="#理解第一个维度" class="headerlink" title="理解第一个维度"></a>理解第一个维度</h4><p>JMM本质上可以理解为,Java内存模型规范了,JVM如何提供按需警用缓存和编译优化的方法.  具体来说,这些方法包括</p><ul><li>volatile    synchronized     final  三个关键字</li><li>Happens - Before规则</li></ul><h4 id="理解第二个维度"><a href="#理解第二个维度" class="headerlink" title="理解第二个维度"></a>理解第二个维度</h4><ul><li><p>原子性</p><ul><li><blockquote><p>Java内存模型保证了基本读取和赋值操作时原子性,如果要大面积实现更大范围操作的原子性,可以通过synchronized 和 Lock来实现.由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块,那么自然就不存在原子性问题了,从而保证了原子性</p></blockquote></li></ul></li><li><p>可见性</p><ul><li><p>Java提供了volatile来保证可见性</p></li><li><p>当一个共享变量被修改时,它会保证修改的值会立即被更新到主存,当有其他线程需要读取时,它会去内存中读取新值.</p><ul><li><blockquote><p>然而 synchronized和Lock也能保证可见性,synchronized和lock能保证同一时刻只有一个线程获取锁然后执行同步代码,并且在释放锁之前会将对变量的修改刷新到主存中. 因此保证可见性</p></blockquote></li></ul></li></ul></li><li><p>有序性 </p><blockquote><p>可以使用volatile来保证有序性 </p><p>可以使用synchronized和Lock保证有序性</p><p>JMM是通过Happens -Before来保证有序性 </p></blockquote></li></ul><h4 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h4><p>上面提到了synchroized和lock来保证有序性.  除此之外JMM还规定了先行发生原则,让一个操作无需控制就能先于另一个操作完成 .</p><h5 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h5><blockquote><p>single  Thread  rule </p></blockquote><p>在一个线程内,在程序前面的操作先行与发生于后面的操作</p><p><img src="https://www.pdai.tech/_images/pics/single-thread-rule.png" alt="image"> </p><h5 id="2-管道锁定规则"><a href="#2-管道锁定规则" class="headerlink" title="2.管道锁定规则"></a>2.管道锁定规则</h5><blockquote><p>Monitor   Lock   Rule</p></blockquote><p>一个unLock操作先行发生于后面对同一个锁的Lock操作 </p><p><img src="https://www.pdai.tech/_images/pics/monitor-lock-rule.png" alt="image">  </p><p>3.volatile变量原则</p><blockquote><p>Volatile  Varible  Rule </p></blockquote><p>对一个Volatile的变量的写操作先行发生于后面对这个变量的读操作</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile-variable-rule.png" alt="image"></p><h5 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4.线程启动规则"></a>4.线程启动规则</h5><blockquote><p>Thread  Start     Rule</p></blockquote><p>Thread 对象的 start()方法调用先行发生于此线程的每一个动作.</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/thread-start-rule.png" alt="image"> </p><h5 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5.线程加入规则"></a>5.线程加入规则</h5><blockquote><p>Thread      Join     Rule </p></blockquote><p>Thread对象的结束先行发生于join()方法返回</p><p><img src="/2021/07/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/thread-join-rule.png" alt="image"> </p><h5 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6.线程中断规则"></a>6.线程中断规则</h5><blockquote><p>Thread     Interruption  Rule</p></blockquote><p><strong>对线程interrupt()方法的调用先行</strong>发生于被中断线程的代码检测到中断事件的发生,可以通过interrupted()方法检测到是否有中断发生</p><h5 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7.对象终结规则"></a>7.对象终结规则</h5><blockquote><p>finallizer  Rule</p></blockquote><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</p><h5 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8.传递性"></a>8.传递性</h5><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C.</p><h4 id="线程安全-不是一个非真即假的命题"><a href="#线程安全-不是一个非真即假的命题" class="headerlink" title="线程安全:不是一个非真即假的命题"></a>线程安全:不是一个非真即假的命题</h4><p>一个类在可以被多个线程安全调用时就是线程安全的。</p><p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱分成一下五类：不可变、线程绝对安全、相对线程安全、线程兼容和线程对立。</p><h5 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h5><p>不可变的对象一定是线程安全的，不需要再采取任何线程的安全保障措施。只要一个不可变的对象被正确的构建出来，永远也不会看到它在多个线程中处于不一致的状态</p><p>不可变的类型 ： </p><ul><li><p>final字段修饰的基本数据类型 </p></li><li><p>String</p></li><li><p>枚举类型</p></li><li><p>Number部分子类，如Long,Double等数值包装类，BigInteger和BigDecimal等大数据类型。但同为Numher的原子类AtomicInteger 和 AtomicLong 则是可变的。</p></li></ul><p>对于集合类型可以通过Collecitons.unmodifiable(xxx) 获取一个不可变的集合 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个不可变的集合类型</span><br>HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zimu&quot;</span>);<br>Map&lt;String, Object&gt; stringObjectMap =<br>        Collections.unmodifiableMap(map);<br>System.out.println(stringObjectMap.get(<span class="hljs-string">&quot;name&quot;</span>));<br>stringObjectMap.put(<span class="hljs-string">&quot;ziu&quot;</span>, <span class="hljs-number">111</span>);<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">zimu<br>Exception <span class="hljs-keyword">in</span> thread &quot;main&quot; java.lang.UnsupportedOperationException<br><span class="hljs-built_in">at</span> java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="hljs-number">1457</span>)<br><span class="hljs-built_in">at</span> com.anzhen.model.reflect.TestReflect.main(TestReflect.java:<span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><p>为什么put会报错呢？</p><blockquote><p>因为Collecitons.unmodifiable(xxx)会对原先的集合进行拷贝，需要对集合进行修改的方法都是直接抛出异常</p></blockquote><h5 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h5><p>不管运行时环境如何，调用者都不需要任何额外的同步措施</p><h5 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h5><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做任何额外的保障措施。</p><p>但是对于一些特定顺序的连续调用，就可能需要在<strong>调用端使用额外的同步手段</strong>来保证调用的正确性</p><p>场景显示</p><p>将元素删除之后进行获取 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>           vector.add(i);<br>       &#125;<br>       ExecutorService executorService = Executors.newCachedThreadPool();<br>       executorService.execute(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>               vector.remove(i);<br>           &#125;<br>       &#125;);<br>       executorService.execute(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>               vector.get(i);<br>           &#125;<br>       &#125;);<br>       executorService.shutdown();<br>   &#125;<br></code></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;pool-25-thread-2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="hljs-number">174</span><br>at java.util.Vector.get(Vector.java:<span class="hljs-number">751</span>)<br>at com.anzhen.model.reflect.TestReflect.lambda$main$<span class="hljs-number">1</span>(TestReflect.java:<span class="hljs-number">31</span>)<br>at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1149</span>)<br>at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">624</span>)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure><p>解决问题的优化 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">executorService.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (vector) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>            vector.remove(i);<br>        &#125;<br>    &#125;<br>&#125;);<br>executorService.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (vector) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>            System.out.println(vector.get(i));<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>对俩个方法进行加锁，保证同步</p><h5 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h5><p>线程兼容是指<strong>对象本身并不是线程安全的</strong>，但是可以通过在<strong>调用端正确的使用同步手段来保证对象在并发环境中可以安全地使用</strong>，我们通常说一个类是线程不安全通常就是指这种情况</p><h5 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h5><p>线程对立是<strong>无论调用端是否采取了同步措施</strong>，<strong>都无法在多线程环境中并发使用的代码</strong> </p><p>由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p><p>什么是线程安全 ？？   有哪几种线程安全的 </p><blockquote><p>一个类在多个线程安全调用的情况就是线程安全 </p><p>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</p></blockquote><h4 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h4><h5 id="1、互斥同步"><a href="#1、互斥同步" class="headerlink" title="1、互斥同步"></a>1、互斥同步</h5><p>ReetrantLock 和 synchronized </p><p>初步分析查看 ：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5</a></p><p>详细深入查看文档 ：</p><p> synchronized <a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></p><p>ReetrantLock ：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html">https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html</a></p><h5 id="2、非阻塞式同步"><a href="#2、非阻塞式同步" class="headerlink" title="2、非阻塞式同步"></a>2、非阻塞式同步</h5><p>非阻塞式同步和阻塞式同步有什么不同？</p><blockquote><p>阻塞式同步，不论多少线程都只能一条线程进行代码中，并且需要一直加锁放锁会带来性能问题</p></blockquote><h6 id="一-CAS"><a href="#一-CAS" class="headerlink" title="一)CAS"></a>一)CAS</h6><p>使用基于乐观并发策略: 先进行操作，如果没有其他线程争用共享数据，那就操作成功，否则就采取补偿措施（不断重试，直到成功为止）。这种乐观的并发策略都不需要将线程阻塞，因此这种同步操作称之为非阻塞式同步</p><h6 id="二）AtomicIntger"><a href="#二）AtomicIntger" class="headerlink" title="二）AtomicIntger"></a>二）AtomicIntger</h6><p>J.U.C包里面的整数原子类AtomicInteger ，其中的compareAndSet() 和 getAndIncrement()等方法都使用了Unsafe类的CAS操作</p><h5 id="3、无同步方案"><a href="#3、无同步方案" class="headerlink" title="3、无同步方案"></a>3、无同步方案</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架详解</title>
    <link href="/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="集合体系架构图"><a href="#集合体系架构图" class="headerlink" title="集合体系架构图"></a>集合体系架构图</h2><p><img src="https://www.pdai.tech/_images/java_collections_overview.png" alt="img"></p><h3 id="什么是容器，有什么优点？"><a href="#什么是容器，有什么优点？" class="headerlink" title="什么是容器，有什么优点？"></a>什么是容器，有什么优点？</h3><blockquote><p>容器就是容纳其他Java对象的对象</p><p>优点是: </p><ul><li>降低编程难度</li><li>提高程序性能</li><li>提高API间的互操作性</li><li>降低学习难度</li><li>降低设计和实现相关API的难度</li><li>增加程序的重要性</li></ul><p>注意特点 ： 容器里面只能放入对象 ，如果是基本数据类型的话 ，需要转成包装类</p></blockquote><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><blockquote><p>容器主要包括Collection 和 Map俩种， Collection存储着对象的集合，而Map存储着键值对的映射表</p></blockquote><p>Set</p><ul><li>TreeSet<ul><li>基于红黑树实现，支持有序性操作。但是查询效率不如HashSet，HashSet查找为O（1） TreeSet查找效率为O(logn)</li></ul></li><li>HashSet<ul><li>基于Hash表实现，支持快速查询，但不是支持有序操作。并且失去了元素的插入顺序信息，也就是说iterator遍历的HashSet得到的结果是不一样的</li></ul></li><li>LinkedHashSet<ul><li>具有HashSet的查询效率，内部采用双向链表维护元素的插入顺序</li></ul></li></ul><p>List</p><ul><li>ArrayList<ul><li>基于动态数组实现</li></ul></li><li>LinkedList <ul><li>基于双向链表实现 </li></ul></li><li>Vector<ul><li>和ArrayList类似，但是是线程安全的</li></ul></li></ul><p>Queue</p><ul><li><p>​    LinkedList</p><ul><li>可以用它来实现双向队列 </li></ul></li><li><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><ul><li>基于堆结构实现，可以用它来实现优先队列 </li></ul></li></ul><p>Map</p><ul><li>HashMap<ul><li>基于哈希表实现</li></ul></li><li>HashTree<ul><li>基于红黑树实现</li></ul></li><li>HashTable<ul><li>和HashMap类似但是是线程安全的，意味着这个同一时刻多个线程同时写入不会导致数据不一致，它是遗留类，不应该去使用它。现在可以使用ConcurrentHashMap来支持线程安全，并且ConcurrentHashMap效率更高，因为ConcurrentHashMap引入了分段锁</li></ul></li><li>LinkedHashMap<ul><li>使用双向链表来维护元素的顺序，顺序为插入顺序或者是最少使用顺序</li></ul></li></ul><h3 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h3><h4 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h4><p>特点 ： 不是线程安全的，可以存储NULL ， 继承了List 是顺序容器</p><h4 id="底层用什么进行存储"><a href="#底层用什么进行存储" class="headerlink" title="底层用什么进行存储"></a>底层用什么进行存储</h4><p>底层采用不能序列化的Object数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;  <span class="hljs-comment">// 长度 </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 默认容量</span><br></code></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定容量大小进行进项创建ArrayList</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty list with an initial capacity of ten.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 默认的空参构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a list containing the elements of the specified</span><br><span class="hljs-comment"> * collection, in the order they are returned by the collection&#x27;s</span><br><span class="hljs-comment"> * iterator.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c the collection whose elements are to be placed into this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 传入集合类转换为ArrayList</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><br><span class="hljs-comment">// 扩容</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    <br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>扩容原理：</p><p><img src="/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/image-20210712083255565.png" alt="image-20210712083255565"></p><p>如上图所示 ，集合每次添加一个元素会添加之后容量是否足够，如果不够的话进行扩容</p><p>扩容的方式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">elementData = Arrays.copyOf(elementData, newCapacity);<br></code></pre></td></tr></table></figure><p>数组操作是，是将老数组的元素全部拷贝一份到新数组中，每次数组容量增加大约是其源容量的1.5倍。这种操作代价高，所以在使用中，应该尽量避免数组扩容。当我们知道具体容量时，可以使用指定容量的构造方法进行创建。或者根据实际需求，通过调用ensureCapacity进行手动扩容。</p><p>扩容图解</p><p><img src="/2021/07/13/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/image-20210712084807191.png" alt="image-20210712084807191"></p><h4 id="add-addAll添加方法"><a href="#add-addAll添加方法" class="headerlink" title="add  addAll添加方法"></a>add  addAll添加方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>   <span class="hljs-comment">// 检测数组中容量是否足够  </span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查index是否可以添加元素 </span><br>    rangeCheckForAdd(index);<br>   <span class="hljs-comment">// 校验容量是否足够 </span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 从某个位置进行插入 </span><br>    <span class="hljs-comment">// 需要位置之后的元素向后移动一个单位 </span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    <span class="hljs-comment">// 将数据赋值到指定位置 </span><br>    elementData[index] = element;<br>    size++;<br>&#125;<br><br><br><span class="hljs-comment">// 将数组拼接到结尾</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-keyword">int</span> numNew = a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 指定位置对接 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-keyword">int</span> numNew = a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-keyword">int</span> numMoved = size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> 添加的时候都会检测容量是否足够，如果不够的话进行扩容，扩容操作通过grow方法完成</p><h4 id="romove"><a href="#romove" class="headerlink" title="romove"></a>romove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    checkForComodification();<br>    E result = parent.remove(parentOffset + index);<br>    <span class="hljs-keyword">this</span>.modCount = parent.modCount;<br>    <span class="hljs-keyword">this</span>.size--;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>对指定位置进行删除</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><blockquote><p>较为简单，对指定位置进行赋值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    rangeCheck(index);<br><br>    E oldValue = elementData(index);<br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br><br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>获取指定位置的元素</p></blockquote><h4 id="rimToSize"><a href="#rimToSize" class="headerlink" title="rimToSize"></a>rimToSize</h4><blockquote><p>将底层数组长度调整为当前列表保存实际元素的大小 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;<br>    modCount++;<br>    <span class="hljs-comment">// 判断当前大小是不是小于数组总长度</span><br>    <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>        elementData = (size == <span class="hljs-number">0</span>)<br>          ? EMPTY_ELEMENTDATA<br>          : Arrays.copyOf(elementData, size);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="index-indexOf"><a href="#index-indexOf" class="headerlink" title="index   indexOf"></a>index   indexOf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从开头查找位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 从数组结尾查找位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>从开头查找位置和结尾查找位置</p></blockquote><h4 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制:"></a>Fail-Fast机制:</h4><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p><h3 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>是什么    </p><p>由链表构成的集合类</p></blockquote><h4 id="存储的数据类型"><a href="#存储的数据类型" class="headerlink" title="存储的数据类型"></a>存储的数据类型</h4><blockquote><p>实现了List，序列化接口 ， 队列接口  ， 克隆接口 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Pointer to first node.</span><br><span class="hljs-comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="hljs-comment">     *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Pointer to last node.</span><br><span class="hljs-comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="hljs-comment">     *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><br><span class="hljs-comment">// 使用静态内部类Node存储数据</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E item;<br>    Node&lt;E&gt; next;  <span class="hljs-comment">// 指向下一个指针</span><br>    Node&lt;E&gt; prev;  <span class="hljs-comment">// 指向前驱的指针 </span><br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.item = element;<br>        <span class="hljs-keyword">this</span>.next = next;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a list containing the elements of the specified</span><br><span class="hljs-comment"> * collection, in the order they are returned by the collection&#x27;s</span><br><span class="hljs-comment"> * iterator.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  c the collection whose elements are to be placed into this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 调用空参构造器 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    addAll(c);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getFirst，getLast"><a href="#getFirst，getLast" class="headerlink" title="getFirst，getLast"></a>getFirst，getLast</h4><blockquote><p>获取第一个元素  ， 获取最后一个元素 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取第一个 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-comment">// 获取最后一个 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> l.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><h4 id="removeFirst，removeLast，-remove-e-，remove-index"><a href="#removeFirst，removeLast，-remove-e-，remove-index" class="headerlink" title="removeFirst，removeLast， remove(e) ，remove(index)"></a>removeFirst，removeLast， remove(e) ，remove(index)</h4><p>remove有俩个版本，一个根据元素匹配，一个根据位置进行查询</p><blockquote><p>根据元素进行删除  判断是否是空值， 因为List中可以存储空值 </p><p>删除统一用那个解除链接的方法，将被删除元素的指针删除，元素被删除之后得维护前驱和后继的链接关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 取消链接</span><br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                <span class="hljs-comment">// 取消链接 </span><br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br><br><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br>        <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-comment">// 获取元素 </span><br>        <span class="hljs-keyword">final</span> E element = x.item;<br>    <span class="hljs-comment">// 赋值后继指针 </span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-comment">// 赋值前驱指针 </span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 第一个元素</span><br>            first = next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prev.next = next;<br>            x.prev = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 最后一个元素</span><br>            last = prev;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.prev = prev;<br>            x.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        x.item = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// GC</span><br>        size--;<br>        modCount++;<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br><br><br><span class="hljs-comment">// 先检查位置是否合理 不合理直接抛出异常 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除图解"><a href="#删除图解" class="headerlink" title="删除图解"></a>删除图解</h4><p><img src="https://www.pdai.tech/_images/collection/LinkedList_remove.png" alt="LinkedList_remove.png"></p><p>删除开头元素和结尾元素最为简单，因为移动的指针很少 </p><p>删除开头元素 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-keyword">final</span> Eelement = f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-keyword">null</span>;<br>    f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>    <span class="hljs-comment">// 将头指针赋值给被删除元素的后继</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>        last = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-comment">// 删除最后一个节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;<br>    <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span><br>    <span class="hljs-keyword">final</span> E element = l.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;<br>    l.item = <span class="hljs-keyword">null</span>;<br>    l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>    <span class="hljs-comment">// 将尾指针赋值给被删除元素的前驱</span><br>    last = prev;<br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)<br>        first = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span><br>        prev.next = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-，-addAll"><a href="#add-，-addAll" class="headerlink" title="add ， addAll"></a>add ， addAll</h4><blockquote><p>add也是需要操作指针，不过这个模式是使用 尾插法进行添加的数据，最后插入的花费的时间较少</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    checkPositionIndex(index);<br><br>    <span class="hljs-keyword">if</span> (index == size)<br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>    first = newNode;<br>    <span class="hljs-keyword">else</span><br>    l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="添加移动指针图解"><a href="#添加移动指针图解" class="headerlink" title="添加移动指针图解"></a>添加移动指针图解</h4><p><img src="https://www.pdai.tech/_images/collection/LinkedList_add.png" alt="LinkedList_add"></p><p>addAll方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用的重载的方法 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> addAll(size, c);<br>&#125;<br><br><span class="hljs-comment">// 使用位置  </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>   <span class="hljs-comment">// 校验位置是否合理</span><br>    checkPositionIndex(index);<br><br>    <span class="hljs-comment">// </span><br>    Object[] a = c.toArray();<br>    <span class="hljs-keyword">int</span> numNew = a.length;<br>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    Node&lt;E&gt; pred, succ;<br>    <span class="hljs-keyword">if</span> (index == size) &#123;<br>        succ = <span class="hljs-keyword">null</span>;<br>        pred = last;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        succ = node(index);<br>        pred = succ.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (Object o : a) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;<br>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            pred.next = newNode;<br>        pred = newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123;<br>        last = pred;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pred.next = succ;<br>        succ.prev = pred;<br>    &#125;<br><br>    size += numNew;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><blockquote><p>清楚链表全部元素，方便GC回收</p></blockquote><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><blockquote><p>从头节点开始遍历，将全部的数据和节点都赋值为空，将大小置为空，将头尾指针赋值为空</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; ) &#123;<br>        Node&lt;E&gt; next = x.next;<br>        x.item = <span class="hljs-keyword">null</span>;<br>        x.next = <span class="hljs-keyword">null</span>;<br>        x.prev = <span class="hljs-keyword">null</span>;<br>        x = next;<br>    &#125;<br>    first = last = <span class="hljs-keyword">null</span>;<br>    size = <span class="hljs-number">0</span>;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Positional-Access-方法"><a href="#Positional-Access-方法" class="headerlink" title="Positional Access 方法"></a>Positional Access 方法</h4><h5 id="通过index获取元素"><a href="#通过index获取元素" class="headerlink" title="通过index获取元素"></a>通过index获取元素</h5><blockquote><p>先校验index是否合理，合理之后进行迭代获取 ， 遍历采用二分查找 </p></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 通过id获取数据 </span><br><span class="hljs-keyword">public</span> E get(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>) &#123;<br><span class="hljs-comment">// </span><br>    checkElementIndex(<span class="hljs-keyword">index</span>);<br>    <span class="hljs-keyword">return</span> node(<span class="hljs-keyword">index</span>).item;<br>&#125;<br><br>Node&lt;E&gt; node(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>) &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br><span class="hljs-comment">// 判断是否合理</span><br><span class="hljs-comment">// 二分法 通过判断位置是否大于中简单的数据 </span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">index</span>; i++)<br>            x = x.<span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 大于从结尾查</span><br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = size - <span class="hljs-number">1</span>; i &gt; <span class="hljs-keyword">index</span>; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对某个位置重新赋值"><a href="#对某个位置重新赋值" class="headerlink" title="对某个位置重新赋值"></a>对某个位置重新赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验长度是否合理</span><br>    checkElementIndex(index);<br>    Node&lt;E&gt; x = node(index);<br>    <span class="hljs-comment">// 获得修改前的值</span><br>    E oldVal = x.item;<br>    x.item = element;<br>    <span class="hljs-keyword">return</span> oldVal;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="根据index删除元素"><a href="#根据index删除元素" class="headerlink" title="根据index删除元素"></a>根据index删除元素</h4><blockquote><p>先判断位置是否合理 ， 然后进行删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><blockquote><p>通过元素查询位置  ， 定义一个count判断元素是否相等，返回count</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> index;<br>            index++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                <span class="hljs-keyword">return</span> index;<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = size;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            index--;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> index;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            index--;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                <span class="hljs-keyword">return</span> index;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h4><blockquote><p>使用LinkedList做队列的方法 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">element</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getFirst();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkFirst(f);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> add(e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Deque方法-双端队列"><a href="#Deque方法-双端队列" class="headerlink" title="Deque方法  (双端队列)"></a>Deque方法  (双端队列)</h4><blockquote><p>Linked实现了deque的接口 </p></blockquote><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addFirst(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : l.item;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkFirst(f);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkLast(l);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addFirst(e);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> removeFirst();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> remove(o);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>(当作栈或队列使用时)有着更好的性能。</p></blockquote><h3 id="Stack-amp-Queue源码解析"><a href="#Stack-amp-Queue源码解析" class="headerlink" title="Stack &amp;  Queue源码解析"></a>Stack &amp;  Queue源码解析</h3><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><blockquote><p>Java里有一个Stack的类 ，却没有一个Queue的类(只有一个接口)。官方不推荐使用Stack，而是推荐使用高效的ArrayDuque；虽然Queue只是一个接口，当需要使用队列时也就首选了ArrayDuque 次选时 LinkedList</p></blockquote><h3 id="Priority-Queue源码解析"><a href="#Priority-Queue源码解析" class="headerlink" title="Priority  Queue源码解析"></a>Priority  Queue源码解析</h3><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><h3 id="HashSet-amp-HashMap源码解析"><a href="#HashSet-amp-HashMap源码解析" class="headerlink" title="HashSet  &amp;  HashMap源码解析"></a>HashSet  &amp;  HashMap源码解析</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><blockquote><p>由于HashSet底层还是使用的是HashMap所以主谈HashMap</p></blockquote><p>查看源码得知 :  HashSet本质就是使用HashMap的Key特性创建而成 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5024744406713321676L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br>    <span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment">     * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="hljs-keyword">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>        addAll(c);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="HashMap用什么结构存储数据"><a href="#HashMap用什么结构存储数据" class="headerlink" title="HashMap用什么结构存储数据"></a>HashMap用什么结构存储数据</h4><blockquote><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p></blockquote><h4 id="HashMap结构图"><a href="#HashMap结构图" class="headerlink" title="HashMap结构图"></a>HashMap结构图</h4><p><img src="https://www.pdai.tech/_images/java/java-collection-hashmap8.png" alt="img"></p><p>源码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><br><span class="hljs-comment">// 使用内部类Node进行存储 ， 实现了 Entry接口 </span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; next;<br><br>    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.hash = hash;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>        V oldValue = value;<br>        value = newValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                Objects.equals(value, e.getValue()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由图得知，HashMap用静态内部类node存储数据 </p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><blockquote><p>总结： 因为HashMap是第一次put值的时候进行初始化，所以要判断是否是第一次put值</p><p>2 判断散列的位置有没有值 如果没有的话，将数据放入当前位置 </p><p>3 判断key是否相等，判断hash值是否相等  如果先等的话，直接进行覆盖操作 </p><p>4 判断节点是不是红黑树，如果是的话，直接进行创建</p><p>5 遍历单链表 判断有没有相同的key如果相同的话，直接进行覆盖，不是的话进行尾插法插入新节点</p><p>6 判断增加有么有过阈值如果超过了阈值就进行扩容</p><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br><span class="hljs-comment">// 第五个参数 evict 我们这里不关心</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    <br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>   <span class="hljs-comment">// 判断是不是第一次put值</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>       <span class="hljs-comment">// 将将resize初始化的值赋值给tab, 将长度给n</span><br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 判断hash之后的位置有没有值   如果没有的话创建Node赋值</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 进入这里表示hash出来的位置有值</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 将之前查找到的位置的数据值 进行Hash比较 传入的key比较</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>           <span class="hljs-comment">// 表示key相等  进行覆盖操作  </span><br>            e = p;<br>        <span class="hljs-comment">// 判断是不是树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 到这里说明当前节点是单链表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 遍历到尾部进行插入操作 </span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 使用尾插法进行节点插入</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 如果binCunt == 8的话 就要转换为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果找到两块相同的地址 </span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>           <span class="hljs-comment">// 将e的值取出来</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">// 将新值替换掉</span><br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回老值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 如果加入的之后的size大于阈值之后应该进行扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数组扩容</p><blockquote><p>流程 ： 判断是否超过阈值 超过了进行扩容 </p><p>结论 ： 每次扩容后为原来的2倍</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">// 将原先数据进行拷贝 </span><br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">// 判断之前的表是否为空 获取原表的容量 </span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-comment">// 获取原表的阈值</span><br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断是否大于最大容量</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-comment">// 将最大值赋值给阈值</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 不是的话新容量 =  旧容量 * 2</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-comment">// 双倍阈值</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 计算新的阈值  =  新容量  *  加载因子0.75</span><br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">// 赋值新阈值 </span><br>    threshold = newThr;<br>    <span class="hljs-comment">//@SuppressWarnings 批注允许您选择性地取消特定代码段（即，类或方法）中的警告。其中的想法是当您看到警告时，您将调查它，如果您确定它不是问题，</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <br>    <span class="hljs-comment">// 使用新容量创建表 </span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-comment">// 将数据遍历 存入新表中并返回</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><blockquote><p>流程 : </p><p>判断hash值是否为空 为空直接返回空 </p><p>判断 // 判断表是否为空, 长度是否小于0, hash散列出来的位置是否有数据</p><p>判断hash是否相等, 判断key是否相等, 判断key的值是否相等</p><p>如果同一位置都不为空的话 , 就直接为</p><p>结论 : </p></blockquote><p>源码解析 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    <span class="hljs-comment">// </span><br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k<br>    <span class="hljs-comment">// 判断表是否为空, 长度是否小于0, hash散列出来的位置是否有数据</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 判断hash是否相等, 判断key是否相等, 判断key的值是否相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-comment">// 返回阶段first</span><br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 表示是单链表或者是树结构</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 判断是否是树节点 </span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 遍历单链表寻找相同的值</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TreeSet-amp-TreeMap-源码解析"><a href="#TreeSet-amp-TreeMap-源码解析" class="headerlink" title="TreeSet  &amp;  TreeMap 源码解析"></a>TreeSet  &amp;  TreeMap 源码解析</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><blockquote><p>之所以把TreeSet和 TreeMap一起讲, 应为二者在java中有着相同的实现,前者只是对后者进行了一层包装,也就是说TreeSet里面有一个TreeMap(适配器模式). </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>activiti学习</title>
    <link href="/2021/07/13/activiti%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/13/activiti%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Activiti"><a href="#Activiti" class="headerlink" title="Activiti"></a>Activiti</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Activiti-介绍"><a href="#Activiti-介绍" class="headerlink" title="Activiti 介绍"></a>Activiti 介绍</h3><p>： Activiti 是一个工作流引擎，可以将复杂的业务抽出出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由Activiti进行管理，减少业务系统由于流程变更进行系统升级改造的的工作量，从而提高系统的健壮性，同时减少系统开发维护成本</p><h4 id="activiti-流程部署"><a href="#activiti-流程部署" class="headerlink" title="activiti 流程部署"></a>activiti 流程部署</h4><p><img src="/2021/07/13/activiti%E5%AD%A6%E4%B9%A0/image-20210713104052176.png" alt="image-20210713104052176"></p><h4 id="activiti使用用法"><a href="#activiti使用用法" class="headerlink" title="activiti使用用法"></a>activiti使用用法</h4><p>创建配置文件 </p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-json-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0.M6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-cloud-services-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>20030825.184428<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    配置有俩种方式  配置数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcDriver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti?characterEncoding=utf-8<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUsername&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcPassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;anzhen3531&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--        帮我们自动创建表结构--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写测试类，通过</p>]]></content>
    
    
    
    <tags>
      
      <tag>activiti</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java复习</title>
    <link href="/2021/07/10/Java%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/07/10/Java%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java整体分析"><a href="#Java整体分析" class="headerlink" title="Java整体分析"></a>Java整体分析</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li>多态</li><li>封装</li><li>继承</li></ol><h4 id="封装是什么-？"><a href="#封装是什么-？" class="headerlink" title="封装是什么 ？"></a>封装是什么 ？</h4><blockquote><p>将抽象数据类型基于数据的操作封装在一起，使其构成一个不可分割的独立实体。</p><p>数据被保护抽象数据类型在内部 ，尽可能地隐藏内部的细节，只提供外部的一些接口进行访问 。</p><p>用户无需关注内部的细节，但是可以通过外部的接口使用访问对象</p></blockquote><p>优点： </p><ul><li>减少耦合 ，可以独立开发，测试，使用，理解</li><li>减轻维护的负担：可以更容易被理解，并且在调试的时候不影响其他模块</li><li>有效地调节性能：可以通过剖析确定那些模块影响性能 </li><li>提高软件的可重用性</li><li>降低构建大型系统地风险：即使整个系统不可以，但是这些独立的模块有可能是可以用的 </li></ul><h4 id="继承是什么-？"><a href="#继承是什么-？" class="headerlink" title="继承是什么 ？"></a>继承是什么 ？</h4><blockquote><p>继承的关系 是一种  is -a  的关系 ， 继承应该遵循里氏替换原则，子类必须能替换掉父类所有的对象 </p></blockquote><h4 id="多态是什么？"><a href="#多态是什么？" class="headerlink" title="多态是什么？"></a>多态是什么？</h4><p>多态分为： </p><ol><li><p>运行时多态</p><ol><li><blockquote><p>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间确定</p></blockquote></li></ol></li><li><p>编译时多态</p><ol><li><blockquote><p>编译时多态主要指方法的重载</p></blockquote></li></ol></li></ol><p>运行时多态三条件:</p><ul><li>继承</li><li>复写</li><li>向上转型</li></ul><h4 id="类图的关系"><a href="#类图的关系" class="headerlink" title="类图的关系"></a>类图的关系</h4><h5 id="泛化关系-用来描述继承关系，Java中extends"><a href="#泛化关系-用来描述继承关系，Java中extends" class="headerlink" title="泛化关系(用来描述继承关系，Java中extends)"></a>泛化关系(用来描述继承关系，Java中extends)</h5><p> <img src="/2021/07/10/Java%E5%A4%8D%E4%B9%A0/image-20210710093913469.png" alt="image-20210710093913469"></p><h5 id="实现关系（Realization）"><a href="#实现关系（Realization）" class="headerlink" title="实现关系（Realization）"></a>实现关系（Realization）</h5><p>用来实现一个接口，在Java中使用implement关键字</p><p><img src="/2021/07/10/Java%E5%A4%8D%E4%B9%A0/image-20210710094132172.png" alt="image-20210710094132172"> </p><p>聚合关系 </p><blockquote><p>若B是A的成员变量，但B不在A的构造函数中生成（new）,只在需要用到的时候才new，则构成聚合关系。</p></blockquote><p>依赖关系（dependency）</p><blockquote><p>若A在某个成员函数中使用了局部变量B，则构成了依赖关系。</p></blockquote><p>组合关系 （Composition）</p><blockquote><p>若B是A的成员变量，且B在A的构造函数种生成（new），则构成组合关系。</p></blockquote><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>8个基本数据类型     占用的字节数 </p><p>boolean    /  1</p><p>byte  /  8</p><p>char   /    16</p><p>short   /  16</p><p>int   / 32 </p><p>float   /  32 </p><p>long    / 64 </p><p>double  /  64</p><p>自动装箱和拆箱 </p><p>基本数据类型都有对应的包装类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntLearn</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer integer = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 装箱 </span><br>        <span class="hljs-keyword">int</span> y = integer;    <span class="hljs-comment">// 拆箱 </span><br>        System.out.println(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>解释一下这个代码 为什么不会相等 ？？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer integer = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>Integer integer1 = Integer.valueOf(<span class="hljs-number">10</span>);<br>System.out.println(integer == integer1);    <span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>​    </p><p>new  Integer(10) 是创建在堆内存里面的对象  ， 每次都会创建一个对象 </p><p>Integer.valueOf(10) 是将常量池的引用赋值过来 ，多个相同的会使用同一个对象</p><p>valueOf() 源码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断i 是否属于缓存池的范围</span><br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-comment">// 如果属于则从缓存中读取</span><br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i  = <span class="hljs-number">124</span>;<br>Integer y = <span class="hljs-number">124</span>;<br>System.out.println(i == y);    <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>基本数据类型包装类的缓冲区大小 </p><blockquote><p>boolean values true and false</p><p>all byte values</p><p>short values between -128 and 127</p><p>int values between -128 and 127</p><p>char in the range \u0000 to \u007F</p></blockquote><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>string 是基本数据类型吗 ？</p><blockquote><p>不是， String是引用数据类型 </p></blockquote><p>String 可以被继承吗 ？ </p><blockquote><p>不可以  String 是final修饰的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br></code></pre></td></tr></table></figure><blockquote><p>String 实现了 序列化接口，比较接口 ， 字符序列接口 </p><p>数据存储采用了 final修饰的字符数组， 所以String数据是不可更改的 </p></blockquote><p>不可变有什么好处 ？？ </p><ul><li>可以缓存hash值<ul><li>在创建的时候就要算hash值， 不可变性就只要算一次hash</li></ul></li><li>String Pool 的需要 <ul><li>如果一个String对象已经被创建过了，那么就会从String Pool中取得引用。只有String是不可变的，才能使用StringPool</li></ul></li><li>安全性 <ul><li>String 经常作为参数，String不可变性质可以保证参数不可变</li></ul></li><li>线程安全 <ul><li>String不可变性天生具有线程安全 ，可以在多个线程中使用</li></ul></li></ul><p>可变的String有哪几个 ？ </p><p>String Buffer   线程安全的    内部使用 <code>synchronized</code></p><p> String Builder 不是线程安全的 </p><p>String.Intern() </p><blockquote><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p></blockquote><p>解释下列现象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String string = <span class="hljs-string">&quot;anzhen&quot;</span>;<br>String anzhen = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;anzhen&quot;</span>);<br>System.out.println(string == anzhen);    <span class="hljs-comment">// false</span><br>System.out.println(anzhen.intern() == string);   <span class="hljs-comment">//  true </span><br></code></pre></td></tr></table></figure><p>创建对象不同， 直接使用字面量创建String的话 ，先检查字符串常量池里面是否有这个常量，如果有的话 就将引用赋值给变量 ，没有就在常量池里创建这个对象</p><blockquote><p>使用字面量创建字符串实例的，会将新建的对象放入String Poll中 </p></blockquote><p>如果使用new String(“111”)的方式去创建对象，先查看字符串常量池里面是否有相等的字符串，如果没有的话就创建，如果有的话将那个字符串的引用地址给对象，对象保存的是指向常量池的引用</p><blockquote><p>开辟了俩个空间 </p></blockquote><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol><li>数据 <ol><li>声明数据为常量，可以是编译时常量，也可能是运行时常量<ol><li>对于基本数据类型 ，数据不能改变</li><li>对于引用数据类型 ，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ol></li></ol></li><li>方法 <ol><li>声明的方法不能被子类重写</li></ol></li><li>类 <ol><li>声明的类不能被继承</li></ol></li></ol><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>静态变量和实例变量的区别 </p><blockquote><p>静态变量 ： 静态变量，称之为类变量，类的所有的实例都共享静态变量，静态变量在内存中只存在一份</p><p>实例变量：每创建一个实例就会产生一个实例变量，它与实例同生共死</p></blockquote><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>能不能声明 抽象静态方法 ？？？ </p><blockquote><p>不能， Illegal combination of modifiers: ‘abstract’ and ‘static’ 编译就会提示警告 </p><p>原因 : 静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，所以不能抽象的 </p></blockquote><p>注意事项，静态方法中，不能有this , super</p><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><p>静态代码块只在类加载的时候执行一次 </p><p>静态加载顺序呢 ？？ </p><blockquote><p>排在前面的先执行</p></blockquote><p>存在继承的情况下，初始化顺序为:</p><ul><li>父类(静态变量、静态语句块)</li><li>子类(静态变量、静态语句块)</li><li>父类(实例变量、普通语句块)</li><li>父类(构造函数)</li><li>子类(实例变量、普通语句块)</li><li>子类(构造函数)</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h5 id="泛型的10道面试题"><a href="#泛型的10道面试题" class="headerlink" title="泛型的10道面试题"></a>泛型的10道面试题</h5><h6 id="1、泛型是什么-？-有什么好处-？"><a href="#1、泛型是什么-？-有什么好处-？" class="headerlink" title="1、泛型是什么 ？  有什么好处 ？"></a>1、泛型是什么 ？  有什么好处 ？</h6><p><strong>泛型</strong> ：顾名思义就是 <strong>广泛的数据类型</strong>，也就是说什么数据类型都可以</p><p>提供了编译器的安全 ，只有填写对应的属性才可以通过编译 </p><h6 id="2、Java泛型如何工作？-什么是类型擦除-？？"><a href="#2、Java泛型如何工作？-什么是类型擦除-？？" class="headerlink" title="2、Java泛型如何工作？  什么是类型擦除 ？？"></a>2、Java泛型如何工作？  什么是类型擦除 ？？</h6><p>工作流程： </p><blockquote><p>Java中的泛型,只在编译阶段有效。在编译过程中,正确检验泛型结果后,会将泛型的相关信息擦出,并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说,泛型信息不会进入到运行时阶段。</p></blockquote><blockquote><p>编译之后会将泛型擦除，比如List<String> 编译之后 就是 List </String></p></blockquote><h6 id="3、什么是泛型中的限定通配符和非限定通配符-？？"><a href="#3、什么是泛型中的限定通配符和非限定通配符-？？" class="headerlink" title="3、什么是泛型中的限定通配符和非限定通配符 ？？"></a>3、什么是泛型中的限定通配符和非限定通配符 ？？</h6><blockquote><p>&lt; ? extends T&gt;  一定要是T类的子类才可以用这个</p></blockquote><blockquote><?  super   T> 一定要是这个类的父类才可以用 </blockquote><h6 id="4、用泛型写一个缓存淘汰算法"><a href="#4、用泛型写一个缓存淘汰算法" class="headerlink" title="4、用泛型写一个缓存淘汰算法"></a>4、用泛型写一个缓存淘汰算法</h6><blockquote><p>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示LinkedHashMap可以用来实现固定大小的LRU缓存  ，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p></blockquote><h6 id="5、Array中可以用泛型吗"><a href="#5、Array中可以用泛型吗" class="headerlink" title="5、Array中可以用泛型吗?"></a>5、Array中可以用泛型吗?</h6><blockquote><p>不可以， 如果数组想要使用泛型的话  可以使用list</p></blockquote><h6 id="6、如何阻止Java中的类型未检查的警告"><a href="#6、如何阻止Java中的类型未检查的警告" class="headerlink" title="6、如何阻止Java中的类型未检查的警告?"></a>6、如何阻止Java中的类型未检查的警告?</h6><blockquote><p>将JDK版本提高到5.0以上</p></blockquote><h6 id="7、你可以把List传递给一个接受List参数的方法吗？"><a href="#7、你可以把List传递给一个接受List参数的方法吗？" class="headerlink" title="7、你可以把List传递给一个接受List参数的方法吗？"></a>7、你可以把List<String>传递给一个接受List<Object>参数的方法吗？</Object></String></h6><blockquote><p>不可以， 这样会导致编译报错 ，</p></blockquote><h3 id="接口和实现类的区别"><a href="#接口和实现类的区别" class="headerlink" title="接口和实现类的区别"></a>接口和实现类的区别</h3><ul><li>一个子类只能继承一个抽象类,但能实现多个接口</li><li>抽象类可以有构造方法,接口没有构造方法</li><li>抽象类可以有普通成员变量,接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li><li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li><li>抽象类可以有静态方法，接口不能有静态方法</li><li>抽象类中的方法可以是public、protected;接口方法只有public abstract</li></ul><h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><blockquote><p>反射是什么 ？ </p><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意的对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称之为Java的反射机制</p></blockquote><p>如何理解Java的一切都是对象</p><blockquote><p>反射就是把java类中的各种成分映射成一个个的Java对象     类也是对象  例如：一个类有实例变量  静态变量， 方法  构造方法，包等等信息，利用反射技术可以对一个类进行剖析，把一个个组成部分映射成一个个Java对象</p></blockquote><ul><li>Class类也是类的一种，与class关键字不同。</li><li>手动编写的类被编译后会产生一个Class对象；其表示是创建的类的类型信息，而且这个Class对象保存在同名.class文件中</li><li>每个通过关键词class标识的类，在内存中有且只有一个与之相对应得Class对象来描述类信息，无论创建多少个实例对象，其依据的都是用一个Class对象 </li><li>Class类只存私有的构造器，因此Class对象只能由JVM创建和加载 </li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要</li></ul><p>获取Class对象的几种方式？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Class对象的三种方式</span><br>logger.info(<span class="hljs-string">&quot;根据类名:  \t&quot;</span> + User.class);<br>logger.info(<span class="hljs-string">&quot;根据对象:  \t&quot;</span> + <span class="hljs-keyword">new</span> User().getClass());<br>logger.info(<span class="hljs-string">&quot;根据全限定类名:\t&quot;</span> + Class.forName(<span class="hljs-string">&quot;com.test.User&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="反射调用流程小结"><a href="#反射调用流程小结" class="headerlink" title="反射调用流程小结"></a>反射调用流程小结</h4><p>最后，用几句话总结反射的实现原理：</p><ol><li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li><li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题提取</title>
    <link href="/2021/07/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%8F%90%E5%8F%96/"/>
    <url>/2021/07/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="面试题基础板块"><a href="#面试题基础板块" class="headerlink" title="面试题基础板块"></a>面试题基础板块</h2><h3 id="JavaSe-常见面试题"><a href="#JavaSe-常见面试题" class="headerlink" title="JavaSe 常见面试题"></a><code>JavaSe</code> 常见面试题</h3><h4 id="1、-和-equals-的区别"><a href="#1、-和-equals-的区别" class="headerlink" title="1、==  和  equals 的区别"></a>1、==  和  equals 的区别</h4><blockquote><p>== 比较的是地址值   </p><p>​            基本类型 比较的是数值</p><p>​            引用类型 比较的是地址</p><p>equals 比较的是具体的值</p></blockquote><p>总结 </p><blockquote><p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p></blockquote><h4 id="2、接口和抽象类的区别"><a href="#2、接口和抽象类的区别" class="headerlink" title="2、接口和抽象类的区别"></a>2、接口和抽象类的区别</h4><ul><li><p><strong>都不能实例化</strong>，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p></li><li><p><strong>抽象类需要被继承，接口需要被实现</strong></p></li><li><p>接口只能做方法申明（类似一个规范），抽象类中可以做方法申明，也可以做方法实现 （增强代码的扩展性）</p></li><li><p>接口定义的变量只能是公共的静态常量，抽象类中定义的变量是普通变量。</p></li><li><p>抽象类中的所有抽象方法都需要被子类实现，如果不能实现父类的全部方法，那么该子类只能是抽象类，一个类实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p></li><li><p><strong>抽象方法只能申明，不能实现</strong></p></li><li><p>抽象类里面可以没有抽象方法，接口里面方法没有方法体</p></li><li><p>如果一个类里面有抽象方法，那么这个类只能是抽象类，</p></li><li><p>抽象类的所有方法不能为静态和私有的，因为所有的抽象方法需要被实现。</p></li><li><p>接口可多实现，抽象类只能继承单个继承</p></li></ul><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>abstract</td><td>interface</td></tr><tr><td>实现</td><td>子类通过extends来继承抽象类，如果<strong>子类不是抽象类</strong>的话需要提供抽象类中所有的证明方法的实现</td><td>通过实现implements关键字来实现接口，它需要提供接口中所有的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中可以是任意访问修饰符</td><td>接口方法默认是public，并且不允许定义为private或者是protected</td></tr><tr><td>多继承</td><td>一个类中直接继承一个</td><td>一个类中可以多实现接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段都是static  和   final修饰的</td></tr></tbody></table><h4 id="3、常用的集合类"><a href="#3、常用的集合类" class="headerlink" title="3、常用的集合类"></a>3、常用的集合类</h4><h6 id="是否线程安全"><a href="#是否线程安全" class="headerlink" title="是否线程安全"></a>是否线程安全</h6><h6 id="如何保证集合类线程安全"><a href="#如何保证集合类线程安全" class="headerlink" title="如何保证集合类线程安全"></a>如何保证集合类线程安全</h6><p>List</p><ul><li><p><code>ArrayList</code></p><blockquote><p>非线程安全    </p><p>保证线程安全的方式 ：</p><ol><li><p>使用Vector  </p></li><li><p>使用<code>Collections.synchronizedList()</code>给集合类加锁 </p></li><li><p>使用新的集合类   CopyOnWriteArrayList 写时复制， 效率高 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();   <br><span class="hljs-comment">// 线程安全  (执行效率变低)  == 不建议使用</span><br>List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());   <span class="hljs-comment">// 使用collections 工具库创建 线程安全的集合</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;(); <span class="hljs-comment">// 写时复制</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>HashMap</code></p><blockquote><p>非线程安全 </p><p>保证线程安全的方式：</p><ol><li>给集合类，加锁 </li><li>使用JUC包下的集合类   <code>ConcurrentHashMap</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 效率低下   不推荐使用</span><br>Map&lt;String,String&gt; hash = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br><br><span class="hljs-comment">// JUC 的hashMap 推荐使用  线程安全  读写分离</span><br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap();<br></code></pre></td></tr></table></figure></blockquote></li></ul><h4 id="4、BIO、NIO、AIO-有什么区别？"><a href="#4、BIO、NIO、AIO-有什么区别？" class="headerlink" title="4、BIO、NIO、AIO 有什么区别？"></a><strong>4、<code>BIO</code>、<code>NIO</code>、<code>AIO</code> 有什么区别？</strong></h4><ul><li><code>BIO</code>：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li><code>NIO</code>：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li><code>AIO</code>：Asynchronous IO 是 <code>NIO</code> 的升级，也叫 <code>NIO2</code>，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h4 id="5、什么是线程和进程"><a href="#5、什么是线程和进程" class="headerlink" title="5、什么是线程和进程"></a>5、什么是线程和进程</h4><p>详情查看另一篇博客 </p><p><strong><code>JMM</code>是什么</strong>  ？</p><blockquote><p>是一套规范 ， 解决了多线程在通过共享内存进行通信时，储存在本地内存时数据不一致，编译器会对代码指令重排，CPU乱序执行所带来的问题</p></blockquote><h4 id="6、this与super的区别"><a href="#6、this与super的区别" class="headerlink" title="6、this与super的区别"></a>6、this与super的区别</h4><ul><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h3 id="JVM常见面试题"><a href="#JVM常见面试题" class="headerlink" title="JVM常见面试题"></a><code>JVM常见面试题</code></h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a><code>JVM</code>内存结构</h4><p>内存分布图 </p><p>浅谈几大内存结构 </p><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（<code>Methed Area</code>）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><p><code>JVM</code>内存结构图</p><p><img src="/2021/07/05/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%8F%90%E5%8F%96/image-20210706083832326.png" alt="image-20210706083832326"></p><p>创建对象流程</p><p>判断该对象对应的类是否以及加载过 </p><p>为对象分配内存</p><ol><li><p>如果内存规整的话采用指针碰撞创建内存 </p></li><li><p>如果内存不规整的话</p><ol><li>虚拟机需要维护一个列表 </li><li>空闲列表分配</li></ol></li><li><p>处理并发安全问题</p><ol><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配一块TLAB</li></ol></li><li><p>初始化分配的空间 - 所有的属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p></li><li><p>设置对象的对象头</p></li><li><p>执行inti方法进行初始化</p></li></ol><p>什么是指针碰撞 ？？</p><blockquote><p>如果是Java堆的内存是规整，即使所有的内存用过的都在一边，没用过的都在另一边。分配内存时将中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成内存分工作</p></blockquote><p>空闲列表？？</p><blockquote><p>如果Java堆的内存是不完整的，则需要有虚拟机维护一个列表来记录那些内存是可以用的，这样在分配的时候可以从列表中查询到足够大的内存空间分配给对象，更新空闲列表</p></blockquote><p>如何解决对象并发安全 ？？</p><blockquote><ol><li><p>对分配的内存空间的动作进行同步处理（采用CAS +失败重试来保障更新操作的原子性）</p></li><li><p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配了一小块内存，称之为本地线程分配缓冲（Thread Local Allocation Buffer, <code>TLAB</code>）哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁。通过设置虚拟机参数：-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</p></li></ol></blockquote><p>浅拷贝和深拷贝 </p><blockquote><p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p><p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p></blockquote><h3 id="Spring常见面试题"><a href="#Spring常见面试题" class="headerlink" title="Spring常见面试题"></a>Spring常见面试题</h3><h4 id="1、SpringIOC"><a href="#1、SpringIOC" class="headerlink" title="1、SpringIOC"></a>1、<code>SpringIOC</code></h4><p><code>IOC</code>控制反转, 将创建对象的操作交予Spring管理，</p><blockquote><p>对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p></blockquote><p><code>IOC</code>有什么作用</p><p>管理对象的创建和依赖关系的维护。对象创建并不是一件简单事，当对象关系复杂的时，如果依赖关系需要程序员来维护的话，那是相当头疼的</p><p>解耦，由容器去维护具体的对象</p><p>托管了类的生产过程，比如我们需要在类的生产过程中做一些处理，最直接的例子就是代理，如果由容器可以把这部分处理交予容器，应用程序无需关心类时如何完成代理的</p><p><code>IOC</code>有什么功能</p><ul><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li></ul><h4 id="2、SpringAOP"><a href="#2、SpringAOP" class="headerlink" title="2、SpringAOP"></a>2、<code>SpringAOP</code></h4>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis6Learn</title>
    <link href="/2021/06/25/Redis6Learn/"/>
    <url>/2021/06/25/Redis6Learn/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>redis 中的字符串value最多可以是512m</p><p>关于字符串的操作命令 </p><blockquote><p>set <key>  value </key></p><p>get <key> </key></p><p>append <key>  value  ： 追加 </key></p><p>strlen <key>  ： 获取key长度</key></p><p>setnx  <key>   <value>  :  只有当key不存在时    设置key的值</value></key></p><p>incr <key>   将key中存储的数字+1    只能对数字值操作，如果为空，新增值为1 （是原子性操作 ）</key></p><p>decr  <key>  将key 中的数字 - 1</key></p></blockquote><p>多个key 和 value的操作 </p><blockquote><p> mset <key> <value> <key> <value>  </value></key></value></key></p><p>原子性操作</p><p>msetnx  <key> <value> <key> <value>   : 如果key中有之前存在过的  则不会设置成功</value></key></value></key></p><p>setrange   <key>    <start>   <value> :   设置key 从start开始往后的所有值都是value</value></start></key></p><p>setex <key> <seconds>  <value>  :    设置过期时间   </value></seconds></key></p></blockquote><blockquote><p>mget <key> <value> <key> <value> </value></key></value></key></p><p>getrange <key>  start  end  :  设置起始位置  类似于SubString    包含 start 和 end </key></p><p>getset <key>  <value>  : 以新值换旧值</value></key></p></blockquote><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特点 ： 单键多值</p><p>底层是一个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能较差</p><p>常用命令 ：</p><blockquote><p>lpush / rpush <key>  <value>  <value>   <value>  </value></value></value></key></p><p> 一个key 多个value  从左边或者是右边插入一个或者是多个值 </p></blockquote><blockquote><p>ipop/rpop <key>  ： 从左边、右边弹出一个值， 值在键在，值亡键亡 </key></p></blockquote><blockquote><p>rpoplpush <key>  <key1>  ： 从 key 右边弹出一个值  放入key1的左边 </key1></key></p></blockquote><blockquote><p>lrange  <key>  <start>  <end>  ： 从左到右，按照下标获得元素</end></start></key></p><p>lrange  <key>   0   -1 ：  遍历所有的值</key></p><p>lindex   <key>  <index>  :   从左到右 ， 去key中下标index中的值</index></key></p><p>llen  <key>  ： 获取key长度</key></p></blockquote><p><img src="/2021/06/25/Redis6Learn/image-20210625211038918.png" alt="image-20210625211038918"></p><p>注意  before 是在前面的意思    图中有失误</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>特点 ： 无需，不存储重复数据 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; sadd k1 v1 v2 v3    : 往<span class="hljs-built_in">set</span>集合添加值 <br>(<span class="hljs-built_in">integer</span>) 3     <br>192.168.1.57:6379&gt; smembers k1    : 遍历<span class="hljs-built_in">set</span>集合<br>1) <span class="hljs-string">&quot;v2&quot;</span><br>2) <span class="hljs-string">&quot;v1&quot;</span><br>3) <span class="hljs-string">&quot;v3&quot;</span><br>192.168.1.57:6379&gt; sismember k1 v1    : 检测key里面有没有v1<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; sismember k1 v3<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; scard k1    : 获取<span class="hljs-built_in">set</span>集合长度<br>(<span class="hljs-built_in">integer</span>) 3<br>192.168.1.57:6379&gt; srem k1 v1    :  指定value 弹出 key<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; smembers k1  <br>1) <span class="hljs-string">&quot;v2&quot;</span><br>2) <span class="hljs-string">&quot;v3&quot;</span><br>192.168.1.57:6379&gt; spop k1   : 随机弹出一个数据  <br><span class="hljs-string">&quot;v3&quot;</span><br>192.168.1.57:6379&gt; srandmember k1 2    : 从key中随机取俩个值  不会删除数据<br><br>192.168.1.57:6379&gt; smove k1 k2 v2<br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; smembers k2<br>1) <span class="hljs-string">&quot;v2&quot;</span><br>2) <span class="hljs-string">&quot;4&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>4) <span class="hljs-string">&quot;1&quot;</span><br>192.168.1.57:6379&gt; sinter k1 k2  : 取俩个结合交集<br>(empty list or <span class="hljs-built_in">set</span>)<br>192.168.1.57:6379&gt;  sunion k1 k2  : 取俩个集合并集<br>1) <span class="hljs-string">&quot;4&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br>4) <span class="hljs-string">&quot;3&quot;</span><br>192.168.1.57:6379&gt; sdiff k1 k2  : 取俩个集合差集<br>(empty list or <span class="hljs-built_in">set</span>)<br></code></pre></td></tr></table></figure><p>底层数据结构，就是用hash表去除value字段 用filed做value</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>特点 ： key  -&gt; value</p><p>关系映射图 ： </p><p><img src="/2021/06/25/Redis6Learn/image-20210625215237439.png" alt="image-20210625215237439"></p><p>常用命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; hset user:1001 id 1  <span class="hljs-comment"># 创建hash &lt;key&gt;  field value </span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; hset user:1001 name zhangshan  <span class="hljs-comment"># 添加 属性 </span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt; hget user:1001 id   <span class="hljs-comment"># 通过filed 获取key中的value</span><br><span class="hljs-string">&quot;1&quot;</span><br>192.168.1.57:6379&gt; hmset user:1001 age 10 danger 12 <span class="hljs-comment"># 批量添加filed 和 value </span><br>OK<br>192.168.1.57:6379&gt; hexists user:1001 id <span class="hljs-comment"># 判断key中是否有这个属性</span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt;<br>192.168.1.57:6379&gt; hkeys user:1001 <span class="hljs-comment"># 获取key中所有的属性 </span><br>1) <span class="hljs-string">&quot;id&quot;</span><br>2) <span class="hljs-string">&quot;name&quot;</span><br>3) <span class="hljs-string">&quot;age&quot;</span><br>4) <span class="hljs-string">&quot;danger&quot;</span><br>192.168.1.57:6379&gt; hvals user:1001  <span class="hljs-comment"># 获取key中所有的值</span><br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;zhangshan&quot;</span><br>3) <span class="hljs-string">&quot;10&quot;</span><br>4) <span class="hljs-string">&quot;12&quot;</span><br>192.168.1.57:6379&gt; hincrby user:1001 age 2 <span class="hljs-comment"># 获取key中filed 属性加 2 </span><br>(<span class="hljs-built_in">integer</span>) 12<br>192.168.1.57:6379&gt;  hsetnx user:1001 age 222 <span class="hljs-comment"># 如果key中有这个filed则添加失败否则成功</span><br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>底层数据结构</p><h2 id="2、常用命令"><a href="#2、常用命令" class="headerlink" title="2、常用命令"></a>2、常用命令</h2><p>创建key :  set  key  value</p><p>查看所有key  : keys *</p><p>判断key是否存在 ： exists key</p><p>查看key类型 ： type key </p><p>删除key : del  key</p><p>阻塞删除key :  unlink  key  </p><p>设置key的过期时间  : expire  key </p><p>查看key的剩余时间 ： ttl   key    -1表示永不过期   -2 表示已经过期 </p><p>切换数据库   ： select   index   </p><p>查看数据库中的key 数量 ： dbsize</p><h2 id="3、Redis发布和订阅"><a href="#3、Redis发布和订阅" class="headerlink" title="3、Redis发布和订阅"></a>3、Redis发布和订阅</h2><h3 id="3-1、-什么是发布和订阅"><a href="#3-1、-什么是发布和订阅" class="headerlink" title="3.1、 什么是发布和订阅"></a>3.1、 什么是发布和订阅</h3><blockquote><p>是一种消息通信模式： 发布者发送消息，订阅者接收消息</p></blockquote><h3 id="3-2、-Redis发布和订阅"><a href="#3-2、-Redis发布和订阅" class="headerlink" title="3.2、 Redis发布和订阅"></a>3.2、 Redis发布和订阅</h3><p>订阅端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; subscribe channel  <span class="hljs-comment"># 订阅频道命令 </span><br>Reading messages... (press Ctrl-C to quit)<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;channel&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br>1) <span class="hljs-string">&quot;message&quot;</span><br>2) <span class="hljs-string">&quot;channel&quot;</span><br>3) <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>发布端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.57:6379&gt; publish channel <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment"># 向频道中发送信息</span><br>(<span class="hljs-built_in">integer</span>) 1<br>192.168.1.57:6379&gt;<br></code></pre></td></tr></table></figure><h2 id="4、Redis6-新数据类型"><a href="#4、Redis6-新数据类型" class="headerlink" title="4、Redis6 新数据类型"></a>4、Redis6 新数据类型</h2><h4 id="4-1、bitmaps"><a href="#4-1、bitmaps" class="headerlink" title="4.1、bitmaps"></a>4.1、bitmaps</h4><p>什么是bitmaps</p><blockquote><p>Bitmaps并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M。</p></blockquote><blockquote><p>字节操作可以分为两类：恒定时间的单个字节操作如将一个字节设置为1或者0、或者获取一个字节的值，和批量字节操作如在给定的字节范围内计算设置字节的数量。</p></blockquote><p> <img src="/2021/06/25/Redis6Learn/image-20210626124901895.png" alt="image-20210626124901895"></p><p>Redis中bitmaps的常用操作<br>基本使用<br>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p><ol><li>setbit key offset value</li><li>getbit key offset</li></ol><ol start="3"><li><p>bitcount key [start end]</p></li><li><p>bitpos key targetBit [start] [end] （起始版本：2.8.7）</p></li></ol><p>计算位图指定范围（start到end，单位为字节，如果不指定就是获取全部）第一个偏移量对应的值等于targetBit的位置。</p><ol start="5"><li>bitop and|or|not|xor destkey key [key…]</li></ol><p>做多个bitmap的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存到destkey中。</p><p>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p><p>6.魔术指令 bitfield</p><p>前文我们设置 (setbit) 和获取 (getbit) 指定位的值都是单个位的，如果要一次操作多个位，就必须使用管道来处理。</p><p>不过 Redis 的 3.2 版本以后新增了一个功能强大的指令，有了这条指令，不用管道也可以一次进行多个位的操作。</p><p>bitfield 有三个子指令，分别是 get/set/incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个</p><h4 id="4-2、HyperLogLog"><a href="#4-2、HyperLogLog" class="headerlink" title="4.2、HyperLogLog"></a>4.2、HyperLogLog</h4><p>用途： 用来做基数统计的算法</p><p>常用命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; pfadd program &quot;java&quot;  # 创建HyperLogLog <br>(integer) 1<br>127.0.0.1:6379&gt; pfadd program &quot;php&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; pfadd program &quot;java&quot;  # 如果有相同的则返回0  成功加入返回1<br>(integer) 0<br>127.0.0.1:6379&gt; pfadd program &quot;spring&quot; &quot;mysql&quot; # 添加多个value  <br>(integer) 1<br>127.0.0.1:6379&gt; pfcount program3  # 统计个数<br>(integer) 7<br>127.0.0.1:6379&gt; pfmerge program3 program program1  # 将俩个合并到一个里面去<br>OK<br></code></pre></td></tr></table></figure><h4 id="4-3、Geospatial"><a href="#4-3、Geospatial" class="headerlink" title="4.3、Geospatial"></a>4.3、Geospatial</h4><p>提供了经纬度，查询，范围查询，距离查询，经纬度 hash等常见操作</p><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; geoadd china 121.48 41.23 shanghai #  创建geo数据类型<br>(integer) 1<br>127.0.0.1:6379&gt; geopos china shanghai   #  获取<br>1) 1) &quot;121.48000091314315796&quot;<br>   2) &quot;41.23000123535113914&quot;<br>127.0.0.1:6379&gt; geoadd china 106.50 29.53 beijng<br>(integer) 1<br>127.0.0.1:6379&gt; geodist china beijng shanghai  km # 两个地方相隔<br>&quot;1875.9716&quot;<br>127.0.0.1:6379&gt; georadius china 110 30 1000 km # 查找周围范围的value<br>1) &quot;beijng&quot;<br><br></code></pre></td></tr></table></figure><h2 id="5、Redis事务"><a href="#5、Redis事务" class="headerlink" title="5、Redis事务"></a>5、Redis事务</h2><h4 id="5-1、redis事务是什么"><a href="#5-1、redis事务是什么" class="headerlink" title="5.1、redis事务是什么"></a>5.1、redis事务是什么</h4><blockquote><p>是一个隔离操作：事务中的所有命令都会序列化，按照顺序执行。事务在执行过程中，不会被其他的客户端发来的请求所打断</p><p>作用：串连多个操作 防止别的命令进行插队</p></blockquote><h4 id="5-2、-事务怎么样使用"><a href="#5-2、-事务怎么样使用" class="headerlink" title="5.2、 事务怎么样使用"></a>5.2、 事务怎么样使用</h4><p>Redis 事务命令   ： </p><p>multi (开启事务) 进入组队模式  </p><p>exec  (执行命令)  执行队列中的命令</p><p>discard (消除命令) ：将队列中的命令清空 关闭事务</p><p><img src="/2021/06/25/Redis6Learn/image-20210626151933051.png" alt="image-20210626151933051"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi  # 开启redis事务 <br>OK<br>127.0.0.1:6379(TX)&gt; set key anzhen  # 将命令放入队列中<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k1 zimu<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec  # 将队列的命令一起执行 <br>1) OK<br>2) OK<br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure><p>几点注意事项 ： </p><blockquote><p>如果是在组队阶段，命令出现了错误时，所有命令都不会执行 </p><p>如果时在执行阶段，出现了错误时，会继续执行下一条命令</p></blockquote><h4 id="5-3、Redis事务锁机制"><a href="#5-3、Redis事务锁机制" class="headerlink" title="5.3、Redis事务锁机制"></a>5.3、Redis事务锁机制</h4><p>解决事务冲突时用到什么锁  ？？</p><ul><li><p>悲观锁</p><ul><li><blockquote><p>悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></blockquote><p>缺点  ——&gt;   效率太低 ：只能一个线程进行操作 </p></li></ul></li><li><p>乐观锁</p><ul><li><blockquote><p>进行操作时，给线程数据加上字段 version，通过版本号判断数据有没有被修改过</p></blockquote></li></ul></li></ul><h4 id="5-4、Redis事务三特性"><a href="#5-4、Redis事务三特性" class="headerlink" title="5.4、Redis事务三特性"></a>5.4、Redis事务三特性</h4><ul><li>不保证原子性 <ul><li>事务中，如果出现错误不会发生回滚 ，而是执行下一条命令</li></ul></li><li>没有隔离级别的概念<ul><li>队列中的命令没有提交之前都不会实际执行，因为事务提交前任何命令都不会实际执行</li></ul></li><li>单独的隔离操作<ul><li>事务中所有的命令都会序列化，按照顺序执行。事务执行的过程中，不会被其他客户端发来的命令请求所打断</li></ul></li></ul><h2 id="6、Redis-主从复制"><a href="#6、Redis-主从复制" class="headerlink" title="6、Redis 主从复制"></a>6、Redis 主从复制</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">port:26379<br>daemonize yes<br>sentinel<span class="hljs-built_in"> monitor </span>mymaster<br></code></pre></td></tr></table></figure><p>主从复制特点以及 ： </p><p>读写分离 ， 主服务器用来写入， 从服务器用来读取</p><p>容灾快速回复： 如果从服务器挂了的话，可以切换到另一台从服务器</p><p>搭建详情: 查看此博客 <a href="https://www.cnblogs.com/kingyifan/p/11721422.html#!comments">https://www.cnblogs.com/kingyifan/p/11721422.html#!comments</a></p><p>redis 集群搭建： <a href="https://www.cnblogs.com/niceyoo/p/14118146.html">https://www.cnblogs.com/niceyoo/p/14118146.html</a> 查看此博客 </p><p>声明  所有的搭建都是在docker 上搭建的</p><h2 id="7、缓存的三大问题"><a href="#7、缓存的三大问题" class="headerlink" title="7、缓存的三大问题"></a>7、缓存的三大问题</h2><h3 id="7-1、缓存穿透"><a href="#7-1、缓存穿透" class="headerlink" title="7.1、缓存穿透"></a>7.1、缓存穿透</h3><p>是什么</p><blockquote><p> 缓存的命中率减低，导致请求绝大部分直接走数据库，造成数据库压力过大甚至宕机</p></blockquote><p><img src="/2021/06/25/Redis6Learn/image-20210627172316133.png" alt="image-20210627172316133"></p><p> <img src="/2021/06/25/Redis6Learn/image-20210627172541377.png" alt="image-20210627172541377"></p><h3 id="7-2、缓存雪崩"><a href="#7-2、缓存雪崩" class="headerlink" title="7.2、缓存雪崩"></a>7.2、缓存雪崩</h3><p>是什么</p><blockquote><p>极少时间段，查询大量key的集中过期情况</p></blockquote><p>解决方案 ：</p><ul><li><p>构建多级缓存架构： nginx(缓存） + redis(缓存) + ehcache(其他缓存)</p></li><li><p>使用锁或者是队列 </p><ul><li>使用锁或者是队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适合高并发情况</li></ul></li><li><p>设置过期标志更新缓存：</p><ul><li>记录缓存数据是否已过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存</li></ul></li><li><p>将缓存失效时间分散开：</p><ul><li>我们可以在原来失效时间的基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，很难引发集体失效的事件。</li></ul></li></ul><h3 id="7-3、缓存击穿"><a href="#7-3、缓存击穿" class="headerlink" title="7.3、缓存击穿"></a>7.3、缓存击穿</h3><p>是什么</p><blockquote><p>某一个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。</p></blockquote><p>解决方案： </p><ul><li><p>预先设置热门数据 ：     在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key长</p></li><li><p>实时调整：现场监控那些数据热门，实时增加key的过期时长</p></li><li><p>使用锁 ：</p></li></ul><h2 id="8、Redis多线程"><a href="#8、Redis多线程" class="headerlink" title="8、Redis多线程"></a>8、Redis多线程</h2><p>Redis并不是多线程？ </p><blockquote><p>Redis是多路IO复用，执行命令还是单线程，</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity</title>
    <link href="/2021/06/18/SpringSecurity/"/>
    <url>/2021/06/18/SpringSecurity/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="1、-是什么？"><a href="#1、-是什么？" class="headerlink" title="1、 是什么？"></a>1、 是什么？</h2><p>看官网<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/">Spring Security Reference</a></p><h2 id="2、项目搭建"><a href="#2、项目搭建" class="headerlink" title="2、项目搭建"></a>2、项目搭建</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        spring security 安全管理框架--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动成功后 ， 后台日志会生成一串安全密码</p><p><img src="/2021/06/18/SpringSecurity/image-20210618201857845.png" alt="image-20210618201857845"></p><p>前台访问登录请求则是使用的Security自带的登录页面</p><img src="/2021/06/18/SpringSecurity/image-20210618202018351.png" alt="image-20210618202018351" style="zoom:33%;"> <p>账号使用的是 user  密码是 日志的密码</p><h4 id="SpringSecurity-Oauth2"><a href="#SpringSecurity-Oauth2" class="headerlink" title="SpringSecurity   +  Oauth2"></a><code>SpringSecurity</code>   +  Oauth2</h4><blockquote><p>配置 Security 配置器 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启安全控制</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 加密服务</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 关闭csrf防护</span><br>        http.csrf().disable()<br>                .authorizeRequests()<br>                <span class="hljs-comment">// 放行登录和认证</span><br>                .antMatchers(<span class="hljs-string">&quot;/oauth/**&quot;</span>,<span class="hljs-string">&quot;/login/**&quot;</span>, <span class="hljs-string">&quot;logout/**&quot;</span>)<br>                .permitAll()<br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .formLogin()<br>                .permitAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置<code>OAuth2</code> 的资源服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableResourceServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourcesServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// </span><br>        http.authorizeRequests()<br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .requestMatchers()<br>                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置<code>OAuth2</code> 的认证服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启授权服务器</span><br><span class="hljs-meta">@EnableAuthorizationServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;<br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * clients : 客户端详细信息服务配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        clients.inMemory()<br>                <span class="hljs-comment">// client id  </span><br>                .withClient(<span class="hljs-string">&quot;admin&quot;</span>) <br>                <span class="hljs-comment">// 密钥</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123123&quot;</span>))<br>                <span class="hljs-comment">// 设置重定向路径</span><br>                .redirectUris(<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>)<br>                <span class="hljs-comment">// 配置申请授权范围</span><br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br>                <span class="hljs-comment">// 设置授权类型  授权码模式 </span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;authorization_code&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>授权码模式  访问流程</p><ol><li><p>浏览器访问<a href="http://localhost:2313/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=https://www.bilibili.com&amp;scope=all">http://localhost:2313/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=https://www.bilibili.com&amp;scope=all</a></p></li><li><p>这条<code>url</code>的 的参数  必须和授权服务一致 否则会出现错误 </p><ol><li><blockquote><p>response_type=code </p><p>client_id=admin</p><p>redirect_uri=<a href="https://www.bilibili.com/">https://www.bilibili.com</a></p><p>scope=all</p></blockquote></li></ol></li></ol><p><img src="/2021/06/18/SpringSecurity/image-20210619163841308.png" alt="image-20210619163841308"></p><p>输入之后自动跳转 security的登录页面 </p><p><img src="/2021/06/18/SpringSecurity/image-20210619164144176.png" alt="image-20210619164144176"></p><p>code 就是授权码 </p><p><img src="/2021/06/18/SpringSecurity/image-20210619164205506.png" alt="image-20210619164205506"></p><p>这里的账号密码就是授权服务器的账号和密码<img src="/2021/06/18/SpringSecurity/image-20210619164255414.png" alt="image-20210619164255414"></p><p>这个里面的字段和<strong>授权服务器</strong>相同, 然后授权服务器发送token </p><p>访问login 并带上token </p><p><img src="/2021/06/18/SpringSecurity/image-20210619165450033.png" alt="image-20210619165450033"></p><p>访问接口带上token 即可返回正确数据</p><h4 id="使用Password模式进行认证"><a href="#使用Password模式进行认证" class="headerlink" title="使用Password模式进行认证"></a>使用Password模式进行认证</h4><p>增加一个方法  修改<code>authorizedGrantTypes</code> 类型为password</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启授权服务器</span><br><span class="hljs-meta">@EnableAuthorizationServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 密码模式需要使用的</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endpoints</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     * 将密码传输给授权服务器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//</span><br>        endpoints.authenticationManager(authenticationManager)<br>                .userDetailsService(userService);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * clients : 客户端详细信息服务配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        clients.inMemory()<br>                <span class="hljs-comment">// client id</span><br>                .withClient(<span class="hljs-string">&quot;admin&quot;</span>)<br>                <span class="hljs-comment">// 密钥</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123123&quot;</span>))<br>                <span class="hljs-comment">// 设置重定向路径</span><br>                .redirectUris(<span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>)<br>                <span class="hljs-comment">// 配置申请授权范围</span><br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br>                <span class="hljs-comment">// 设置授权类型 使用授权码的方式</span><br>                <span class="hljs-comment">//.authorizedGrantTypes(&quot;authorization_code&quot;);</span><br>                <span class="hljs-comment">// 使用密码的方式</span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为需要注入<code>AuthenticationManager</code>所以需要往<code>SecurityConfig</code>里面配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-comment">// 开启安全控制</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 加密服务</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>    &#125;<br><br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">super</span>.authenticationManager();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 关闭csrf防护</span><br>        http.csrf().disable()<br>                .authorizeRequests()<br>                <span class="hljs-comment">// 放行登录和认证</span><br>                .antMatchers(<span class="hljs-string">&quot;/oauth/**&quot;</span>,<span class="hljs-string">&quot;/login/**&quot;</span>, <span class="hljs-string">&quot;logout/**&quot;</span>)<br>                .permitAll()<br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .formLogin()<br>                .permitAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mallGateway</title>
    <link href="/2021/06/17/mallGateway/"/>
    <url>/2021/06/17/mallGateway/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是服务网关-？"><a href="#什么是服务网关-？" class="headerlink" title="什么是服务网关 ？"></a>什么是服务网关 ？</h2><ul><li><code>API </code>    是一个服务器，是系统统一堆外开放的入口，网关封装了内部架构，为每个客户端提供了一个定制的<code>API</code>。<code>API</code>网关方式的核心就是：所有的客户端和服务端通过统一的网关接入微服务，在网关层处理所有非业务功能</li></ul><p>优缺点 ：</p><ul><li>通过聚合接口使得服务对调用者透明，  降低客户端和服务端的耦合度。</li><li>聚合后台服务，节省流量，提高性能，提升用户体验</li><li>提供安全，流量控制，认证，过滤，监控，计费的API管理</li></ul><h2 id="为什么要有服务网关"><a href="#为什么要有服务网关" class="headerlink" title="为什么要有服务网关"></a>为什么要有服务网关</h2><p>单机应用  ： 浏览器发送请求给应用，应用查询数据库原路返回服务器，单机应用只有一个服务所以是用不上网关的</p><p><img src="/2021/06/17/mallGateway/image-20210617145224101.png" alt="image-20210617145224101"></p><p>微服务应用 ： </p><h3 id="网关解决了什么问题"><a href="#网关解决了什么问题" class="headerlink" title="网关解决了什么问题"></a>网关解决了什么问题</h3><ul><li>统一接入</li><li>认证授权</li><li>流量控制</li><li>协议适配  </li></ul><h3 id="Gateway-实现API网关"><a href="#Gateway-实现API网关" class="headerlink" title="Gateway 实现API网关"></a>Gateway 实现<code>API</code>网关</h3><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li><pre><code> **路由（router）** :  包括`id ` ,   目标`uri` ,    一组断言和一组过滤器组成。如果断言路由为真，则说明请求的Uri和配置相符</code></pre></li><li>​    <strong>断言（Predicate）</strong>：检验</li><li>​    <strong>过滤 （Filter）</strong>：</li></ul><h5 id="1、-路由的配置规则-："><a href="#1、-路由的配置规则-：" class="headerlink" title="1、 路由的配置规则 ："></a>1、 路由的配置规则 ：</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment">#配置路由路径</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-auth</span>   <span class="hljs-comment">#  路由id </span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-auth</span>   <span class="hljs-comment"># 目标微服务地址</span><br>          <span class="hljs-attr">predicates:</span>    <span class="hljs-comment">#  断言  检验请求地址是否和path相符  判断条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-auth/**</span>   <span class="hljs-comment">#  根据请求路进行跳转</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span> <br>            <span class="hljs-comment"># 根据指定时间前进行判断</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span><br>            <span class="hljs-comment"># 根据指定时间后进行判断</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="hljs-number">2017-01-21T17:42:47.789-07:00</span>[<span class="hljs-string">America/Denver</span>]<br>            <span class="hljs-comment"># 根据指定时间内进行判断</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=chocolate,</span> <span class="hljs-string">ch.p</span><br>            <span class="hljs-comment"># 根据cookie 进行判断</span><br>            <br></code></pre></td></tr></table></figure><h4 id="2、动态路由规则-："><a href="#2、动态路由规则-：" class="headerlink" title="2、动态路由规则 ："></a>2、动态路由规则 ：</h4><p>动态获取微服务地址： </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span>   <br>          <span class="hljs-comment"># 通过开启与服务发现进行结合，通过serviceId转发到具体服务实例。</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">lower-case-service-id:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#使用小写service-id</span><br></code></pre></td></tr></table></figure><p>3、 Path过滤器</p><p>4、 全局过滤器 <code>Global Filter</code> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">全局过滤器不需要在配置文件中配置，作用在所有的路由上，最终通过   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker搭建笔记</title>
    <link href="/2021/06/16/docker%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/16/docker%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="docker-搭建-RibbitMQ"><a href="#docker-搭建-RibbitMQ" class="headerlink" title="docker 搭建 RibbitMQ"></a>docker 搭建 RibbitMQ</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 拉取镜像</span><br>docker pull rabbitmq<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看所有镜像</span><br>docker images<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 创建容器</span> <br>docker run -d --name rabbitmq<br>-p 5672:5672<br>-p 15672:15672<br>-v `pwd`/data:/var/lib/rabbitmq<br>--hostname myRabbit <br>-e RABBITMQ_DEFAULT_VHOST=my_vhost  <br>-e RABBITMQ_DEFAULT_USER=admin <br>-e RABBITMQ_DEFAULT_PASS=admin rabbitmq<br><br><br>rabbitmq 是指image name<br>-d 后台运行容器；<br>--name 指定容器名；<br>-p 指定服务运行的端口（5672：应用访问端口；15672：控制台Web端口号）；<br>-v 映射目录或文件；<br>--hostname 主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；<br>-e 指定环境变量；（<br>RABBITMQ_DEFAULT_VHOST：默认虚拟机名；<br>RABBITMQ_DEFAULT_USER：默认的用户名；<br>RABBITMQ_DEFAULT_PASS：默认用户名的密码）<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看运行容器</span> <br>docker ps <br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 启动管理程序</span> <br><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it【交互式方式执行命令】容器id/容器name 命令</span><br>docker exec -it rabbitmq  rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><h2 id="Docker搭建Redis6"><a href="#Docker搭建Redis6" class="headerlink" title="Docker搭建Redis6"></a>Docker搭建Redis6</h2><h4 id="1、-拉取镜像"><a href="#1、-拉取镜像" class="headerlink" title="1、 拉取镜像"></a>1、 拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull redis<br></code></pre></td></tr></table></figure><h4 id="2、下载配置文件"><a href="#2、下载配置文件" class="headerlink" title="2、下载配置文件"></a>2、下载配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建本地文件映射 </span><br><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span><br>mkdir redis<br><span class="hljs-built_in">cd</span> redis<br><span class="hljs-comment"># 下载配置文件</span><br>wget http://download.redis.io/redis-stable/redis.conf<br><br><span class="hljs-comment"># 修改配置文件</span><br><span class="hljs-comment"># 关闭ip绑定 </span><br><span class="hljs-built_in">bind</span> 127.0.0.1 -::1 注释掉这行<br></code></pre></td></tr></table></figure><p><strong>关闭保护模式（默认是yes）</strong></p><p><img src="/2021/06/16/docker%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/image-20210622084518055.png" alt="image-20210622084518055"></p><h4 id="3、-创建容器"><a href="#3、-创建容器" class="headerlink" title="3、 创建容器"></a>3、 创建容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 6379:6379  -v <span class="hljs-variable">$PWD</span>/data:/data -v <span class="hljs-variable">$PWD</span>/redis.conf:/etc/redis/redis.conf --privileged=<span class="hljs-literal">true</span> --name mredis -d redis redis-server /etc/redis/redis.conf<br><br><br><br><br>创建哨兵模式的redis <br>docker run -p 6379:6379 -p 26379:26379   -v <span class="hljs-variable">$PWD</span>/data:/data -v <span class="hljs-variable">$PWD</span>/redis.conf:/etc/redis/redis.conf --privileged=<span class="hljs-literal">true</span> --name sentinelredis -d redis redis-server /etc/redis/redis.conf<br><br><span class="hljs-comment"># 进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> -it redis /bin/bash<br><br><span class="hljs-comment"># 更新依赖  安装vim</span><br>apt-get update<br>apt-get install -y vim<br></code></pre></td></tr></table></figure><h4 id="4、查看运行状态"><a href="#4、查看运行状态" class="headerlink" title="4、查看运行状态"></a>4、查看运行状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><h4 id="5、-进入本地客户端"><a href="#5、-进入本地客户端" class="headerlink" title="5、 进入本地客户端"></a>5、 进入本地客户端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mredis(与创建的容器名相对应) redis-cli<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mall学习笔记</title>
    <link href="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1、项目结构分析"><a href="#1、项目结构分析" class="headerlink" title="1、项目结构分析"></a>1、项目结构分析</h2><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210616131124608.png" alt="image-20210616131124608"> </p><p><code>mall-admin</code> ： 主业务模块</p><p><code>mall-auth</code> ： 用户认证模块</p><p><code>mall-common </code>：公共模块</p><p><code>mall-monitor </code>：监控模块</p><p><code>mall-portal </code>： 前端用户接口</p><p><code>mall-search</code> ： 搜索模块</p><p><code>mall-mbg</code> ： Mapper配置文件和接口</p><p><code>mall-gateway</code> ：网关模块 </p><p>所有的请求都走网关进入先阅读<code>gateway</code>和<code>auth</code></p><h3 id="Gateway模块"><a href="#Gateway模块" class="headerlink" title="Gateway模块"></a>Gateway模块</h3><h4 id="1、先查看配置文件"><a href="#1、先查看配置文件" class="headerlink" title="1、先查看配置文件"></a>1、先查看配置文件</h4><h5 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a><strong><code>application.yaml</code></strong></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8201</span><br>  <br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">lower-case-service-id:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#使用小写service-id</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment">#配置路由路径</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-auth</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-auth</span><br>          <span class="hljs-attr">predicates:</span>  <span class="hljs-comment"># 使用路径断言</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-auth/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-admin</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-admin</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-admin/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span>    <br>            <span class="hljs-comment"># 分割请求路径  默认前端请求路径都带mall-admin 将mall-admin分割掉</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-portal</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-portal</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-portal/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-search</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-search</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-search/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">mall-demo</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://mall-demo</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/mall-demo/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">oauth2:</span><br>      <span class="hljs-attr">resourceserver:</span><br>        <span class="hljs-attr">jwt:</span><br>          <span class="hljs-attr">jwk-set-uri:</span> <span class="hljs-string">&#x27;http://localhost:8201/mall-auth/rsa/publicKey&#x27;</span> <span class="hljs-comment">#配置RSA的公钥访问地址</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-comment">#host: 192.168.1.57</span><br>    <span class="hljs-attr">password:</span><br><span class="hljs-attr">secure:</span><br>  <span class="hljs-attr">ignore:</span><br>    <span class="hljs-attr">urls:</span> <span class="hljs-comment">#配置白名单路径</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/doc.html&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/swagger-resources/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/swagger/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/v2/api-docs&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.js&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.css&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.png&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/**/*.ico&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/webjars/springfox-swagger-ui/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/actuator/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-auth/oauth/token&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-auth/rsa/publicKey&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-search/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/sso/login&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/sso/register&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/sso/getAuthCode&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/home/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/product/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-portal/brand/**&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-admin/admin/login&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-admin/admin/register&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/mall-admin/minio/upload&quot;</span><br><span class="hljs-attr">management:</span> <span class="hljs-comment">#开启SpringBoot Admin的监控</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>注意 ：</p><p><code>bootstrap.yml</code>（<code>bootstrap.properties</code>）先加载<br><code>application.yml</code>（<code>application.properties</code>）后加载<br><code>bootstrap.yml</code> 用于应用程序上下文的引导阶段。<br><code>bootstrap.yml</code> 由父Spring<code> ApplicationContext</code>加载。</p><h5 id="bootstrap-yaml"><a href="#bootstrap-yaml" class="headerlink" title="bootstrap.yaml"></a><strong><code>bootstrap.yaml</code></strong></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>  <span class="hljs-comment"># 配置的是dev环境</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">application:</span><br>  <span class="hljs-comment"># 配置应用名  用于微服务注册</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-gateway</span><br></code></pre></td></tr></table></figure><h5 id="bootstrap-dev-yaml-开发环境"><a href="#bootstrap-dev-yaml-开发环境" class="headerlink" title="bootstrap-dev.yaml(开发环境)"></a><strong><code>bootstrap-dev.yaml</code></strong>(开发环境)</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>    <span class="hljs-comment"># 配置服务发现</span><br>      <span class="hljs-attr">discovery:</span><br>      <span class="hljs-comment"># 配置nacos 地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>      <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 配置配置地址 </span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span>  <span class="hljs-comment"># 配置配置文件地址</span><br></code></pre></td></tr></table></figure><p>运行网关</p><p>因为Cookie 不能跨域访问， 配置<strong>全局的跨域器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;加载全局跨域配置&quot;</span>);<br>        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();<br>        <span class="hljs-comment">// 允许任何方式访问</span><br>        config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 允许任何来源的请求访问</span><br>        config.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 允许任何请求头进行访问</span><br>        config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 设置是否允许发送cookie信息</span><br>        config.setAllowCredentials(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 为Url配置映射路径</span><br>        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource(<span class="hljs-keyword">new</span> PathPatternParser());<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>        <span class="hljs-comment">// 返回重新定义的配置器</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsWebFilter(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、资源服务器"><a href="#2、资源服务器" class="headerlink" title="2、资源服务器"></a>2、资源服务器</h4><h5 id="资源配置服务"><a href="#资源配置服务" class="headerlink" title="资源配置服务"></a>资源配置服务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebFluxSecurity</span> <br><span class="hljs-comment">// 由于gateway使用的是Flux 协议</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">// 权限管理器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthorizationManager authorizationManager;<br><br>    <span class="hljs-comment">// 权限白名单</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IgnoreUrlsConfig ignoreUrlsConfig;<br><br>    <span class="hljs-comment">// Restful 访问被拒绝处理程序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestfulAccessDeniedHandler restfulAccessDeniedHandler;<br><br>    <span class="hljs-comment">// 休息站点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestAuthenticationEntryPoint restAuthenticationEntryPoint;<br><br>    <span class="hljs-comment">// 白名单路径访问时需要移除JWT请求头</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IgnoreUrlsRemoveJwtFilter ignoreUrlsRemoveJwtFilter;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 安全网页过滤链  这里涉及的是SpringSecurity Web Filter Chain  保护网关</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> http</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SecurityWebFilterChain <span class="hljs-title">springSecurityFilterChain</span><span class="hljs-params">(ServerHttpSecurity http)</span> </span>&#123;<br><br><br>        <span class="hljs-comment">// 加载 jwtAuthenticationConverter  将</span><br>        http.oauth2ResourceServer().jwt()<br>                .jwtAuthenticationConverter(jwtAuthenticationConverter());<br><br>        <span class="hljs-comment">//自定义处理JWT请求头过期或签名错误的结果</span><br>        <span class="hljs-comment">// 身份验证入口  如果没有token 则会直接提出</span><br>        http.oauth2ResourceServer().authenticationEntryPoint(restAuthenticationEntryPoint);<br><br>        <span class="hljs-comment">//对白名单路径，直接移除JWT请求头</span><br>        http.addFilterBefore(ignoreUrlsRemoveJwtFilter,SecurityWebFiltersOrder.AUTHENTICATION);<br><br>        http.authorizeExchange()<br>                <span class="hljs-comment">// 配置网关白名单  将全局网关配置的url获取出来进行匹配</span><br>                .pathMatchers(ArrayUtil.toArray(ignoreUrlsConfig.getUrls(),String.class)).permitAll()<br>                <span class="hljs-comment">// 剩余所有的请求都要走鉴权管理器</span><br>                .anyExchange().access(authorizationManager)<span class="hljs-comment">//鉴权管理器配置</span><br>                .and().exceptionHandling()<br>                <span class="hljs-comment">// 权限不足的接口 走这个返回  没有权限访问时 处理未授权</span><br>                .accessDeniedHandler(restfulAccessDeniedHandler)<br>                 <span class="hljs-comment">// 没有token是 走这个返回  处理未认证</span><br>                .authenticationEntryPoint(restAuthenticationEntryPoint)<br>                .and().csrf().disable();<br>        <span class="hljs-keyword">return</span> http.build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Jwt认证转换器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Converter&lt;Jwt, ? extends Mono&lt;? extends AbstractAuthenticationToken&gt;&gt; jwtAuthenticationConverter() &#123;<br><br>        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = <span class="hljs-keyword">new</span> JwtGrantedAuthoritiesConverter();<br><br>        <span class="hljs-comment">// 设置权限前缀</span><br>        jwtGrantedAuthoritiesConverter.setAuthorityPrefix(AuthConstant.AUTHORITY_PREFIX);<br><br>        <span class="hljs-comment">// 设置权限声明名词</span><br>        jwtGrantedAuthoritiesConverter.setAuthoritiesClaimName(AuthConstant.AUTHORITY_CLAIM_NAME);<br><br>        <span class="hljs-comment">//</span><br>        JwtAuthenticationConverter jwtAuthenticationConverter = <span class="hljs-keyword">new</span> JwtAuthenticationConverter();<br><br>        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在刚才的资源服务器中已经配置了 这个校验器  所以至于要交予spring托管</p><h5 id="权限校验器"><a href="#权限校验器" class="headerlink" title="权限校验器"></a>权限校验器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ReactiveAuthorizationManager</span>&lt;<span class="hljs-title">AuthorizationContext</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IgnoreUrlsConfig ignoreUrlsConfig;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验权限</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mono</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> authorizationContext</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;AuthorizationDecision&gt; <span class="hljs-title">check</span><span class="hljs-params">(Mono&lt;Authentication&gt; mono, AuthorizationContext authorizationContext)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过 request</span><br>        ServerHttpRequest request = authorizationContext.getExchange().getRequest();<br>        <span class="hljs-comment">// 获取uri</span><br>        URI uri = request.getURI();<br>        <span class="hljs-comment">// 创建路径匹配器</span><br>        PathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();<br>        <span class="hljs-comment">//白名单路径直接放行</span><br>        List&lt;String&gt; ignoreUrls = ignoreUrlsConfig.getUrls();<br>        <span class="hljs-keyword">for</span> (String ignoreUrl : ignoreUrls) &#123;<br>            <span class="hljs-keyword">if</span> (pathMatcher.match(ignoreUrl, uri.getPath())) &#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测请求方式</span><br>        <span class="hljs-keyword">if</span>(request.getMethod()==HttpMethod.OPTIONS)&#123;<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>));<br>        &#125;<br>        <span class="hljs-comment">//不同用户体系登录不允许互相访问</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取请求头中的token</span><br>            String token = request.getHeaders().getFirst(AuthConstant.JWT_TOKEN_HEADER);<br>            <span class="hljs-comment">// 检验请求中是否有token</span><br>            <span class="hljs-keyword">if</span>(StrUtil.isEmpty(token))&#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>            &#125;<br>            <span class="hljs-comment">// 去除token前缀</span><br>            String realToken =   token.replace(AuthConstant.JWT_TOKEN_PREFIX, <span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-comment">// 将realToken中的数据进行解密</span><br>            JWSObject jwsObject = JWSObject.parse(realToken);<br>            String userStr = jwsObject.getPayload().toString();<br>            <span class="hljs-comment">// 将token的数据封装到一个bean中</span><br>            UserDto userDto = JSONUtil.toBean(userStr, UserDto.class);<br><br>            <span class="hljs-comment">// 获取请求地址的url进行配对 失败返回false</span><br>            <span class="hljs-keyword">if</span> (AuthConstant.ADMIN_CLIENT_ID.equals(userDto.getClientId()) &amp;&amp;!pathMatcher.match(AuthConstant.ADMIN_URL_PATTERN, uri.getPath())) &#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(AuthConstant.PORTAL_CLIENT_ID.equals(userDto.getClientId()) &amp;&amp; pathMatcher.match(AuthConstant.ADMIN_URL_PATTERN, uri.getPath())) &#123;<br>                <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>        &#125;<br>        <span class="hljs-comment">//非管理端路径直接放行  前端用户接口直接放行</span><br>        <span class="hljs-keyword">if</span> (!pathMatcher.match(AuthConstant.ADMIN_URL_PATTERN, uri.getPath())) &#123;<br>            <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>));<br>        &#125;<br>        <span class="hljs-comment">//管理端路径需校验权限</span><br>        <span class="hljs-comment">//将redis中的数据进行去除之后重新写入map集合中</span><br>        Map&lt;Object, Object&gt; resourceRolesMap =<br>                redisTemplate.opsForHash().entries(AuthConstant.RESOURCE_ROLES_MAP_KEY);<br>        <br>        Iterator&lt;Object&gt; iterator = resourceRolesMap.keySet().iterator();<br>        <br>        <span class="hljs-comment">// </span><br>        List&lt;String&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            String pattern = (String) iterator.next();<br>            <span class="hljs-comment">// 将uri的地址与redis中的地址进行匹配</span><br>            <span class="hljs-keyword">if</span> (pathMatcher.match(pattern, uri.getPath())) &#123;<br>                authorities.addAll(Convert.toList(String.class, resourceRolesMap.get(pattern)));<br>            &#125;<br>        &#125;<br>        authorities = authorities.stream().map(i -&gt; i = AuthConstant.AUTHORITY_PREFIX + i).collect(Collectors.toList());<br>        System.out.println(authorities);<br>        <span class="hljs-comment">//认证通过且角色匹配的用户可访问当前路径</span><br>        <span class="hljs-keyword">return</span> mono<br>                .filter(Authentication::isAuthenticated)<br>                .flatMapIterable(Authentication::getAuthorities)<br>                .map(GrantedAuthority::getAuthority)<br>                .any(authorities::contains)<br>                .map(AuthorizationDecision::<span class="hljs-keyword">new</span>)<br>                .defaultIfEmpty(<span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>start - 9.0</p><p>网关过滤器拦截请求执行顺序 </p><p>白名单拦截器 -&gt; 全局过滤器 -&gt; 安全验证管理器  -&gt; 跳转模块</p><h4 id="3、拦截器"><a href="#3、拦截器" class="headerlink" title="3、拦截器"></a>3、拦截器</h4><h5 id="白名单拦截器"><a href="#白名单拦截器" class="headerlink" title="白名单拦截器"></a>白名单拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IgnoreUrlsRemoveJwtFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebFilter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IgnoreUrlsConfig ignoreUrlsConfig;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, WebFilterChain chain)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;白名单拦截器&quot;</span>);<br>        <span class="hljs-comment">// 获取请求对象 </span><br>        ServerHttpRequest request = exchange.getRequest();<br>        <span class="hljs-comment">// 获取请求路径 </span><br>        URI uri = request.getURI();<br>        <span class="hljs-comment">// 创建路径匹配器</span><br>        PathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();<br>        <span class="hljs-comment">//白名单路径移除JWT请求头</span><br>        List&lt;String&gt; ignoreUrls = ignoreUrlsConfig.getUrls();<br>        <span class="hljs-comment">// 遍历该路径是否属于白名单 </span><br>        <span class="hljs-keyword">for</span> (String ignoreUrl : ignoreUrls) &#123;<br>            <span class="hljs-keyword">if</span> (pathMatcher.match(ignoreUrl, uri.getPath())) &#123;<br>                request = exchange .getRequest(). mutate(). header (AuthConstant.JWT_TOKEN_HEADER, <span class="hljs-string">&quot;&quot;</span>).build();<br>                <span class="hljs-comment">// 封装请求传递给 下一个请求</span><br>                exchange = exchange.mutate().request(request).build();<br>                <span class="hljs-keyword">return</span> chain.filter(exchange);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>    <span class="hljs-comment">//  创建日志对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AuthGlobalFilter.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过exchange 获取token对象</span><br>        String token = exchange. getRequest(). getHeaders(). getFirst(AuthConstant.JWT_TOKEN_HEADER);<br>        System.out.println(<span class="hljs-string">&quot;进入全局拦截器 &quot;</span>);<br>        LOGGER.warn(<span class="hljs-string">&quot;当前请求是否有jwt&quot;</span> + StrUtil.isEmpty(token));<br>        <span class="hljs-keyword">if</span> (StrUtil.isEmpty(token)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;token === null&quot;</span>);<br>            System.out.println(exchange);<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//从token中解析用户信息并设置到Header中去</span><br>            String realToken = token.replace(AuthConstant.JWT_TOKEN_PREFIX, <span class="hljs-string">&quot;&quot;</span>);<br>            JWSObject jwsObject = JWSObject.parse(realToken);<br>            String userStr = jwsObject.getPayload().toString();<br>            LOGGER.info(<span class="hljs-string">&quot;AuthGlobalFilter.filter() user:&#123;&#125;&quot;</span>,userStr);<br>            ServerHttpRequest request = exchange.getRequest().mutate().header(AuthConstant.USER_TOKEN_HEADER, userStr).build();<br>            exchange = exchange.mutate().request(request).build();<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *   过滤器执行顺序，数值越小，优先级越高</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、自定义返回结果"><a href="#4、自定义返回结果" class="headerlink" title="4、自定义返回结果"></a>4、自定义返回结果</h4><h5 id="校验失败返回结果"><a href="#校验失败返回结果" class="headerlink" title="校验失败返回结果"></a>校验失败返回结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestfulAccessDeniedHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerAccessDeniedHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">handle</span><span class="hljs-params">(ServerWebExchange exchange, AccessDeniedException denied)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;权限不对&quot;</span>);<br><br>        ServerHttpResponse response = exchange.getResponse();<br><br>        response.setStatusCode(HttpStatus.OK);<br><br>        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);<br><br>        response.getHeaders().set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br><br>        response.getHeaders().set(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br><br>        String body= JSONUtil.toJsonStr(CommonResult.forbidden(denied.getMessage()));<br><br>        DataBuffer buffer =  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>)));<br><br>        System.out.println(Mono.just(buffer));<br><br>        <span class="hljs-keyword">return</span> response.writeWith(Mono.just(buffer));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5><h5 id="没有token或者token过期时-异常返回结果"><a href="#没有token或者token过期时-异常返回结果" class="headerlink" title="没有token或者token过期时   异常返回结果"></a>没有token或者token过期时   <strong>异常返回结果</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestAuthenticationEntryPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServerAuthenticationEntryPoint</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">commence</span><span class="hljs-params">(ServerWebExchange exchange, AuthenticationException e)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;因为没有token直接返回&quot;</span>);<br><br>        ServerHttpResponse response = exchange.getResponse();<br><br>        response.setStatusCode(HttpStatus.OK);<br><br>        <span class="hljs-comment">// 指定响应头类型</span><br>        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);<br><br>        <span class="hljs-comment">// 添加跨域支持</span><br>        response.getHeaders().set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br><br>        <span class="hljs-comment">// 是否允许缓存 控制</span><br>        response.getHeaders().set(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br><br>        <span class="hljs-comment">// 异常message</span><br>        String body= JSONUtil.toJsonStr(CommonResult.unauthorized(e.getMessage()));<br><br>        DataBuffer buffer =  response.bufferFactory().wrap(body.getBytes(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>)));<br><br>        <span class="hljs-keyword">return</span> response.writeWith(Mono.just(buffer));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Auth模块"><a href="#Auth模块" class="headerlink" title="Auth模块"></a><code>Auth</code>模块</h3><p>模块介绍 ： 该模块用于认证和发送token字符串  </p><h4 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h4><h5 id="application-yaml-1"><a href="#application-yaml-1" class="headerlink" title="application.yaml"></a><code>application.yaml</code></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8401</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">okhttp:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#服务请求连接超时时间（毫秒）</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#服务请求处理超时时间（毫秒）</span><br></code></pre></td></tr></table></figure><h5 id="bootstrap-yaml-1"><a href="#bootstrap-yaml-1" class="headerlink" title="bootstrap.yaml"></a><code>bootstrap.yaml</code></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>  <span class="hljs-comment"># 使用dev环境</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">application:</span><br>  <span class="hljs-comment"># 配置应用名称</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-auth</span><br></code></pre></td></tr></table></figure><h5 id="bootstrap-dev-yaml"><a href="#bootstrap-dev-yaml" class="headerlink" title="bootstrap-dev.yaml"></a><code>bootstrap-dev.yaml</code></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>      <span class="hljs-comment"># 服务发现地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>      <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 服务配置地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">http://localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br><span class="hljs-comment"># 配置日志级别</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h4 id="2、配置类"><a href="#2、配置类" class="headerlink" title="2、配置类"></a>2、配置类</h4><h5 id="配置授权服务器"><a href="#配置授权服务器" class="headerlink" title="配置授权服务器"></a>配置授权服务器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 开启授权服务器</span><br><span class="hljs-meta">@EnableAuthorizationServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Oauth2ServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">// 密码加密方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordEncoder passwordEncoder;<br><br>    <span class="hljs-comment">// 自定义登录逻辑</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserServiceImpl userDetailsService;<br><br>    <span class="hljs-comment">// 身份认证转换器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthenticationManager authenticationManager;<br><br>    <span class="hljs-comment">// jwt内容增强器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTokenEnhancer jwtTokenEnhancer;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        clients.inMemory()<br>                <span class="hljs-comment">// 配置clientId</span><br>                .withClient(<span class="hljs-string">&quot;admin-app&quot;</span>)<br>                <span class="hljs-comment">// 设置密码</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123456&quot;</span>))<br>                <span class="hljs-comment">// 配置作用域</span><br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br>                <span class="hljs-comment">// 授权</span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>)<br>                <span class="hljs-comment">// 访问令牌的有效期</span><br>                .accessTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>)<br>                <span class="hljs-comment">// 刷新令牌的有效期</span><br>                .refreshTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">7</span>)<br>                .and()<br>                 <span class="hljs-comment">// 配置ClientId</span><br>                .withClient(<span class="hljs-string">&quot;portal-app&quot;</span>)<br>                <span class="hljs-comment">// 配置密钥</span><br>                .secret(passwordEncoder.encode(<span class="hljs-string">&quot;123456&quot;</span>))<br>                .scopes(<span class="hljs-string">&quot;all&quot;</span>)<br> <span class="hljs-comment">// 设置密码模式  刷新token 如果不设置refresh_token 是不会自动刷新token的</span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>)<br>                .accessTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>)<br>                .refreshTokenValiditySeconds(<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">7</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  密码模式需要这个配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 配置token增强器</span><br>        TokenEnhancerChain enhancerChain = <span class="hljs-keyword">new</span> TokenEnhancerChain();<br><br>        List&lt;TokenEnhancer&gt; delegates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        delegates.add(jwtTokenEnhancer);<br><br>        delegates.add(accessTokenConverter());<br><br>        <span class="hljs-comment">//配置JWT的内容增强器</span><br>        enhancerChain.setTokenEnhancers(delegates);<br><br>        endpoints.authenticationManager(authenticationManager)<br>                <span class="hljs-comment">//配置加载用户信息的服务</span><br>                .userDetailsService(userDetailsService)<br>                <span class="hljs-comment">// 配置Jwt Token 和 Access Token 转换</span><br>                .accessTokenConverter(accessTokenConverter())<br>                <span class="hljs-comment">// token 存储策略</span><br>                .tokenEnhancer(enhancerChain);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取密钥需要身份认证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> security</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        security.allowFormAuthenticationForClients();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-comment">// 令牌转换器  </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">accessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;<br><br>        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();<br>        <span class="hljs-comment">// 将密钥的的值放入token中</span><br>        jwtAccessTokenConverter.setKeyPair(keyPair());<br>        <span class="hljs-keyword">return</span> jwtAccessTokenConverter;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyPair <span class="hljs-title">keyPair</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//从classpath下的证书中获取秘钥对</span><br>        <span class="hljs-comment">// 创建密钥  存入密钥文件</span><br>        KeyStoreKeyFactory keyStoreKeyFactory = <span class="hljs-keyword">new</span> KeyStoreKeyFactory(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;jwt.jks&quot;</span>), <span class="hljs-string">&quot;123456&quot;</span>.toCharArray());<br>        <span class="hljs-keyword">return</span> keyStoreKeyFactory.getKeyPair(<span class="hljs-string">&quot;jwt&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>.toCharArray());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>SecurityConfig</p><h5 id="配置-SprignSecurity安全"><a href="#配置-SprignSecurity安全" class="headerlink" title="配置 SprignSecurity安全"></a>配置 <code>SprignSecurity</code>安全</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-comment">// 开启web安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 配置安全</span><br>        http.authorizeRequests()<br>                .requestMatchers (EndpointRequest.toAnyEndpoint())  .permitAll()<br>                <span class="hljs-comment">// 释放公钥地址和api-docs地址</span><br>                .antMatchers(<span class="hljs-string">&quot;/rsa/publicKey&quot;</span>).permitAll()<br>                .antMatchers(<span class="hljs-string">&quot;/v2/api-docs&quot;</span>).permitAll()<br>                .anyRequest().authenticated();  <span class="hljs-comment">// 所有请求认证</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 身份认证器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManagerBean();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密器  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置token内容增强器"><a href="#配置token内容增强器" class="headerlink" title="配置token内容增强器"></a>配置token内容增强器</h5><blockquote><p>为什么需要这个 ？？ </p><p><code>SpringSecurity OAuth2</code> 生成的token 中不能添加字段 所以使用token内容增强器</p><p>增加token信息  多携带信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTokenEnhancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenEnhancer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;<br><br>        SecurityUser securityUser = (SecurityUser) authentication.getPrincipal();<br><br>        Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">//把用户ID设置到JWT中</span><br>        info.put(<span class="hljs-string">&quot;id&quot;</span>, securityUser.getId());<br><br>        info.put(<span class="hljs-string">&quot;client_id&quot;</span>,securityUser.getClientId());<br><br>        <span class="hljs-comment">// OAuth2AccessToken 这个是接口  所以只能强转</span><br>        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);<br><br>        <span class="hljs-keyword">return</span> accessToken;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定义消息常量"><a href="#定义消息常量" class="headerlink" title="定义消息常量"></a>定义消息常量</h5><p>便于统一定制 消息返回提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConstant</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOGIN_SUCCESS = <span class="hljs-string">&quot;登录成功!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USERNAME_PASSWORD_ERROR = <span class="hljs-string">&quot;用户名或密码错误!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CREDENTIALS_EXPIRED = <span class="hljs-string">&quot;该账户的登录凭证已过期，请重新登录!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ACCOUNT_DISABLED = <span class="hljs-string">&quot;该账户已被禁用，请联系管理员!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ACCOUNT_LOCKED = <span class="hljs-string">&quot;该账号已被锁定，请联系管理员!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ACCOUNT_EXPIRED = <span class="hljs-string">&quot;该账号已过期，请联系管理员!&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PERMISSION_DENIED = <span class="hljs-string">&quot;没有访问权限，请联系管理员!&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h4><h5 id="1、自定义获取token接口"><a href="#1、自定义获取token接口" class="headerlink" title="1、自定义获取token接口"></a>1、自定义获取token接口</h5><p>通过需要安全验证的接口， 通过远程调用这个接口进行验证返回token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Api(tags = &quot;AuthController&quot;, description = &quot;认证中心登录认证&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/oauth&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TokenEndpoint tokenEndpoint;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;Oauth2获取token&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParams(&#123;</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;grant_type&quot;, value = &quot;授权模式&quot;, required = true),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;client_id&quot;, value = &quot;Oauth2客户端ID&quot;, required = true),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;client_secret&quot;, value = &quot;Oauth2客户端秘钥&quot;, required = true),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;refresh_token&quot;, value = &quot;刷新token&quot;),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;username&quot;, value = &quot;登录用户名&quot;),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;password&quot;, value = &quot;登录密码&quot;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/token&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Oauth2TokenDto&gt; <span class="hljs-title">postAccessToken</span><span class="hljs-params">(<span class="hljs-meta">@ApiIgnore</span> Principal principal, <span class="hljs-meta">@ApiIgnore</span> <span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; parameters)</span> <span class="hljs-keyword">throws</span> HttpRequestMethodNotSupportedException </span>&#123;<br><br>        <span class="hljs-comment">// 构建token</span><br>        OAuth2AccessToken oAuth2AccessToken = tokenEndpoint.postAccessToken(principal, parameters).getBody();<br><br>        Oauth2TokenDto oauth2TokenDto = Oauth2TokenDto.builder()<br>                .token(oAuth2AccessToken.getValue())<br>                .refreshToken(oAuth2AccessToken.getRefreshToken().getValue())<br>                .expiresIn(oAuth2AccessToken.getExpiresIn())<br>                .tokenHead(AuthConstant.JWT_TOKEN_PREFIX).build();<br><br>        <span class="hljs-keyword">return</span> CommonResult.success(oauth2TokenDto);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、接口返回参数类"><a href="#2、接口返回参数类" class="headerlink" title="2、接口返回参数类"></a>2、接口返回参数类</h5><h6 id="定义-Oauth2Token返回参数"><a href="#定义-Oauth2Token返回参数" class="headerlink" title="定义 Oauth2Token返回参数"></a>定义 <code>Oauth2Token</code>返回参数</h6><p>便于返回统一格式Token</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Data</span><br><span class="hljs-variable">@EqualsAndHashCode</span>(callSuper = false)<br><span class="hljs-variable">@Builder</span><br>public class Oauth2TokenDto &#123;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;访问令牌&quot;</span>)<br>    private String token;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;刷令牌&quot;</span>)<br>    private String refreshToken;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;访问令牌头前缀&quot;</span>)<br>    private String tokenHead;<br>    <span class="hljs-variable">@ApiModelProperty</span>(<span class="hljs-string">&quot;有效时间（秒）&quot;</span>)<br>    private int expiresIn;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、获取公钥"><a href="#3、获取公钥" class="headerlink" title="3、获取公钥"></a>3、获取公钥</h5><p>通过接口获取公钥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyPairController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KeyPair keyPair;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/rsa/publicKey&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 读取公钥  转换成Json 返回</span><br>        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();<br>        RSAKey key = <span class="hljs-keyword">new</span> RSAKey.Builder(publicKey).build();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JWKSet(key).toJSONObject();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、自定义登录逻辑"><a href="#4、自定义登录逻辑" class="headerlink" title="4、自定义登录逻辑"></a>4、自定义登录逻辑</h4><h5 id="1、UserServiceImpl"><a href="#1、UserServiceImpl" class="headerlink" title="1、UserServiceImpl"></a>1、<code>UserServiceImpl</code></h5><p>通过实现<code>UserDetailService</code>进行自定义<code>sercurity</code>的登录逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-comment">// 通过远程接口进行访问</span><br>    <span class="hljs-keyword">private</span> UmsAdminService adminService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-comment">// 通过远程接口进行调用</span><br>    <span class="hljs-keyword">private</span> UmsMemberService memberService;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> HttpServletRequest request;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br><br>        <span class="hljs-comment">// 获取服务端id</span><br>        String clientId = request.getParameter(<span class="hljs-string">&quot;client_id&quot;</span>);<br>        <span class="hljs-comment">// 统一封装参数</span><br>        UserDto userDto;<br>        <span class="hljs-comment">// 检验是不是后台客户端</span><br>        <span class="hljs-keyword">if</span>(AuthConstant.ADMIN_CLIENT_ID.equals(clientId))&#123;<br>            <span class="hljs-comment">// 调用后台的接口查询</span><br>            userDto = adminService.loadUserByUsername(username);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 调用前台的接口查询</span><br>            userDto = memberService.loadUserByUsername(username);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userDto==<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 表示用户名和密码错误</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(MessageConstant.USERNAME_PASSWORD_ERROR);<br>        &#125;<br>        <span class="hljs-comment">// 将clientId 加入参数中</span><br>        userDto.setClientId(clientId);<br>        <span class="hljs-comment">// 添加</span><br>        SecurityUser securityUser = <span class="hljs-keyword">new</span> SecurityUser(userDto);<br>        <span class="hljs-comment">// 检验账号是否已经开启</span><br>        <span class="hljs-keyword">if</span> (!securityUser.isEnabled()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledException(MessageConstant.ACCOUNT_DISABLED);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!securityUser.isAccountNonLocked()) &#123;    <span class="hljs-comment">// 检验是否被锁定</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LockedException(MessageConstant.ACCOUNT_LOCKED);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!securityUser.isAccountNonExpired()) &#123;   <span class="hljs-comment">// 检验账号是否过期</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccountExpiredException(MessageConstant.ACCOUNT_EXPIRED);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!securityUser.isCredentialsNonExpired()) &#123;  <span class="hljs-comment">// 检验账号凭证是否已经过期</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CredentialsExpiredException(MessageConstant.CREDENTIALS_EXPIRED);<br>        &#125;<br>        <span class="hljs-keyword">return</span> securityUser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、SecurityUser"><a href="#2、SecurityUser" class="headerlink" title="2、SecurityUser"></a><code>2、SecurityUser</code></h5><p>使用与参数列表  <code>SecurityUser</code> 和 <code>UserServiceImpl</code>是security安全的俩个核心</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityUser</span> <span class="hljs-title">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> username;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> password;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> enabled;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录客户端ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> clientId;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 权限数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Collection&lt;SimpleGrantedAuthority&gt; authorities;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">SecurityUser</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">SecurityUser</span>(<span class="hljs-params">UserDto userDto</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setId(userDto.getId());<br>        <span class="hljs-built_in">this</span>.setUsername(userDto.getUsername());<br>        <span class="hljs-built_in">this</span>.setPassword(userDto.getPassword());<br>        <span class="hljs-built_in">this</span>.setEnabled(userDto.getStatus() == <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.setClientId(userDto.getClientId());<br>        <span class="hljs-keyword">if</span> (userDto.getRoles() != <span class="hljs-literal">null</span>) &#123;<br>            authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            userDto.getRoles().forEach(item -&gt; authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(item)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Collection&lt;? <span class="hljs-keyword">extends</span> GrantedAuthority&gt; <span class="hljs-function"><span class="hljs-title">getAuthorities</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.authorities;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getPassword</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.password;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getUsername</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.username;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isAccountNonExpired</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isAccountNonLocked</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isCredentialsNonExpired</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isEnabled</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.enabled;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>总结 ： <code>Auth</code>认证服务 通过暴露<code>/oauth/token</code>接口，让需要认真的接口远程调用进行认证  </p><h3 id="Admin模块"><a href="#Admin模块" class="headerlink" title="Admin模块"></a><code>Admin</code>模块</h3><p><code>admin</code>模块</p><h4 id="订单管理"><a href="#订单管理" class="headerlink" title="订单管理"></a>订单管理</h4><p>暂时还没到这个层面</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><ul><li><p>授权<code>admin</code>  没有修改最后登录</p></li><li><p>授权了管理员或者是别的账号    角色用户数没有增加 </p></li><li><p>不管是增加和删除都没有增加数量    </p></li><li><p>删除和授权  角色关系映射和角色表应该改变 </p><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210630084404241.png" alt="image-20210630084404241"></p></li></ul><p>删除问题已经解决</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>查看三张表的关系</p><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210630104835298.png" alt="image-20210630104835298"></p><p>接口定义  加上事务  不然出现异常用户不会回滚 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long id)</span></span>;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    <span class="hljs-comment">// 删除账号</span><br>    <span class="hljs-keyword">int</span> count = adminMapper.deleteByPrimaryKey(id);<br>    System.out.println(id);<br>    <span class="hljs-comment">// 获取关系映射id</span><br>    UmsAdminRoleRelation roleRelation = adminRoleRelationDao.getRoleIdByAdminId(id);<br>    System.out.println(roleRelation);<br>    <span class="hljs-comment">// 删除关系映射</span><br>    <span class="hljs-keyword">int</span> i = adminRoleRelationMapper .deleteByPrimaryKey (roleRelation.getId()); <br>    <span class="hljs-comment">// 删除role对应的角色数量</span><br>    UmsRole umsRole = roleService.selectRoleById(roleRelation.getRoleId());<br>    umsRole.setAdminCount(umsRole.getAdminCount()-<span class="hljs-number">1</span>);<br>    roleService.update(roleRelation.getRoleId() , umsRole);<br>    <span class="hljs-comment">// 删除缓存</span><br>    adminCacheService.delAdmin(id);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出登录修改最后登录时间 </p><p>添加中角色数量没有增加   需要进行修改 </p><h4 id="会员管理"><a href="#会员管理" class="headerlink" title="会员管理"></a>会员管理</h4><h5 id="对接会员模块"><a href="#对接会员模块" class="headerlink" title="对接会员模块"></a>对接会员模块</h5><p>如图可知，现在开源项目 ， 会员管理并未完成， 对接会员管理</p><p><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703101321207.png" alt="image-20210703101321207"></p><h5 id="修改后端"><a href="#修改后端" class="headerlink" title="修改后端"></a>修改后端</h5><ol><li><p>创建菜单列表  对应的数据库为 <code>ums_menu</code>这个实现的接口为  <code>/menu/**</code></p></li><li><p>使用改接口添加会员字段  （对菜单表进行insert操作）</p></li><li><p>创建子级目录 会员列表和会员等级列表    &lt; 数据库设计如下</p><ol><li><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703111656921.png" alt="image-20210703111656921"></li></ol></li><li><p>在资源列表中将会员列表的接口 和 会员等级的接口添加进去资源列表，要不然前端无法调用</p></li><li><p>添加之后设置等级 ，缓存等级表是<code>ums_resource_category</code>  这里有对应的模块用于对模块进行分类显示</p></li><li><p>其中这个表的id要与resource资源路径的categoryId一致</p><ol><li><img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703112539225.png" alt="image-20210703112539225"></li></ol></li></ol><h5 id="修改前端"><a href="#修改前端" class="headerlink" title="修改前端"></a>修改前端</h5><h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><blockquote><p>前端采用的是vue + elementUi </p><p>Vue对组件的路径管理  采用的是路由的方式 </p><p>所以得先修改路由，进行展示 </p></blockquote><p>先查看路由</p><p>修改路由注意事项</p><p> <img src="/2021/06/16/mall%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210703125358063.png" alt="image-20210703125358063"></p><blockquote><p>这里是用全局路由数组和请求过来的权限数组进行匹配  如果有不匹配的则不进行显示</p></blockquote><p>查看路由匹配算法 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//判断是否有权限访问该菜单</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPermission</span>(<span class="hljs-params">menus, route</span>) </span>&#123;<br>   <span class="hljs-comment">// 将路由名字进行判断</span><br>  <span class="hljs-keyword">if</span> (route.name) &#123;<br>      <span class="hljs-comment">// 通过路由名字 和 menus 进行匹配 查看是否匹配</span><br>    <span class="hljs-keyword">let</span> currMenu = getMenu(route.name, menus);<br>    <span class="hljs-keyword">if</span> (currMenu!=<span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//设置菜单的标题、图标和可见性</span><br>      <span class="hljs-keyword">if</span> (currMenu.title != <span class="hljs-literal">null</span> &amp;&amp; currMenu.title !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        route.meta.title = currMenu.title;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (currMenu.icon != <span class="hljs-literal">null</span> &amp;&amp; currMenu.title !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        route.meta.icon = currMenu.icon;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(currMenu.hidden!=<span class="hljs-literal">null</span>)&#123;<br>        route.hidden = currMenu.hidden !== <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (currMenu.sort != <span class="hljs-literal">null</span> &amp;&amp; currMenu.sort !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        route.sort = currMenu.sort;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      route.sort = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (route.hidden !== <span class="hljs-literal">undefined</span> &amp;&amp; route.hidden === <span class="hljs-literal">true</span>) &#123;<br>          <span class="hljs-comment">// 不会显示</span><br>        route.sort=-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以这里的路由命和meanu菜单的name要保持一致</p><p>增加对会员列表的增删查改 </p><p>完成 。。。</p><p>增加会员等级列表 </p><p>完成</p><p>增加会员成长值 </p><p>完成</p><p>增加会员登录日志</p><p>完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaJvm和JMM</title>
    <link href="/2021/06/16/JavaJVM%E5%92%8CJMM/"/>
    <url>/2021/06/16/JavaJVM%E5%92%8CJMM/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>JVM(Java虚拟机的运行时区域)  和 JMM(Java内存模型) 有什么关系 </p><blockquote><p>JMM 和  Java并发编程有关  </p></blockquote><h2 id="JMM-是什么"><a href="#JMM-是什么" class="headerlink" title="JMM 是什么"></a>JMM 是什么</h2><ul><li>JMM是一种符合内存规范的, 屏蔽了各种硬件和操作系统的访问差异的, 保证了Java程序在各种平台对内存访问都能保证效果一致的机制及规范</li><li>Java内存模型规定了<strong>所有的变量</strong>都存储在主内存中, 每条线程还有自己的工作内存, 线程的工作内存中保存了该线程中是<strong>用到的变量的主内存副本拷贝</strong>, 线程对变量的所有操作都必须在工作内存中进行, 不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量, 线程间变量的传递均需要自己的共工作内存和主存之间进行数据同步进行</li><li>JMM就作用于工作内存和主内存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</li></ul><h2 id="JMM-的主要作用-以及实现方式-解决了那些问题"><a href="#JMM-的主要作用-以及实现方式-解决了那些问题" class="headerlink" title="JMM 的主要作用  以及实现方式 解决了那些问题"></a>JMM 的主要作用  以及实现方式 解决了那些问题</h2><p><img src="/2021/06/16/JavaJVM%E5%92%8CJMM/image-20210616092723877.png" alt="image-20210616092723877"></p><p>JMM是一种规范，目的是<strong>解决</strong>由于多线程通过共享内存进行通信时，储存在本地内存的<strong>数据不一致</strong></p><p>、编译器会对<strong>代码指令重排序</strong>、处理器会对<strong>代码乱序执行</strong>等带来的问题</p><p>原子性 ：</p><blockquote><p><em>即一个操作或者多个操作</em> <em>要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</em></p></blockquote><p>​        Java中可以使用<code>synchronized </code>来保证方法和代码内的操作是原子性的 </p><p>​        自Jdk1.5之后提供了一个<code>Lock</code>(使用的是实现类)包 可以保证方法和代码内的操作都是原子性的</p><p> 而且俩者都是可重入锁 ？ </p><blockquote><p>解答文档<a href="https://mp.weixin.qq.com/s/R7Fu1HDW3N1pl1c9VJ2T5Q">https://mp.weixin.qq.com/s/R7Fu1HDW3N1pl1c9VJ2T5Q</a></p></blockquote><p>有序性 ： 即程序执行的顺序按照代码的先后顺序执行。</p><p><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p><p>可见性：</p><blockquote><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSeRelearn</title>
    <link href="/2021/06/15/JavaSeRelearn/"/>
    <url>/2021/06/15/JavaSeRelearn/</url>
    
    <content type="html"><![CDATA[<h1 id="javaSe-复习"><a href="#javaSe-复习" class="headerlink" title="javaSe  复习"></a>javaSe  复习</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java 数据类型的取值范围 </p><blockquote><p>byte 字节型 -128～127 -2^7～2^7-1 1字节</p><p>short 短整型 -32768～32767 -2^15～2^15-12字节</p><p>int 整型 -2147483648～2147483647 -2^31～2^31-1 4字节</p><p>long 长整型 -9223372036854775808～9223372036854775807 -2^63～2^-1 8字节</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> i = <span class="hljs-number">127</span>;<br><span class="hljs-keyword">long</span> s = <span class="hljs-number">1000L</span>;<br><span class="hljs-keyword">long</span> l = s - i;<br>System.out.println(l);<br></code></pre></td></tr></table></figure><blockquote><p>当容量小的数据类型与容量大的数据类型的变量做运算时, 结果会自动提升为容量大的数据类型</p></blockquote><p>位运算符 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">【特别说明的】<br>1. 位运算符操作的都是整型的数据<br>2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2<br>&gt;&gt; :在一定范围内，每向右移1位，相当于 / 2<br></code></pre></td></tr></table></figure><p>流程控制 </p><p>switch 语法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>执行语句<span class="hljs-number">1</span>;<br><span class="hljs-comment">//break;</span><br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>执行语句<span class="hljs-number">2</span>;<br><span class="hljs-comment">//break;</span><br>...<br><span class="hljs-keyword">default</span>:<br>执行语句n;<br><span class="hljs-comment">//break;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组数据类型 </p><p>数组的特点</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 1数组是序排列的<br><span class="hljs-bullet">*</span> 2数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型<br><span class="hljs-bullet">*</span> 3创建数组对象会在内存中开辟一整块连续的空间<br><span class="hljs-bullet">*</span> 4数组的长度一旦确定，就不能修改。<br></code></pre></td></tr></table></figure><p>数组的创建方式</p><ol><li><p>直接声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[]  array;   <br></code></pre></td></tr></table></figure></li><li><p>静态初始化： 数组初始化和数组元素赋值同时进行 </p> <figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">int[]<span class="hljs-built_in"> array </span>= &#123;1,2 ,3, 4&#125;;<br></code></pre></td></tr></table></figure></li><li><p>动态初始化：数组的初始化和数组元素的赋值操作分开进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明数组时 指定长度 默认数组的所有元素初始化为null </span><br>String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure></li></ol><p>‘ Arrays 工具类的使用’</p><blockquote><p>boolean equals(int[] a,int[] b)  :判断两个数组是否相等。<br>String toString(int[] a)  :输出数组信息。<br>void fill(int[] a,int val)  :将指定值填充到数组之中<br>void sort(int[] a)  :对数组进行排序<br>int binarySearch(int[] a,int key) :  从数组中查找key    </p></blockquote><h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><p>理解”<strong>万事万物皆对象</strong>“  </p><p>1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构</p><ul><li><blockquote><p>Scanner,String等</p></blockquote></li><li><blockquote><p>文件：File</p></blockquote></li><li><blockquote><p>网络资源：URL</p></blockquote></li></ul><p>2.涉及到Java语言与前端<strong>Html</strong>、后端的数据库交互时<strong>，前后端的结构在Java层面交互时</strong>，都体现为<strong>类、对象</strong>。</p><p>类的属性和局部变量的不同以及差异</p><blockquote><p>对比：属性  vs  局部变量</p><p>1.相同点：</p><ul><li><pre><code>    1.1  定义变量的格式：数据类型  变量名 = 变量值</code></pre></li><li><pre><code>    1.2 先声明，后使用</code></pre></li><li><pre><code>    1.3 变量都其对应的作用域 </code></pre></li></ul><p>2.不同点：<br>       2.1 在类中声明的位置的不同</p><ul><li><pre><code>    属性：直接定义在类的一对&#123;&#125;内</code></pre></li><li><pre><code>    局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</code></pre></li></ul><p> 2.2 关于权限修饰符的不同</p><ul><li><pre><code>    属性：可以在声明属性时，指明其权限，使用权限修饰符。</code></pre></li><li><pre><code>    常用的权限修饰符：private、public、缺省、protected  ---&gt;封装性</code></pre></li><li><pre><code>    目前，大家声明属性时，都使用缺省就可以了。</code></pre></li><li><pre><code>    局部变量：不可以使用权限修饰符。</code></pre></li></ul><p> 2.3 默认初始化值的情况：</p><ul><li><pre><code>    属性：类的属性，根据其类型，都默认初始化值。</code></pre></li><li><pre><code>    整型（byte、short、int、long：0）</code></pre></li><li><pre><code>    浮点型（float、double：0.0）</code></pre></li><li><pre><code>    字符型（char：0  （或&#39;\u0000&#39;））</code></pre></li><li><pre><code>    布尔型（boolean：false）</code></pre></li></ul><ul><li><pre><code>        引用数据类型（类、数组、接口：null）</code></pre></li><li><pre><code>        局部变量：没默认初始化值。</code></pre></li><li><pre><code>        意味着，我们在调用局部变量之前，一定要显式赋值。</code></pre></li><li><pre><code>        特别地：形参在调用时，我们赋值即可。</code></pre></li></ul><p> 2.4 在内存中加载的位置：</p><ul><li><pre><code>    属性：加载到**堆空间**中   （非static）</code></pre></li><li><pre><code>    局部变量：加载到操作数栈</code></pre></li></ul></blockquote><h4 id="为什么-需要封装"><a href="#为什么-需要封装" class="headerlink" title="为什么 需要封装"></a>为什么 需要封装</h4><blockquote><p>我们程序设计追求“高内聚，低耦合”。</p><p>高内聚 ：<strong>类的内部数据操作细节自己完成，不允许外部干涉；</strong><br>低耦合 ：<strong>仅对外暴露少量的方法用于使用。</strong></p></blockquote><p>封装概念以及思想</p><blockquote><p>隐藏对象内部的复杂性，只对外公开简单的接口。</p><p>便于外界调用，从而提高系统的可扩展性、可维护性。</p><p>通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p></blockquote><p>封装的具体的代码实现</p><ul><li><blockquote><p>将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p></blockquote></li><li><blockquote><p>不对外暴露的私有的方法</p></blockquote></li><li><blockquote><p>单例模式（将构造器私有化）****</p></blockquote></li><li><blockquote><p>如果不希望类在包外被调用，可以将类设置为缺省的。</p></blockquote></li></ul><p>java的权限修饰符 </p><blockquote><p>private &lt;  缺省 &lt; protected &lt; public</p></blockquote><p>四个属性修饰的范围 </p><blockquote><p>4种权限都可以用来修饰<strong>类的内部结构</strong>：<strong>属性、方法、构造器、内部类</strong></p></blockquote><blockquote><p>修饰类的话，只能使用：<strong>缺省、public</strong></p></blockquote><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote><p>2.使用说明：</p><ul><li>1.如果没显式的定义类的构造器的话，则系统默认提供一个<strong>空参的构造器</strong></li><li>2.定义构造器的格式：<strong>权限修饰符  类名(形参列表){}</strong></li><li>3.一个类中定义的多个构造器，<strong>彼此构成重载</strong></li><li>4.一旦我们显式的定义了类的构造器之后，<strong>系统就不再提供默认的空参构造器</strong></li><li>5.一个类中，至少<strong>会有一个构造器。</strong></li></ul></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>// 面向对象三大特性  ：  封装  继承  多态 </p><ul><li>不使用继承前的代码 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> Integer age;<br>    <span class="hljs-keyword">public</span> Date   birthDate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(name + age + birthDate);<br>        <span class="hljs-keyword">return</span>  name + age + birthDate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生类 class Student&#123;    public String name;    public Integer age;    public Date   birthDate;    public String schoolName;    public String  getInfo()&#123;        System.out.println(name + age + birthDate);        return  name + age + birthDate;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>使用继承之后的代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明父类class People&#123;    public String name;    public Integer age;    public Date   birthDate;    public String  getInfo()&#123;        System.out.println(name + age + birthDate);        return  name + age + birthDate;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生类class Student extends People&#123;    public String schoolName;&#125;</span><br></code></pre></td></tr></table></figure><p>通过上述的代码：  ——&gt; 得出的结论为 ：   继承可以减少代码冗余     提高可复用性</p></li></ul><p>  作用：</p><blockquote><p>继承的出现减少了代码冗余   提高了代码的复用性。<br>继承的出现，更有利于功能的扩展。<br>继承 的出现让类与类之间产生了 关系 ，提供了多态的 前提 。</p><blockquote><p>注意：<strong>不要 仅为了获取其他类中某个功能而去继承</strong></p></blockquote></blockquote><p>  为什么要有继承 ？？？</p><blockquote><p>多个类中存在<strong>相同属性和行为</strong>时，将这些内容抽取到单独一个类中，<br>那么<strong>多个类无需再定义这些属性和行为</strong>，只要继承那个类即可。</p></blockquote><p>​    </p><p>子类是不是能操作父类的全部的数据呢 ？？ </p><blockquote><p>不是， 子类不能直接访问父类私有的属性以及方法</p></blockquote><p>java是不是属于多继承呢 ？？ </p><blockquote><p>java 是单继承   一个子类只能有一个父类    一个父类可以有多个子类</p></blockquote><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>子类重写父类的定义：：</p><blockquote><p>在子类中可以根据需要对从<strong>父类中继承来的方法进行改造</strong> 也称<br>为方法 的 重置、覆盖 。在程序执行时，<strong>子类的方法将覆盖父类的方法。</strong>  </p></blockquote><p>注意事项：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 子类与父类中同名同参数的方法必须同时声明 为  非static的 (即为重写)，或者同时声明 为static 的不是重写 。因为 static方法是属于类的，子类无法覆盖父类的方法。</span><br></code></pre></td></tr></table></figure><p>要求</p><ol><li><p>子类重写的方法 必须和父类被重写的方法 具有<strong>相同的 方法名称、 参数 列表</strong></p></li><li><p>子类<strong>重写的方法的返回值类型</strong>不能大于   <strong>父类被重写的方法的返回值类型</strong></p></li><li><p>子类<strong>重写的方法使用的访问权限</strong> 不能小于 父类被重写的方法的访问权限</p><ol><li><blockquote><p>子类<strong>不能重写父类中声明为 private 权限的方法</strong></p></blockquote></li></ol></li><li><p>子类<strong>方法抛出的异常</strong>不能大于<strong>父类被重写方法的异常</strong></p></li></ol><p>问题： 重写和重载的区别 :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 方法的重写Overriding和重载Overloading是Java多态性的不同表现。2. 重写Overriding是父类与子类之间多态性的一种表现，3. 重载Overloading是一个类中多态性的一种表现。4. 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&quot;屏蔽&quot;了。5. 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。<br></code></pre></td></tr></table></figure><h4 id="super关键词"><a href="#super关键词" class="headerlink" title="super关键词"></a>super关键词</h4><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210411184500602.png" alt="image-20210411184500602"></p></blockquote><p>this  和  super的区别</p><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210411184639758.png" alt="image-20210411184639758"></p></blockquote><p>面试题：  ==  和  equasl 的区别 </p><blockquote><p>== 既可以比较 地址值和数据值    </p><p>对于基本类型比较的是值   对于引用类型比较的就是地址</p><p>具体 要看自定义类里有没有 重写 Object 的 equals 方法来 判断。</p><p>通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。</p></blockquote><h3 id="字符串和基本数据类型之间的互相转换"><a href="#字符串和基本数据类型之间的互相转换" class="headerlink" title="字符串和基本数据类型之间的互相转换"></a>字符串和基本数据类型之间的互相转换</h3><p><strong>String 转换成基本数据类型的方法</strong></p><p><strong>基本数据类型转换String</strong> </p><p><img src="/2021/06/15/JavaSeRelearn/image-20210414104116418.png" alt="image-20210414104116418"></p><h3 id="interface-gt-abstract"><a href="#interface-gt-abstract" class="headerlink" title="interface   -&gt;  abstract"></a>interface   -&gt;  abstract</h3><p>接口和抽象类有什么不同点和共同点</p><p>相同点：</p><blockquote><p>不能实例化    -    都可以包含抽象方法</p></blockquote><p> 不同点：</p><blockquote><p>类： 单继承      接口： 多继承  </p><p>类与接口 ： 多实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">interfaceLearn</span>   <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Dao</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 接口可以调用接口的静态方法        Dao.tses(new Object());        // 默认方法 通过接口的实现类进行调用  如果接口的实现复写了改方法 就调用接口实现者的方法        Dao dao = new interfaceLearn();        // 调用默认方法        // 调用的是抽象类的方法   执行类有先的原则        dao.test();        /**         *  service -&gt;  执行         * java.lang.Object@1b6d3586         * Service-&gt;   test         */    &#125;&#125;interface Dao&#123;    // 结构中可以声明静态方法    static void tses(Object o)&#123;        System.out.println(o);    &#125;    // 接口中的默认方法    default void  test()&#123;        System.out.println(&quot;interface  -&gt; default  -&gt;   test&quot;);    &#125;&#125;abstract class Service&#123;    // 抽象类中声明静态代码块    static &#123;        System.out.println(&quot; service -&gt;  执行&quot;);    &#125;    // 定义普通方法     public void  test()&#123;         System.out.println(&quot;Service-&gt;   test&quot;);     &#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h3><p>疑问 ： </p><ul><li>线程声明周期 ：</li></ul><p><img src="/2021/06/15/JavaSeRelearn/image-20210414155458289.png" alt="image-20210414155458289"></p><ul><li> 创建多线程有多少方法</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 第一种：  通过继承Thread类然后   调用start()进行创建# 第二种： 通过继承runnable()    接口进行创建# 第三种： 通过继承callable 接口进行创建   （带有泛型和返回值）# 第四种： 通过线程池创建</span><br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 使用线程        new MyThread().start();        // 使用runnable 实现接口        new Thread(new RunnableLearn()).start();        // 实现 callable接口 注意这个接口需要使用别的扩展类进行创建线程        new Thread(new FutureTask&lt;&gt;(new CallableLearn())).start();        // 使用线程池创建   创建线程池        System.out.println(&quot;线程池执行 = 》   》》》 》》》   》》&quot;);        ExecutorService executorService = Executors.newFixedThreadPool(10);        executorService.execute(new MyThread());        executorService.execute(new RunnableLearn());        // 执行 callable接口        executorService.execute(new FutureTask&lt;&gt;(new CallableLearn()));        executorService.shutdown();    &#125;&#125;// 创建线程第一种方法class MyThread extends Thread&#123;    @Override    public void run() &#123;        System.out.println(&quot;MyThread  -&gt;  run&quot;);    &#125;&#125;// 第二种创建线程方法  通过 runnable接口class RunnableLearn implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(&quot;runnable  -&gt;  run&quot;);    &#125;&#125;// 第三种方式通过实现callable 接口  该接口带有泛型  泛型就表示call方法返回值class CallableLearn implements Callable&lt;Object&gt; &#123;    @Override    public Object call() throws Exception &#123;        System.out.println(&quot; callable  -&gt;  run&quot;);        return new String(&quot;callable run&quot;);    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>Java里面线程池的<strong>顶级接口是Executor</strong>，但是<strong>严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。</strong>真正的<strong>线程池接口是ExecutorService。</strong></p><p>线程池有几种 ？    四种</p><p>分别是什么   功能以及优缺点？ </p><ul><li><blockquote><h1 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h1><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p></blockquote></li><li><blockquote><h1 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h1><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p></blockquote></li></ul><ul><li><blockquote><h1 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h1><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote></li><li><blockquote><h1 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h1><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p></blockquote></li></ul><h4 id="线程池-源码解析"><a href="#线程池-源码解析" class="headerlink" title="线程池 源码解析"></a><strong>线程池 源码解析</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">都是通过 <span class="hljs-keyword">new</span> ThreadPoolExecutor 进行创建的线程池     <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>,  <span class="hljs-comment">// 核心线程数 process + 1,   // 最大线程数 ==  电脑线程数 + 12L,   // 存活时间 TimeUnit.SECONDS,  // 时间单位new LinkedBlockingQueue&lt;&gt;(3),  // 创建长度为三的阻塞队列  Executors.defaultThreadFactory(),     //   默认线程工厂    //new ThreadPoolExecutor.AbortPolicy() // 出场默认中止策略    //new ThreadPoolExecutor.CallerRunsPolicy()   // 处理不掉的 任务返回给委派任务者    //new ThreadPoolExecutor.DiscardPolicy()  //  抛弃任务中的等待时间最长的任务，然后把当前任务加入队列中，尝试再次提交当前任务   不抛出异常    new ThreadPoolExecutor.DiscardOldestPolicy()   // 该策略默默丢弃一些无法处理的任务,不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略);</span><br></code></pre></td></tr></table></figure><h4 id="线程锁："><a href="#线程锁：" class="headerlink" title="线程锁："></a>线程锁：</h4><p>概念暂无 ：“</p><p>详情查看书籍 :   java重点总结</p><p>Start 和  run 方法的区别</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">start与<span class="hljs-built_in">run</span>区别 <span class="hljs-number">1.</span> start（）方法来启动线程，真正实现了多线程运行。这时无需等待<span class="hljs-built_in">run</span>方法体代码执行完毕，可以直接继续执行下面的代码。<span class="hljs-number">2.</span> 通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 <span class="hljs-number">3.</span> 方法<span class="hljs-built_in">run</span>()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行<span class="hljs-built_in">run</span>函数当中的代码。 <span class="hljs-built_in">Run</span>方法运行结束， 此线程终止。然后CPU再调度其它线程。<br></code></pre></td></tr></table></figure><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h4><p>源码分析： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span>          <span class="hljs-title">private</span> <span class="hljs-title">final</span> <span class="hljs-title">char</span> <span class="hljs-title">value</span>[]</span>;    <span class="hljs-comment">// String 是final修饰的， 是不能被修改的// 实现了 Serializable接口实现了序列化// 实现了Comparable接口  可以进行比较// String底层默认使用字符数组进行存储</span><br></code></pre></td></tr></table></figure><p>字符串实例方式  以及差异 </p><blockquote><p>第一种方式通过字符字面量进行创建</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String name = <span class="hljs-string">&quot;anzhen&quot;</span>; <span class="hljs-comment">// 直接创建在常量池    </span><br></code></pre></td></tr></table></figure><blockquote><p>第二种通过new  String 进行创建    </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String names = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;anzhen&quot;</span>);System.out.println(names == name); <span class="hljs-comment">// 比较地址值// 返回值为false</span><br></code></pre></td></tr></table></figure><p>请问new String() 开辟了 几块内存 </p><blockquote><p>两个: 一个是<strong>堆空间中new结构</strong>，另一个是<strong>char[]对应的常量池中的数据</strong>：”abc”</p></blockquote><p>创建过程如下： </p><blockquote><p>先在堆空间开辟对象，然后查找字符串常量池中查找传入的值  </p><p>如果字符串常量池中存在则把字符串常量地址复制给value</p></blockquote><p>检验如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">names = names.intern();   <span class="hljs-comment">// intern 将字符串的值推向常量池  如果常量池存在则把常量池对象地址赋值给变量System.out.println(names == name);  // 比较地址值</span><br></code></pre></td></tr></table></figure><p>字符串拼接：</p><blockquote><p>常量和常量拼接在字符串常量池   常量池不会存在相同的常量</p><p>只要<strong>其中一个是变量</strong>结果就在<strong>堆中</strong></p><p>如果拼接的字符串的结果调用了 <strong>intern()</strong> 方法， 返回值就在常量池中</p></blockquote><p>string 常用api </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span>：返回字符串的长度： return value.lengthchar <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span>： 返回某索引处的字符return value[index]<span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span>：判断是否是空字符串：return value.length </span>== 0<span class="hljs-function">String <span class="hljs-title">toLowerCase</span><span class="hljs-params">()</span>：使用默认语言环境，将 String 中的所字符转换为小写String <span class="hljs-title">toUpperCase</span><span class="hljs-params">()</span>：使用默认语言环境，将 String 中的所字符转换为大写String <span class="hljs-title">trim</span><span class="hljs-params">()</span>：返回字符串的副本，忽略前导空白和尾部空白<span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span>：比较字符串的内容是否相同<span class="hljs-keyword">boolean</span> <span class="hljs-title">equalsIgnoreCase</span><span class="hljs-params">(String anotherString)</span>：与equals方法类似，忽略大小写String <span class="hljs-title">concat</span><span class="hljs-params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”<span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(String anotherString)</span>：比较两个字符串的大小String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="hljs-title">endIndex</span><span class="hljs-params">(不包含)</span>的一个子字符串。<span class="hljs-keyword">boolean</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(String suffix)</span>：测试此字符串是否以指定的后缀结束<span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span>：测试此字符串是否以指定的前缀开始<span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix, <span class="hljs-keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="hljs-keyword">char</span> 值序列时，返回 trueint <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引<span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引<span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索注：indexOf和lastIndexOf方法如果未找到都是返回-1替换：String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> oldChar, <span class="hljs-keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。String <span class="hljs-title">replace</span><span class="hljs-params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。String <span class="hljs-title">replaceAll</span><span class="hljs-params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。String <span class="hljs-title">replaceFirst</span><span class="hljs-params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。匹配:<span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。切片：String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex)</span>：根据给定正则表达式的匹配拆分此字符串。String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex, <span class="hljs-keyword">int</span> limit)</span>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span><br></code></pre></td></tr></table></figure><p>String 和 基本数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)// 基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)int age = 198;String strAge = String.valueOf(age);  // 基本数据类型和包装类转换字符串int i = Integer.parseInt(strAge);   // 字符串转基本数据类型System.out.println(i == age);   // trueSystem.out.println(strAge instanceof String); // true</span><br></code></pre></td></tr></table></figure><p>String 和 char[] 数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//        String --&gt; char[]:调用String的toCharArray()//        char[] --&gt; String:调用String的构造器String name = &quot;anzhen&quot;;char[] chars = name.toCharArray();  // 转换成字符数组String s = new String(chars);  //  转换字符串System.out.println(s == name); // false  解释如下: 通过new的对象生成在堆里面System.out.println(s.intern() == name); // true</span><br></code></pre></td></tr></table></figure><p>String 和 byte[] 数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">编码：String --&gt; <span class="hljs-keyword">byte</span>[]:调用String的getBytes()解码：<span class="hljs-keyword">byte</span>[] --&gt; String:调用String的构造器编码：字符串 --&gt;字节  (看得懂 ---&gt;看不懂的二进制数据)解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。String name = <span class="hljs-string">&quot;anzhen&quot;</span>;<span class="hljs-keyword">byte</span>[] bytes = name.getBytes(StandardCharsets.UTF_8);<span class="hljs-comment">// 设置标准字符集String s = new String(bytes);System.out.println(Arrays.toString(bytes));System.out.println(s);</span><br></code></pre></td></tr></table></figure><p>​    </p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合类的关系图</p><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210416205008922.png" alt="image-20210416205008922"></p></blockquote><p>接口中定义的方法</p><blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210416205148905.png" alt="image-20210416205148905"></p></blockquote><p>collection 与 数组的转换 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">调用 toArray()<br></code></pre></td></tr></table></figure><p>数组  转换为  集合 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">通过  Arrays.asList()<br></code></pre></td></tr></table></figure><p>使用Collection集合存储对象，要求对象所属的类满足：</p><blockquote><p>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</p></blockquote><p>迭代器接口</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">GOF给迭代器模式的定义为：提供一种方法访问一个容器(<span class="hljs-built_in">container</span>)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection list = <span class="hljs-keyword">new</span> ArrayList();  <span class="hljs-comment">// 创建集合对象list.add(&quot;anzhne&quot;);list.add(&quot;age&quot;);list.add(11);Iterator iterator = list.iterator();// 获取拦截器while (iterator.hasNext())&#123;     // 判断是否下一个元素存在    System.out.println(iterator.next());      // 指针下移  进行输出&#125;</span><br></code></pre></td></tr></table></figure><p>collection 接口和  list接口主要的实现类</p><h5 id="List-接口以及实现类"><a href="#List-接口以及实现类" class="headerlink" title="List 接口以及实现类"></a>List 接口以及实现类</h5><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p><ul><li>|—-List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组<ul><li><pre><code> |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</code></pre></li><li><pre><code> |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</code></pre></li><li><pre><code> |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</code></pre></li></ul></li></ul><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>底层源码解析</p><p>疑问1: new 的时候有没有分配大小？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用空参构造器的时候  创建的是this.elementData =      DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  // 这个常量默认等于空只要调用add方法的时候才会创建长度为10的element数组</span><br></code></pre></td></tr></table></figure><p>特点： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">排列有序，可重复底层使用数组查询速度修改速度快  增加和删除慢线程不安全当容量不足时 arraylist的当前容量*<span class="hljs-number">1.5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList list = <span class="hljs-keyword">new</span> LinkedList(); 内部声明了Node类型的first和last属性，默认值为<span class="hljs-keyword">null</span>*      list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//将123封装到Node中，创建了Node对象。**      其中，Node定义为：体现了LinkedList的双向链表的说法private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        this.item = element;        this.next = next;        this.prev = prev;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>特点：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">增加和删除快  但是查询和修改效率不高底层使用的是双向链表 有序的, 可重复的线程不安全<br></code></pre></td></tr></table></figure><h6 id="Vector-已经废用"><a href="#Vector-已经废用" class="headerlink" title="Vector: (已经废用)"></a>Vector: (已经废用)</h6><blockquote><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p></blockquote><h5 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h5><p>set接口特性 ：</p><blockquote><p>无序性， 不可重复的元素</p></blockquote><p>子类 </p><h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><blockquote><p>底层是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">// initial capacity (16) and load factor (0.75).public HashSet() &#123;   map = new HashMap&lt;&gt;();&#125;// 初始化默认长度是 16  加载因子是0.75</span><br></code></pre></td></tr></table></figure><p>无序排列 ， 元素不重复</p><p>存取速度快</p><p>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。</p></blockquote><h6 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h6><blockquote><p>无序排列 ， 元素不重复</p><p>底层实现：二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,Object&gt;());&#125;<br></code></pre></td></tr></table></figure><p>可以自定义排序 </p></blockquote><h6 id="LinkedSet"><a href="#LinkedSet" class="headerlink" title="LinkedSet"></a>LinkedSet</h6><blockquote><p>采用hash表存储，并用双向链表记录插入顺序</p><p>内部是LinkedHashMap</p><p>默认容量和加载因子是 16 ， 0.75</p></blockquote><p>使用Set集合存储对象时， 注意事项</p><blockquote><p>HashSet/LinkedHashSet:</p><p>要求：</p><blockquote><p>向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</p></blockquote><blockquote><p>重写的hashCode()和equals()尽可能保持一致性：</p></blockquote><blockquote><p>相等的对象必须具有相等的散列码</p></blockquote><ul><li><p>   重写两个方法的小技巧：</p></li><li><p>   对象中用作 equals() 方法比较的 Field，</p></li><li><p>   都应该用来计算 hashCode 值。</p></li></ul><p>TreeSet:<br>1.自然排序中，比较两个对象是否相同的标准为：</p><blockquote><p>compareTo()返回0.不再是equals().</p></blockquote><p>2.定制排序中，比较两个对象是否相同的标准为：</p><blockquote><p>compare()返回0.不再是equals().</p></blockquote></blockquote><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h5><p>子类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap  HashTable  （线程安全）TreeMap (可排序)LinkHashMap（记录插入顺序）<br></code></pre></td></tr></table></figure><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><blockquote><p>HashMap根据<strong>键的hashCode</strong>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。<strong>HashMap非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 <strong>Collections的synchronizedMap方法使HashMap具有线程安全的能力</strong>，或者使用<strong>ConcurrentHashMap。</strong></p></blockquote><p><img src="/2021/06/15/JavaSeRelearn/image-20210417151158049.png" alt="image-20210417151158049"></p><p>当单链表长度大于8时候  单链表变成红黑树</p><h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable:"></a>HashTable:</h6><blockquote><p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是<strong>线程安全</strong>的，任一时间只有一个线程能写Hashtable，<strong>并发性不如ConcurrentHashMap</strong>，因为<strong>ConcurrentHashMap引入了分段锁</strong>。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。****</p></blockquote><h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><blockquote><p>TreeMap实现<strong>SortedMap接口</strong>，能够把<strong>它保存的记录根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。 如果使用排序的映射，建议使用TreeMap。 在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p></blockquote><h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap:"></a>LinkedHashMap:</h6><blockquote><p><strong>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</strong></p></blockquote><p>如何把线程不安全的集合类变得线程安全？？</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;# 回答如下第一种方式 : ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程安全的。使用synchronizedList(List list） 和 synchronizedMap(Map map）给集合类加锁# 第二种使用线程安全的集合类// 线程安全的集合类 arraylist线程安全类CopyOnWriteArrayList// map 集合线程安全类ConcurrentHashMap<br></code></pre></td></tr></table></figure></blockquote><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>集合中使用泛型和不使用泛型的区别</p><blockquote><p>任何类型都可以添加到集合中，类型不安全</p><p>读取出来的数据需要强转， 太过于繁琐</p></blockquote><p>集合泛型总结</p><blockquote><ul><li>① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。</li></ul><ul><li> ② 在实例化集合类时，可以指明具体的泛型类型</li><li> ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</li><li> 比如：add(E e)  —&gt;实例化以后：add(Integer e)</li><li> ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li><li> ⑤ 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。</li></ul></blockquote><h3 id="Class-反射"><a href="#Class-反射" class="headerlink" title="Class 反射"></a>Class 反射</h3><p>Class 反射概念  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<span class="hljs-comment"># 框架 = 反射 + 注解 + 设计模式。3.体会反射机制的“动态性”</span><br></code></pre></td></tr></table></figure><p>类加载过程：</p><blockquote><p>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</p><p>2.换句话说，Class的实例就对应着一个运行时类。</p><p>3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p></blockquote><p>获取class实例的四种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;System.out.println(personClass.getClassLoader());  //  AppClassLoader// 通过对象获取classPerson person = new Person();Class&lt;? extends Person&gt; aClass = person.getClass(); // 获取class对象System.out.println(aClass.getName());  //  获取全类名// 调用Class的静态方法Class&lt;?&gt; person1 = Class.forName(&quot;com.anzhen.io.Person&quot;);System.out.println(person1);// 使用类加载器加载ClassLoader classLoader = ClassLearn.class.getClassLoader();Class&lt;?&gt; aClass1 = classLoader.loadClass(&quot;com.anzhen.io.Person&quot;);// 加载classSystem.out.println(aClass1);</span><br></code></pre></td></tr></table></figure><p>通过反射创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;// 通过反射获取对象Person person = personClass.newInstance();System.out.println(person);</span><br></code></pre></td></tr></table></figure><p>获取全部权限为public的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] fields = personClass.getFields();<span class="hljs-comment">// 只能获取权限为public的for (Field field : fields) &#123;    System.out.println(field);&#125;</span><br></code></pre></td></tr></table></figure><p>获取全部属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] declaredFields = personClass.getDeclaredFields();  <span class="hljs-comment">// 获取全部属性的信息 包括私有的（不包含父类的）for (Field declaredField : declaredFields) &#123;    System.out.println(declaredField);&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz = Person.class;<span class="hljs-comment">//getConstructors():获取当前运行时类中声明为public的构造器Constructor[] constructors = clazz.getConstructors();for(Constructor c : constructors)&#123;    System.out.println(c);&#125;System.out.println();//getDeclaredConstructors():获取当前运行时类中声明的所的构造器Constructor[] declaredConstructors = clazz.getDeclaredConstructors();for(Constructor c : declaredConstructors)&#123;System.out.println(c);&#125;// 获取父类Class superclass = clazz.getSuperclass();System.out.println(superclass);        // 获取父类泛型Type genericSuperclass = clazz.getGenericSuperclass();System.out.println(genericSuperclass);</span><br></code></pre></td></tr></table></figure><p>通过class 创建实例打开私有权限 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;// 通过反射获取对象Person person = personClass.newInstance();person.setName(&quot;anzhen&quot;);person.setAge(19);Field age = personClass.getDeclaredField(&quot;age&quot;);// 打开权限age.setAccessible(true);System.out.println(age.get(person));</span><br></code></pre></td></tr></table></figure><p>通过class 调用方法 和 静态方法</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSe</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
