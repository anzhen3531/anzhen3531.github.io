<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JavaSeRelearn | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="javaSe  复习数据类型java 数据类型的取值范围   byte 字节型 -128～127 -2^7～2^7-1 1字节 short 短整型 -32768～32767 -2^15～2^15-12字节 int 整型 -2147483648～2147483647 -2^31～2^31-1 4字节 long 长整型 -9223372036854775808～9223372036854775807">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSeRelearn">
<meta property="og:url" content="http://example.com/2021/06/15/JavaSeRelearn/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="javaSe  复习数据类型java 数据类型的取值范围   byte 字节型 -128～127 -2^7～2^7-1 1字节 short 短整型 -32768～32767 -2^15～2^15-12字节 int 整型 -2147483648～2147483647 -2^31～2^31-1 4字节 long 长整型 -9223372036854775808～9223372036854775807">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210411184500602.png">
<meta property="og:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210411184639758.png">
<meta property="og:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210414104116418.png">
<meta property="og:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210414155458289.png">
<meta property="og:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210416205008922.png">
<meta property="og:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210416205148905.png">
<meta property="og:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210417151158049.png">
<meta property="article:published_time" content="2021-06-15T08:29:53.000Z">
<meta property="article:modified_time" content="2021-06-15T08:32:26.075Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/06/15/JavaSeRelearn/image-20210411184500602.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JavaSeRelearn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/15/JavaSeRelearn/" class="article-date">
  <time class="dt-published" datetime="2021-06-15T08:29:53.000Z" itemprop="datePublished">2021-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JavaSeRelearn
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="javaSe-复习"><a href="#javaSe-复习" class="headerlink" title="javaSe  复习"></a>javaSe  复习</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java 数据类型的取值范围 </p>
<blockquote>
<p>byte 字节型 -128～127 -2^7～2^7-1 1字节</p>
<p>short 短整型 -32768～32767 -2^15～2^15-12字节</p>
<p>int 整型 -2147483648～2147483647 -2^31～2^31-1 4字节</p>
<p>long 长整型 -9223372036854775808～9223372036854775807 -2^63～2^-1 8字节</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> i = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">long</span> s = <span class="number">1000L</span>;</span><br><span class="line"><span class="keyword">long</span> l = s - i;</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当容量小的数据类型与容量大的数据类型的变量做运算时, 结果会自动提升为容量大的数据类型</p>
</blockquote>
<p>位运算符 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【特别说明的】</span><br><span class="line">1. 位运算符操作的都是整型的数据</span><br><span class="line">2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2</span><br><span class="line">&gt;&gt; :在一定范围内，每向右移1位，相当于 / 2</span><br></pre></td></tr></table></figure>

<p>流程控制 </p>
<p>switch 语法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	执行语句n;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>数组数据类型 </p>
<p>数组的特点</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 1数组是序排列的</span><br><span class="line"><span class="bullet">*</span> 2数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</span><br><span class="line"><span class="bullet">*</span> 3创建数组对象会在内存中开辟一整块连续的空间</span><br><span class="line"><span class="bullet">*</span> 4数组的长度一旦确定，就不能修改。</span><br></pre></td></tr></table></figure>



<p>数组的创建方式</p>
<ol>
<li><p>直接声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[]  array;   </span><br></pre></td></tr></table></figure></li>
<li><p>静态初始化： 数组初始化和数组元素赋值同时进行 </p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] array = &#123;1,2 ,3, 4&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>动态初始化：数组的初始化和数组元素的赋值操作分开进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明数组时 指定长度 默认数组的所有元素初始化为null </span></span><br><span class="line">String[] strings = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li>
</ol>
<p>‘ Arrays 工具类的使用’</p>
<blockquote>
<p>boolean equals(int[] a,int[] b)  :判断两个数组是否相等。<br>String toString(int[] a)  :输出数组信息。<br>void fill(int[] a,int val)  :将指定值填充到数组之中<br>void sort(int[] a)  :对数组进行排序<br>int binarySearch(int[] a,int key) :  从数组中查找key    </p>
</blockquote>
<h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><p>理解”<strong>万事万物皆对象</strong>“  </p>
<p>1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构</p>
<ul>
<li><blockquote>
<p>Scanner,String等</p>
</blockquote>
</li>
<li><blockquote>
<p>文件：File</p>
</blockquote>
</li>
<li><blockquote>
<p>网络资源：URL</p>
</blockquote>
</li>
</ul>
<p>2.涉及到Java语言与前端<strong>Html</strong>、后端的数据库交互时<strong>，前后端的结构在Java层面交互时</strong>，都体现为<strong>类、对象</strong>。</p>
<p>类的属性和局部变量的不同以及差异</p>
<blockquote>
<p>对比：属性  vs  局部变量</p>
<p>1.相同点：</p>
<ul>
<li><pre><code>    1.1  定义变量的格式：数据类型  变量名 = 变量值
</code></pre>
</li>
<li><pre><code>    1.2 先声明，后使用
</code></pre>
</li>
<li><pre><code>    1.3 变量都其对应的作用域 
</code></pre>
</li>
</ul>
<p>2.不同点：<br>       2.1 在类中声明的位置的不同</p>
<ul>
<li><pre><code>    属性：直接定义在类的一对&#123;&#125;内
</code></pre>
</li>
<li><pre><code>    局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
</code></pre>
</li>
</ul>
<p> 2.2 关于权限修饰符的不同</p>
<ul>
<li><pre><code>    属性：可以在声明属性时，指明其权限，使用权限修饰符。
</code></pre>
</li>
<li><pre><code>    常用的权限修饰符：private、public、缺省、protected  ---&gt;封装性
</code></pre>
</li>
<li><pre><code>    目前，大家声明属性时，都使用缺省就可以了。
</code></pre>
</li>
<li><pre><code>    局部变量：不可以使用权限修饰符。
</code></pre>
</li>
</ul>
<p> 2.3 默认初始化值的情况：</p>
<ul>
<li><pre><code>    属性：类的属性，根据其类型，都默认初始化值。
</code></pre>
</li>
<li><pre><code>    整型（byte、short、int、long：0）
</code></pre>
</li>
<li><pre><code>    浮点型（float、double：0.0）
</code></pre>
</li>
<li><pre><code>    字符型（char：0  （或&#39;\u0000&#39;））
</code></pre>
</li>
<li><pre><code>    布尔型（boolean：false）
</code></pre>
</li>
</ul>
<ul>
<li><pre><code>        引用数据类型（类、数组、接口：null）
</code></pre>
</li>
<li><pre><code>        局部变量：没默认初始化值。
</code></pre>
</li>
<li><pre><code>        意味着，我们在调用局部变量之前，一定要显式赋值。
</code></pre>
</li>
<li><pre><code>        特别地：形参在调用时，我们赋值即可。
</code></pre>
</li>
</ul>
<p> 2.4 在内存中加载的位置：</p>
<ul>
<li><pre><code>    属性：加载到**堆空间**中   （非static）
</code></pre>
</li>
<li><pre><code>    局部变量：加载到操作数栈
</code></pre>
</li>
</ul>
</blockquote>
<h4 id="为什么-需要封装"><a href="#为什么-需要封装" class="headerlink" title="为什么 需要封装"></a>为什么 需要封装</h4><blockquote>
<p>我们程序设计追求“高内聚，低耦合”。</p>
<p>高内聚 ：<strong>类的内部数据操作细节自己完成，不允许外部干涉；</strong><br>低耦合 ：<strong>仅对外暴露少量的方法用于使用。</strong></p>
</blockquote>
<p>封装概念以及思想</p>
<blockquote>
<p>隐藏对象内部的复杂性，只对外公开简单的接口。</p>
<p>便于外界调用，从而提高系统的可扩展性、可维护性。</p>
<p>通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
</blockquote>
<p>封装的具体的代码实现</p>
<ul>
<li><blockquote>
<p>将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p>
</blockquote>
</li>
<li><blockquote>
<p>不对外暴露的私有的方法</p>
</blockquote>
</li>
<li><blockquote>
<p>单例模式（将构造器私有化）****</p>
</blockquote>
</li>
<li><blockquote>
<p>如果不希望类在包外被调用，可以将类设置为缺省的。</p>
</blockquote>
</li>
</ul>
<p>java的权限修饰符 </p>
<blockquote>
<p>private &lt;  缺省 &lt; protected &lt; public</p>
</blockquote>
<p>四个属性修饰的范围 </p>
<blockquote>
<p>4种权限都可以用来修饰<strong>类的内部结构</strong>：<strong>属性、方法、构造器、内部类</strong></p>
</blockquote>
<blockquote>
<p>修饰类的话，只能使用：<strong>缺省、public</strong></p>
</blockquote>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote>
<p>2.使用说明：</p>
<ul>
<li>1.如果没显式的定义类的构造器的话，则系统默认提供一个<strong>空参的构造器</strong></li>
<li>2.定义构造器的格式：<strong>权限修饰符  类名(形参列表){}</strong></li>
<li>3.一个类中定义的多个构造器，<strong>彼此构成重载</strong></li>
<li>4.一旦我们显式的定义了类的构造器之后，<strong>系统就不再提供默认的空参构造器</strong></li>
<li>5.一个类中，至少<strong>会有一个构造器。</strong></li>
</ul>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>// 面向对象三大特性  ：  封装  继承  多态 </p>
<ul>
<li>不使用继承前的代码 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> Date   birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + age + birthDate);</span><br><span class="line">        <span class="keyword">return</span>  name + age + birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生类 class Student&#123;    public String name;    public Integer age;    public Date   birthDate;    public String schoolName;    public String  getInfo()&#123;        System.out.println(name + age + birthDate);        return  name + age + birthDate;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用继承之后的代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明父类class People&#123;    public String name;    public Integer age;    public Date   birthDate;    public String  getInfo()&#123;        System.out.println(name + age + birthDate);        return  name + age + birthDate;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生类class Student extends People&#123;    public String schoolName;&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过上述的代码：  ——&gt; 得出的结论为 ：   继承可以减少代码冗余     提高可复用性</p>
</li>
</ul>
<p>  作用：</p>
<blockquote>
<p>继承的出现减少了代码冗余   提高了代码的复用性。<br>继承的出现，更有利于功能的扩展。<br>继承 的出现让类与类之间产生了 关系 ，提供了多态的 前提 。</p>
<blockquote>
<p>注意：<strong>不要 仅为了获取其他类中某个功能而去继承</strong></p>
</blockquote>
</blockquote>
<p>  为什么要有继承 ？？？</p>
<blockquote>
<p>多个类中存在<strong>相同属性和行为</strong>时，将这些内容抽取到单独一个类中，<br>那么<strong>多个类无需再定义这些属性和行为</strong>，只要继承那个类即可。</p>
</blockquote>
<p>​    </p>
<p>子类是不是能操作父类的全部的数据呢 ？？ </p>
<blockquote>
<p>不是， 子类不能直接访问父类私有的属性以及方法</p>
</blockquote>
<p>java是不是属于多继承呢 ？？ </p>
<blockquote>
<p>java 是单继承   一个子类只能有一个父类    一个父类可以有多个子类</p>
</blockquote>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>子类重写父类的定义：：</p>
<blockquote>
<p>在子类中可以根据需要对从<strong>父类中继承来的方法进行改造</strong> 也称<br>为方法 的 重置、覆盖 。在程序执行时，<strong>子类的方法将覆盖父类的方法。</strong>  </p>
</blockquote>
<p>注意事项：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 子类与父类中同名同参数的方法必须同时声明 为  非static的 (即为重写)，或者同时声明 为static 的不是重写 。因为 static方法是属于类的，子类无法覆盖父类的方法。</span></span><br></pre></td></tr></table></figure>

<p>要求</p>
<ol>
<li><p>子类重写的方法 必须和父类被重写的方法 具有<strong>相同的 方法名称、 参数 列表</strong></p>
</li>
<li><p>子类<strong>重写的方法的返回值类型</strong>不能大于   <strong>父类被重写的方法的返回值类型</strong></p>
</li>
<li><p>子类<strong>重写的方法使用的访问权限</strong> 不能小于 父类被重写的方法的访问权限</p>
<ol>
<li><blockquote>
<p>子类<strong>不能重写父类中声明为 private 权限的方法</strong></p>
</blockquote>
</li>
</ol>
</li>
<li><p>子类<strong>方法抛出的异常</strong>不能大于<strong>父类被重写方法的异常</strong></p>
</li>
</ol>
<p>问题： 重写和重载的区别 :</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 方法的重写Overriding和重载Overloading是Java多态性的不同表现。2. 重写Overriding是父类与子类之间多态性的一种表现，3. 重载Overloading是一个类中多态性的一种表现。4. 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&quot;屏蔽&quot;了。5. 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。</span><br></pre></td></tr></table></figure>



<h4 id="super关键词"><a href="#super关键词" class="headerlink" title="super关键词"></a>super关键词</h4><blockquote>
<p><img src="/2021/06/15/JavaSeRelearn/image-20210411184500602.png" alt="image-20210411184500602"></p>
</blockquote>
<p>this  和  super的区别</p>
<blockquote>
<p><img src="/2021/06/15/JavaSeRelearn/image-20210411184639758.png" alt="image-20210411184639758"></p>
</blockquote>
<p>面试题：  ==  和  equasl 的区别 </p>
<blockquote>
<p>== 既可以比较 地址值和数据值    </p>
<p>对于基本类型比较的是值   对于引用类型比较的就是地址</p>
<p>具体 要看自定义类里有没有 重写 Object 的 equals 方法来 判断。</p>
<p>通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。</p>
</blockquote>
<h3 id="字符串和基本数据类型之间的互相转换"><a href="#字符串和基本数据类型之间的互相转换" class="headerlink" title="字符串和基本数据类型之间的互相转换"></a>字符串和基本数据类型之间的互相转换</h3><p><strong>String 转换成基本数据类型的方法</strong></p>
<p><strong>基本数据类型转换String</strong> </p>
<p><img src="/2021/06/15/JavaSeRelearn/image-20210414104116418.png" alt="image-20210414104116418"></p>
<h3 id="interface-gt-abstract"><a href="#interface-gt-abstract" class="headerlink" title="interface   -&gt;  abstract"></a>interface   -&gt;  abstract</h3><p>接口和抽象类有什么不同点和共同点</p>
<p>相同点：</p>
<blockquote>
<p>不能实例化    -    都可以包含抽象方法</p>
</blockquote>
<p> 不同点：</p>
<blockquote>
<p>类： 单继承      接口： 多继承  </p>
<p>类与接口 ： 多实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interfaceLearn</span>   <span class="keyword">extends</span> <span class="title">Service</span>  <span class="keyword">implements</span> <span class="title">Dao</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 接口可以调用接口的静态方法        Dao.tses(new Object());        // 默认方法 通过接口的实现类进行调用  如果接口的实现复写了改方法 就调用接口实现者的方法        Dao dao = new interfaceLearn();        // 调用默认方法        // 调用的是抽象类的方法   执行类有先的原则        dao.test();        /**         *  service -&gt;  执行         * java.lang.Object@1b6d3586         * Service-&gt;   test         */    &#125;&#125;interface Dao&#123;    // 结构中可以声明静态方法    static void tses(Object o)&#123;        System.out.println(o);    &#125;    // 接口中的默认方法    default void  test()&#123;        System.out.println(&quot;interface  -&gt; default  -&gt;   test&quot;);    &#125;&#125;abstract class Service&#123;    // 抽象类中声明静态代码块    static &#123;        System.out.println(&quot; service -&gt;  执行&quot;);    &#125;    // 定义普通方法     public void  test()&#123;         System.out.println(&quot;Service-&gt;   test&quot;);     &#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h3><p>疑问 ： </p>
<ul>
<li>线程声明周期 ：</li>
</ul>
<p><img src="/2021/06/15/JavaSeRelearn/image-20210414155458289.png" alt="image-20210414155458289"></p>
<ul>
<li> 创建多线程有多少方法</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 第一种：  通过继承Thread类然后   调用start()进行创建# 第二种： 通过继承runnable()    接口进行创建# 第三种： 通过继承callable 接口进行创建   （带有泛型和返回值）# 第四种： 通过线程池创建</span></span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 使用线程        new MyThread().start();        // 使用runnable 实现接口        new Thread(new RunnableLearn()).start();        // 实现 callable接口 注意这个接口需要使用别的扩展类进行创建线程        new Thread(new FutureTask&lt;&gt;(new CallableLearn())).start();        // 使用线程池创建   创建线程池        System.out.println(&quot;线程池执行 = 》   》》》 》》》   》》&quot;);        ExecutorService executorService = Executors.newFixedThreadPool(10);        executorService.execute(new MyThread());        executorService.execute(new RunnableLearn());        // 执行 callable接口        executorService.execute(new FutureTask&lt;&gt;(new CallableLearn()));        executorService.shutdown();    &#125;&#125;// 创建线程第一种方法class MyThread extends Thread&#123;    @Override    public void run() &#123;        System.out.println(&quot;MyThread  -&gt;  run&quot;);    &#125;&#125;// 第二种创建线程方法  通过 runnable接口class RunnableLearn implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(&quot;runnable  -&gt;  run&quot;);    &#125;&#125;// 第三种方式通过实现callable 接口  该接口带有泛型  泛型就表示call方法返回值class CallableLearn implements Callable&lt;Object&gt; &#123;    @Override    public Object call() throws Exception &#123;        System.out.println(&quot; callable  -&gt;  run&quot;);        return new String(&quot;callable run&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>



<p>Java里面线程池的<strong>顶级接口是Executor</strong>，但是<strong>严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。</strong>真正的<strong>线程池接口是ExecutorService。</strong></p>
<p>线程池有几种 ？    四种</p>
<p>分别是什么   功能以及优缺点？ </p>
<ul>
<li><blockquote>
<h1 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h1><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p>
</blockquote>
</li>
<li><blockquote>
<h1 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h1><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
</blockquote>
</li>
</ul>
<ul>
<li><blockquote>
<h1 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h1><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
</blockquote>
</li>
<li><blockquote>
<h1 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h1><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p>
</blockquote>
</li>
</ul>
<h4 id="线程池-源码解析"><a href="#线程池-源码解析" class="headerlink" title="线程池 源码解析"></a><strong>线程池 源码解析</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">都是通过 <span class="keyword">new</span> ThreadPoolExecutor 进行创建的线程池     <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,  <span class="comment">// 核心线程数 process + 1,   // 最大线程数 ==  电脑线程数 + 12L,   // 存活时间 TimeUnit.SECONDS,  // 时间单位new LinkedBlockingQueue&lt;&gt;(3),  // 创建长度为三的阻塞队列  Executors.defaultThreadFactory(),     //   默认线程工厂    //new ThreadPoolExecutor.AbortPolicy() // 出场默认中止策略    //new ThreadPoolExecutor.CallerRunsPolicy()   // 处理不掉的 任务返回给委派任务者    //new ThreadPoolExecutor.DiscardPolicy()  //  抛弃任务中的等待时间最长的任务，然后把当前任务加入队列中，尝试再次提交当前任务   不抛出异常    new ThreadPoolExecutor.DiscardOldestPolicy()   // 该策略默默丢弃一些无法处理的任务,不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略);</span></span><br></pre></td></tr></table></figure>

<h4 id="线程锁："><a href="#线程锁：" class="headerlink" title="线程锁："></a>线程锁：</h4><p>概念暂无 ：“</p>
<p>详情查看书籍 :   java重点总结</p>
<p>Start 和  run 方法的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start与run区别 1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码。2. 通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 3. 方法run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行run函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</span><br></pre></td></tr></table></figure>



<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h4><p>源码分析： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>          <span class="title">private</span> <span class="title">final</span> <span class="title">char</span> <span class="title">value</span>[]</span>;    <span class="comment">// String 是final修饰的， 是不能被修改的// 实现了 Serializable接口实现了序列化// 实现了Comparable接口  可以进行比较// String底层默认使用字符数组进行存储</span></span><br></pre></td></tr></table></figure>



<p>字符串实例方式  以及差异 </p>
<blockquote>
<p>第一种方式通过字符字面量进行创建</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;anzhen&quot;</span>; <span class="comment">// 直接创建在常量池    </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种通过new  String 进行创建    </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String names = <span class="keyword">new</span> String(<span class="string">&quot;anzhen&quot;</span>);System.out.println(names == name); <span class="comment">// 比较地址值// 返回值为false</span></span><br></pre></td></tr></table></figure>

<p>请问new String() 开辟了 几块内存 </p>
<blockquote>
<p>两个: 一个是<strong>堆空间中new结构</strong>，另一个是<strong>char[]对应的常量池中的数据</strong>：”abc”</p>
</blockquote>
<p>创建过程如下： </p>
<blockquote>
<p>先在堆空间开辟对象，然后查找字符串常量池中查找传入的值  </p>
<p>如果字符串常量池中存在则把字符串常量地址复制给value</p>
</blockquote>
<p>检验如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = names.intern();   <span class="comment">// intern 将字符串的值推向常量池  如果常量池存在则把常量池对象地址赋值给变量System.out.println(names == name);  // 比较地址值</span></span><br></pre></td></tr></table></figure>

<p>字符串拼接：</p>
<blockquote>
<p>常量和常量拼接在字符串常量池   常量池不会存在相同的常量</p>
<p>只要<strong>其中一个是变量</strong>结果就在<strong>堆中</strong></p>
<p>如果拼接的字符串的结果调用了 <strong>intern()</strong> 方法， 返回值就在常量池中</p>
</blockquote>
<p>string 常用api </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>：返回字符串的长度： return value.lengthchar <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index]<span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断是否是空字符串：return value.length </span>== 0<span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所字符转换为小写String <span class="title">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所字符转换为大写String <span class="title">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白<span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同<span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写String <span class="title">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”<span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串。<span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束<span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始<span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时，返回 trueint <span class="title">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引<span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引<span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索注：indexOf和lastIndexOf方法如果未找到都是返回-1替换：String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。匹配:<span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。切片：String[] <span class="title">split</span><span class="params">(String regex)</span>：根据给定正则表达式的匹配拆分此字符串。String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br></pre></td></tr></table></figure>

<p>String 和 基本数据类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)// 基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)int age = 198;String strAge = String.valueOf(age);  // 基本数据类型和包装类转换字符串int i = Integer.parseInt(strAge);   // 字符串转基本数据类型System.out.println(i == age);   // trueSystem.out.println(strAge instanceof String); // true</span></span><br></pre></td></tr></table></figure>

<p>String 和 char[] 数据类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        String --&gt; char[]:调用String的toCharArray()//        char[] --&gt; String:调用String的构造器String name = &quot;anzhen&quot;;char[] chars = name.toCharArray();  // 转换成字符数组String s = new String(chars);  //  转换字符串System.out.println(s == name); // false  解释如下: 通过new的对象生成在堆里面System.out.println(s.intern() == name); // true</span></span><br></pre></td></tr></table></figure>

<p>String 和 byte[] 数据类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编码：String --&gt; <span class="keyword">byte</span>[]:调用String的getBytes()解码：<span class="keyword">byte</span>[] --&gt; String:调用String的构造器编码：字符串 --&gt;字节  (看得懂 ---&gt;看不懂的二进制数据)解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。String name = <span class="string">&quot;anzhen&quot;</span>;<span class="keyword">byte</span>[] bytes = name.getBytes(StandardCharsets.UTF_8);<span class="comment">// 设置标准字符集String s = new String(bytes);System.out.println(Arrays.toString(bytes));System.out.println(s);</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合类的关系图</p>
<blockquote>
<p><img src="/2021/06/15/JavaSeRelearn/image-20210416205008922.png" alt="image-20210416205008922"></p>
</blockquote>
<p>接口中定义的方法</p>
<blockquote>
<p><img src="/2021/06/15/JavaSeRelearn/image-20210416205148905.png" alt="image-20210416205148905"></p>
</blockquote>
<p>collection 与 数组的转换 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用 toArray()</span><br></pre></td></tr></table></figure>

<p>数组  转换为  集合 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过  Arrays.asList()</span><br></pre></td></tr></table></figure>



<p>使用Collection集合存储对象，要求对象所属的类满足：</p>
<blockquote>
<p>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</p>
</blockquote>
<p>迭代器接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection list = <span class="keyword">new</span> ArrayList();  <span class="comment">// 创建集合对象list.add(&quot;anzhne&quot;);list.add(&quot;age&quot;);list.add(11);Iterator iterator = list.iterator();// 获取拦截器while (iterator.hasNext())&#123;     // 判断是否下一个元素存在    System.out.println(iterator.next());      // 指针下移  进行输出&#125;</span></span><br></pre></td></tr></table></figure>



<p>collection 接口和  list接口主要的实现类</p>
<h5 id="List-接口以及实现类"><a href="#List-接口以及实现类" class="headerlink" title="List 接口以及实现类"></a>List 接口以及实现类</h5><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p>
<ul>
<li>|—-List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组<ul>
<li><pre><code> |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储
</code></pre>
</li>
<li><pre><code> |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储
</code></pre>
</li>
<li><pre><code> |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>底层源码解析</p>
<p>疑问1: new 的时候有没有分配大小？ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用空参构造器的时候  创建的是this.elementData =      DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  // 这个常量默认等于空只要调用add方法的时候才会创建长度为10的element数组</span></span><br></pre></td></tr></table></figure>

<p>特点： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排列有序，可重复底层使用数组查询速度修改速度快  增加和删除慢线程不安全当容量不足时 arraylist的当前容量*<span class="number">1.5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); 内部声明了Node类型的first和last属性，默认值为<span class="keyword">null</span>*      list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。**      其中，Node定义为：体现了LinkedList的双向链表的说法private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) 			&#123;        this.item = element;        this.next = next;        this.prev = prev;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">增加和删除快  但是查询和修改效率不高底层使用的是双向链表 有序的, 可重复的线程不安全</span><br></pre></td></tr></table></figure>



<h6 id="Vector-已经废用"><a href="#Vector-已经废用" class="headerlink" title="Vector: (已经废用)"></a>Vector: (已经废用)</h6><blockquote>
<p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p>
</blockquote>
<h5 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h5><p>set接口特性 ：</p>
<blockquote>
<p>无序性， 不可重复的元素</p>
</blockquote>
<p>子类 </p>
<h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><blockquote>
<p>底层是HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// initial capacity (16) and load factor (0.75).public HashSet() &#123;   map = new HashMap&lt;&gt;();&#125;// 初始化默认长度是 16  加载因子是0.75</span></span><br></pre></td></tr></table></figure>

<p>无序排列 ， 元素不重复</p>
<p>存取速度快</p>
<p>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。</p>
</blockquote>
<h6 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h6><blockquote>
<p>无序排列 ， 元素不重复</p>
<p>底层实现：二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());&#125;</span><br></pre></td></tr></table></figure>

<p>可以自定义排序 </p>
</blockquote>
<h6 id="LinkedSet"><a href="#LinkedSet" class="headerlink" title="LinkedSet"></a>LinkedSet</h6><blockquote>
<p>采用hash表存储，并用双向链表记录插入顺序</p>
<p>内部是LinkedHashMap</p>
<p>默认容量和加载因子是 16 ， 0.75</p>
</blockquote>
<p>使用Set集合存储对象时， 注意事项</p>
<blockquote>
<p>HashSet/LinkedHashSet:</p>
<p>要求：</p>
<blockquote>
<p>向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</p>
</blockquote>
<blockquote>
<p>重写的hashCode()和equals()尽可能保持一致性：</p>
</blockquote>
<blockquote>
<p>相等的对象必须具有相等的散列码</p>
</blockquote>
<ul>
<li><p>   重写两个方法的小技巧：</p>
</li>
<li><p>   对象中用作 equals() 方法比较的 Field，</p>
</li>
<li><p>   都应该用来计算 hashCode 值。</p>
</li>
</ul>
<p>TreeSet:<br>1.自然排序中，比较两个对象是否相同的标准为：</p>
<blockquote>
<p>compareTo()返回0.不再是equals().</p>
</blockquote>
<p>2.定制排序中，比较两个对象是否相同的标准为：</p>
<blockquote>
<p>compare()返回0.不再是equals().</p>
</blockquote>
</blockquote>
<h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h5><p>子类： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap  HashTable  （线程安全）TreeMap (可排序)LinkHashMap（记录插入顺序）</span><br></pre></td></tr></table></figure>



<h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><blockquote>
<p>HashMap根据<strong>键的hashCode</strong>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。<strong>HashMap非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 <strong>Collections的synchronizedMap方法使HashMap具有线程安全的能力</strong>，或者使用<strong>ConcurrentHashMap。</strong></p>
</blockquote>
<p><img src="/2021/06/15/JavaSeRelearn/image-20210417151158049.png" alt="image-20210417151158049"></p>
<p>当单链表长度大于8时候  单链表变成红黑树</p>
<h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable:"></a>HashTable:</h6><blockquote>
<p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是<strong>线程安全</strong>的，任一时间只有一个线程能写Hashtable，<strong>并发性不如ConcurrentHashMap</strong>，因为<strong>ConcurrentHashMap引入了分段锁</strong>。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。****</p>
</blockquote>
<h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><blockquote>
<p>TreeMap实现<strong>SortedMap接口</strong>，能够把<strong>它保存的记录根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。 如果使用排序的映射，建议使用TreeMap。 在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
</blockquote>
<h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap:"></a>LinkedHashMap:</h6><blockquote>
<p><strong>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</strong></p>
</blockquote>
<p>如何把线程不安全的集合类变得线程安全？？</p>
<blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;# 回答如下第一种方式 : ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程安全的。使用synchronizedList(List list） 和 synchronizedMap(Map map）给集合类加锁# 第二种使用线程安全的集合类// 线程安全的集合类 arraylist线程安全类CopyOnWriteArrayList// map 集合线程安全类ConcurrentHashMap</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>集合中使用泛型和不使用泛型的区别</p>
<blockquote>
<p>任何类型都可以添加到集合中，类型不安全</p>
<p>读取出来的数据需要强转， 太过于繁琐</p>
</blockquote>
<p>集合泛型总结</p>
<blockquote>
<ul>
<li>① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。</li>
</ul>
<ul>
<li> ② 在实例化集合类时，可以指明具体的泛型类型</li>
<li> ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</li>
<li> 比如：add(E e)  —&gt;实例化以后：add(Integer e)</li>
<li> ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li>
<li> ⑤ 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。</li>
</ul>
</blockquote>
<h3 id="Class-反射"><a href="#Class-反射" class="headerlink" title="Class 反射"></a>Class 反射</h3><p>Class 反射概念  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<span class="comment"># 框架 = 反射 + 注解 + 设计模式。3.体会反射机制的“动态性”</span></span><br></pre></td></tr></table></figure>



<p>类加载过程：</p>
<blockquote>
<p>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</p>
<p>2.换句话说，Class的实例就对应着一个运行时类。</p>
<p>3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p>
</blockquote>
<p>获取class实例的四种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;System.out.println(personClass.getClassLoader());  //  AppClassLoader// 通过对象获取classPerson person = new Person();Class&lt;? extends Person&gt; aClass = person.getClass(); // 获取class对象System.out.println(aClass.getName());  //  获取全类名// 调用Class的静态方法Class&lt;?&gt; person1 = Class.forName(&quot;com.anzhen.io.Person&quot;);System.out.println(person1);// 使用类加载器加载ClassLoader classLoader = ClassLearn.class.getClassLoader();Class&lt;?&gt; aClass1 = classLoader.loadClass(&quot;com.anzhen.io.Person&quot;);// 加载classSystem.out.println(aClass1);</span></span><br></pre></td></tr></table></figure>

<p>通过反射创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;// 通过反射获取对象Person person = personClass.newInstance();System.out.println(person);</span></span><br></pre></td></tr></table></figure>



<p>获取全部权限为public的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = personClass.getFields();<span class="comment">// 只能获取权限为public的for (Field field : fields) &#123;    System.out.println(field);&#125;</span></span><br></pre></td></tr></table></figure>

<p>获取全部属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] declaredFields = personClass.getDeclaredFields();  <span class="comment">// 获取全部属性的信息 包括私有的（不包含父类的）for (Field declaredField : declaredFields) &#123;    System.out.println(declaredField);&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;<span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器Constructor[] constructors = clazz.getConstructors();for(Constructor c : constructors)&#123;    System.out.println(c);&#125;System.out.println();//getDeclaredConstructors():获取当前运行时类中声明的所的构造器Constructor[] declaredConstructors = clazz.getDeclaredConstructors();for(Constructor c : declaredConstructors)&#123;System.out.println(c);&#125;// 获取父类Class superclass = clazz.getSuperclass();System.out.println(superclass);        // 获取父类泛型Type genericSuperclass = clazz.getGenericSuperclass();System.out.println(genericSuperclass);</span></span><br></pre></td></tr></table></figure>


<p>通过class 创建实例打开私有权限 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类名获取classClass&lt;Person&gt; personClass = Person.class;// 通过反射获取对象Person person = personClass.newInstance();person.setName(&quot;anzhen&quot;);person.setAge(19);Field age = personClass.getDeclaredField(&quot;age&quot;);// 打开权限age.setAccessible(true);System.out.println(age.get(person));</span></span><br></pre></td></tr></table></figure>

<p>通过class 调用方法 和 静态方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/15/JavaSeRelearn/" data-id="ckpxs73jx00003cwo9ozxec9p" data-title="JavaSeRelearn" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/06/15/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/15/JavaSeRelearn/">JavaSeRelearn</a>
          </li>
        
          <li>
            <a href="/2021/06/15/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>